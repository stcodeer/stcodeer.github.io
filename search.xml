<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性代数的几何意义</title>
      <link href="/2022/01/07/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89/"/>
      <url>/2022/01/07/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>基于3Blue1Brown科普内容的总结，关于线性代数的本质。</p><h2 id="3Blue1Brown原视频链接"><a href="#3Blue1Brown原视频链接" class="headerlink" title="3Blue1Brown原视频链接"></a>3Blue1Brown原视频链接</h2><p><a href="https://www.bilibili.com/medialist/play/watchlater/BV1ys411472E">【官方双语/合集】线性代数的本质 - 系列合集</a></p><h2 id="张成与基"><a href="#张成与基" class="headerlink" title="张成与基"></a>张成与基</h2><p>向量集合的张成是所有能表示的点所构成的线性空间。</p><p>基即最小的向量集合，使得该集合的张成等于当前线性空间。</p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>线性变换是指满足可加性，数乘性的离散函数，有输入，有输出。通俗来说，线性变换的几何意义是原点不变且直线在变换后仍为直线，更直观的表示是原点不变且网格线变换前后保持平行且等距离。</p><h2 id="矩阵与矩阵乘法"><a href="#矩阵与矩阵乘法" class="headerlink" title="矩阵与矩阵乘法"></a>矩阵与矩阵乘法</h2><p>矩阵的几何意义是线性变换，矩阵乘法的几何意义是线性变换的叠加。</p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>方阵的行列式的几何定义是有向的放缩倍率。</p><h2 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h2><p>非方阵也是高维到低维的线性变换。</p><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积的式子可以用对偶性来证明，看成对于一个向量的非方阵线性变换，使得其位于另一个向量的直线上。</p><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>二维叉积是有向面积，就是将其看作二维线性变换后的放缩倍率，即行列式。</p><p>三维叉积的面积即将两个向量和另一个单位向量（看作可变向量，但将其认为是单位向量）看作三维线性变换后得到的放缩倍率，即行列式。但最终得到的行列式实际上是个与两个向量垂直的向量，且长度才为叉积值。此处可以用对偶性来证明，将该行列式等同于求得向量与可变向量的点积，显然无论该可变向量如何变化都是成立的，可变向量在所求向量上的投影=可变向量在六面体的高，所求向量长度=底面积叉积，所以叉积的本质就是这个求得向量。</p><h2 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h2><p>特征向量是线性变换中张成空间不变的向量。</p><p>特征值是特征向量的变化率。（$A*v=\lambda*v$，$A$是线性变换矩阵，$\lambda$是特征值，$v$是特征向量）</p><h2 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h2><p>$A^{-1}*M*A$实际上是在非标准基下进行标准视角下的变换。（比如说旋转$90$度，标准基下乘上$M$即可，但是非标准基下要乘上$A^{-1}*M*A$，$A$是用来转化成标准基的线性变换矩阵）</p><p>如果可以选$n$个特征向量张成整个空间的话，那么可以将这$n$个向量看作新的基底，此时线性变换在该基底下一定是对角阵，即有$A^{-1}*M*A=D$。（$D$是对角阵）（基向量都是特征向量的话，线性变换一定是对角阵）</p><p>方阵快速幂：</p><p><img src="https://www.ipicbed.com/images/2022/01/08/l1.png" alt="方阵快速幂1"></p><p><img src="https://www.ipicbed.com/images/2022/01/08/l2.png" alt="方阵快速幂2"></p><p><img src="https://www.ipicbed.com/images/2022/01/08/l3.png" alt="方阵快速幂3"></p><p><img src="https://www.ipicbed.com/images/2022/01/08/l4.png" alt="方阵快速幂4"></p><h2 id="向量的抽象"><a href="#向量的抽象" class="headerlink" title="向量的抽象"></a>向量的抽象</h2><p>满足八大公理的结构都能被看作向量，存在线性变换，也有之前所推导的性质。例如函数也可以看作一种有无穷维度的向量，同样有基底（$1,x^1,x^2,x^3,…$）。线性变换即线性算子（如求导等，可以用无穷阶的方阵表示），点积即内积，特征向量即特征函数等等。</p><p><img src="https://www.ipicbed.com/images/2022/01/07/linear_atoms.png" alt="八大公理"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Knowledge Summary </tag>
            
            <tag> 3Blue1Brown </tag>
            
            <tag> Chinese </tag>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2022/01/04/hello%20hexo/"/>
      <url>/2022/01/04/hello%20hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ Coding Style</title>
      <link href="/2017/03/07/C%20C++%20Coding%20Style/"/>
      <url>/2017/03/07/C%20C++%20Coding%20Style/</url>
      
        <content type="html"><![CDATA[<p>C/C++代码规范。包括命名规则，排版规则，文档及注释，编码要求等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://www.ipicbed.com/images/2022/01/08/C-CodingStyle.png" alt="C/C++ Google Coding Style"></p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><h3 id="起个合适的名字"><a href="#起个合适的名字" class="headerlink" title="起个合适的名字"></a>起个合适的名字</h3><h4 id="类的名称"><a href="#类的名称" class="headerlink" title="类的名称"></a>类的名称</h4><p>类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p><p>类的名字不需要告诉我们，它从哪个类继承而来的。</p><p>有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p><h4 id="方法和函数的名称"><a href="#方法和函数的名称" class="headerlink" title="方法和函数的名称"></a>方法和函数的名称</h4><p>方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p><p>函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p><p>可以加一些必要的后缀：</p><p>Max – 表示取最大值</p><p>Cnt – 表示当前的计数值</p><p>Key – 表示键值</p><p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p><p>前缀也同样有用：</p><p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p><p>Get – 用于获取一个值。</p><p>Set – 用于设置一个值。</p><p>例如：IsHitRetryLimit。</p><h4 id="含有度量单位的名称"><a href="#含有度量单位的名称" class="headerlink" title="含有度量单位的名称"></a>含有度量单位的名称</h4><p>如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 mTimeoutMsecs;</span><br><span class="line">uint32 mMyWeightLbs;</span><br></pre></td></tr></table></figure><h4 id="缩写名称不要全部大写"><a href="#缩写名称不要全部大写" class="headerlink" title="缩写名称不要全部大写"></a>缩写名称不要全部大写</h4><p>无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FluidOz</span>;</span>            <span class="comment">// 而不是 FluidOZ</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkAbcKey</span>;</span>      <span class="comment">// 而不是 NetworkABCKey</span></span><br></pre></td></tr></table></figure><h3 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h3><p>用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p><p>名字的第一个字母应大写。</p><p>不含有下划线。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>;</span></span><br></pre></td></tr></table></figure><h3 id="类库或程序库命名"><a href="#类库或程序库命名" class="headerlink" title="类库或程序库命名"></a>类库或程序库命名</h3><p>使用命名空间防止名字冲突。</p><p>如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p><p>例如：（Tong Su 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TsLinkList</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法和函数的命名"><a href="#方法和函数的命名" class="headerlink" title="方法和函数的命名"></a>方法和函数的命名</h3><p>使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoIt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类属性的命名"><a href="#类属性的命名" class="headerlink" title="类属性的命名"></a>类属性的命名</h3><p>属性（通常是非公有数据成员）名字以字母’m’开头。</p><p>在 ‘m(m_)’ 后面，使用与类名相同的规则。</p><p>‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">VarAbc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ErrorNumber</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mVarAbc;</span><br><span class="line"><span class="keyword">int</span> mErrorNumber;</span><br><span class="line">String* mpName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法和函数参数的命名"><a href="#方法和函数参数的命名" class="headerlink" title="方法和函数参数的命名"></a>方法和函数参数的命名</h3><p>第一个字母必须小写。</p><p>第一个字母后面的单词使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StartYourEngines</span><span class="params">(Engine&amp;rSomeEngine,Engine&amp;rAnotherEngine)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量的命名"><a href="#局部变量的命名" class="headerlink" title="局部变量的命名"></a>局部变量的命名</h3><p>所有字母都用小写。</p><p>使用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NameOneTwo::HandleError</span><span class="params">(<span class="keyword">int</span> errorNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error= <span class="built_in">OsErr</span>();</span><br><span class="line">Time time_of_error;</span><br><span class="line">ErrorProcessor error_processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针变量的命名前缀"><a href="#指针变量的命名前缀" class="headerlink" title="指针变量的命名前缀"></a>指针变量的命名前缀</h3><p>指针变量多数情况应在前面加 ‘p’。</p><p>星号应靠近类型，而不是变量名。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String* pName=<span class="keyword">new</span> String;</span><br></pre></td></tr></table></figure><p>特别的：String* pName, name; 应分成两行来写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String* pName;</span><br><span class="line">String  name;</span><br></pre></td></tr></table></figure><h3 id="引用变量和返回引用函数的命名前缀"><a href="#引用变量和返回引用函数的命名前缀" class="headerlink" title="引用变量和返回引用函数的命名前缀"></a>引用变量和返回引用函数的命名前缀</h3><p>引用必须用‘r’作前缀修饰。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(StatusInfo&amp;rStatus)</span></span>;</span><br><span class="line"><span class="function">StatusInfo&amp; <span class="title">rStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">constStatusInfo&amp; <span class="title">Status</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 这里返回的是常量引用，所以不符合本规则</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StatusInfo&amp; mrStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局变量的命名前缀"><a href="#全局变量的命名前缀" class="headerlink" title="全局变量的命名前缀"></a>全局变量的命名前缀</h3><p>全局变量总是以 ‘g(g_)’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger g_Log;</span><br><span class="line">Logger* g_pLog;</span><br></pre></td></tr></table></figure><h3 id="全局常量的命名"><a href="#全局常量的命名" class="headerlink" title="全局常量的命名"></a>全局常量的命名</h3><p>全局常量全部大写，并以下划线分隔单词。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> intA_GLOBAL_CONSTANT = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="静态变量的命名前缀"><a href="#静态变量的命名前缀" class="headerlink" title="静态变量的命名前缀"></a>静态变量的命名前缀</h3><p>静态变量以 ‘s’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">staticStatusInfo m_sStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类型typedef的命名"><a href="#自定义类型typedef的命名" class="headerlink" title="自定义类型typedef的命名"></a>自定义类型typedef的命名</h3><p>类型定义名称指的是用typedef定义的名称。</p><p>类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint16  ModuleType;</span><br><span class="line"><span class="keyword">typedef</span> uint32  SystemType;</span><br></pre></td></tr></table></figure><h3 id="宏定义的命名"><a href="#宏定义的命名" class="headerlink" title="宏定义的命名"></a>宏定义的命名</h3><p>所有单词的字母都用大写，并使用下划线分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) blah</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ERR(err) blah</span></span><br></pre></td></tr></table></figure><h3 id="C-函数的命名"><a href="#C-函数的命名" class="headerlink" title="C 函数的命名"></a>C 函数的命名</h3><p>C++项目中，应尽量少用C函数。</p><p>C函数使用GNU规范，所有字母都使用小写，并用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，为了兼容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” <span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>或在C/C++中推荐使用下面的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef__cplusplus__</span><br><span class="line"><span class="keyword">extern</span> “C”&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">#ifdef__cplusplus__</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="枚举的命名"><a href="#枚举的命名" class="headerlink" title="枚举的命名"></a>枚举的命名</h3><p>所有字母都大写，并用下划线作为单词分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enumPinStateType&#123;</span><br><span class="line">PIN_OFF,</span><br><span class="line">PIN_ON;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>STATE_ERR,STATE_OPEN,STATE_RUNNING,STATE_DYING&#125;;</span><br></pre></td></tr></table></figure><h2 id="排版规则"><a href="#排版规则" class="headerlink" title="排版规则"></a>排版规则</h2><h3 id="布局和模板"><a href="#布局和模板" class="headerlink" title="布局和模板"></a>布局和模板</h3><h4 id="类的布局模板"><a href="#类的布局模板" class="headerlink" title="类的布局模板"></a>类的布局模板</h4><p>请使用下面的模板来创建一个新的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment"> * 用一行来描述类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *#include &quot;XX.h&quot; &lt;BR&gt;</span></span><br><span class="line"><span class="comment"> *-llib</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类的详细说明</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @seesomething</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="comment">// 在这里包含系统头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含项目头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含局部头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置前置引用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XX</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 类的生命周期控制函数，如构造和析构，以及状态机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***Default constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">/***Copy constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">const</span> XX&amp; from);</span><br><span class="line"><span class="comment">/***Destructor.*/</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 在这里放置类的运算操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Assignment operator.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@param from THe value to assign to this object.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@return A reference to this object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">XX&amp; <span class="keyword">operator</span>=(XX&amp;from); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的操作                      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置属性存取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的状态查询</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 内联方法定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>定义的顺序是: public, protected, private。</p><p>要清楚public/protected/private都应该放置哪些东西。</p><h4 id="保护头文件不被重复包含"><a href="#保护头文件不被重复包含" class="headerlink" title="保护头文件不被重复包含"></a>保护头文件不被重复包含</h4><p>应使用宏定义来保护头文件不被重复包含：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>如果使用命名空间的时候，要把命名空间加到文件名前面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="方法和函数的布局"><a href="#方法和函数的布局" class="headerlink" title="方法和函数的布局"></a>方法和函数的布局</h4><p>对于有较多参数的函数的写法。</p><p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg1, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg2,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg4)</span></span>; </span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(<span class="keyword">int</span> arg1 </span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg2</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg3</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg4)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="尽量使一行不要超过78个字母"><a href="#尽量使一行不要超过78个字母" class="headerlink" title="尽量使一行不要超过78个字母"></a>尽量使一行不要超过78个字母</h3><p>有许多编辑器屏幕只有78个字母宽。</p><h3 id="保证一行只写一条语句"><a href="#保证一行只写一条语句" class="headerlink" title="保证一行只写一条语句"></a>保证一行只写一条语句</h3><p>一行最多只写一条语句。</p><p>一行只定义一个变量。</p><h3 id="圆括号规则"><a href="#圆括号规则" class="headerlink" title="圆括号规则"></a>圆括号规则</h3><p>圆括号与关键字之间应放一个空格。</p><p>圆括号与函数名之间不要有空格。</p><p>Return 语句不要使用圆括号。</p><h3 id="使用goto-continue-break-和"><a href="#使用goto-continue-break-和" class="headerlink" title="使用goto continue break 和?:"></a>使用goto continue break 和?:</h3><h4 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h4><p>尽量避免使用Goto 语句。</p><h4 id="Continue-and-Break"><a href="#Continue-and-Break" class="headerlink" title="Continue and Break"></a>Continue and Break</h4><p>Continue和break实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p><h4 id="A-B-C"><a href="#A-B-C" class="headerlink" title="A?B:C"></a>A?B:C</h4><p>用括号把条件表达式括起来。</p><p>不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p><p>操作语句应分行写，除非它们能够简洁的放在一行当中。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(condition) ?<span class="built_in">funct1</span>() : <span class="built_in">func2</span>();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(condition)</span><br><span class="line">? longstatement</span><br><span class="line">: anotherlong statement;</span><br></pre></td></tr></table></figure><h3 id="运算符号的规则"><a href="#运算符号的规则" class="headerlink" title="运算符号的规则"></a>运算符号的规则</h3><p>一元操作符如（!、~ 等等）应贴近操作对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IsOk)</span><br><span class="line">    <span class="keyword">return</span> ++v;</span><br></pre></td></tr></table></figure><p>二元操作符如（+、%、== 等等）应在前后留空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 == v2)</span><br><span class="line">     <span class="keyword">return</span> v1 * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。</p><h3 id="变量声明语句块"><a href="#变量声明语句块" class="headerlink" title="变量声明语句块"></a>变量声明语句块</h3><p>变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。</p><p>声明语句块必须要对齐。类型，变量，等号和初始化值要分别对齐。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DWORD      mDword;</span><br><span class="line">DWORD*     mpDword;</span><br><span class="line"><span class="keyword">char</span>*      mpChar;</span><br><span class="line"><span class="keyword">char</span>       mChar;</span><br><span class="line"></span><br><span class="line">mDword     =    <span class="number">0</span>;</span><br><span class="line">mpDword    =    <span class="literal">NULL</span>;</span><br><span class="line">mpChar     =    <span class="literal">NULL</span>;</span><br><span class="line">mChar      =    <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="文档及注释"><a href="#文档及注释" class="headerlink" title="文档及注释"></a>文档及注释</h2><p>应当使用文档自动生成工具，来生成相关的程序文档。</p><h3 id="文件或程序库的文档注释"><a href="#文件或程序库的文档注释" class="headerlink" title="文件或程序库的文档注释"></a>文件或程序库的文档注释</h3><p>可以为整个文件编写文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @file file.h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Abrief file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Amore elaborated file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="类文档注释"><a href="#类文档注释" class="headerlink" title="类文档注释"></a>类文档注释</h3><p>在类定义前面应加上类说明文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** WindowsNT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @brief Windows Nice Try.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Bill Gates</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Several species of small furryanimals gathered together</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *          in a cave and grooving with a pict.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @version 4.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @date   1996-1998</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug It crashes a lot and requires hugeamounts of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug The class introduces the more bugs, thelonger it is used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning This class may explode in your face.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning If you inherit anything from thisclass, you&#x27;re doomed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsNT</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="函数文档注释"><a href="#函数文档注释" class="headerlink" title="函数文档注释"></a>函数文档注释</h3><p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 赋值操作符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param val 将要赋给本对象的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return 本对象的引用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">XX&amp;  <span class="keyword">operator</span> =(XX&amp; val);</span><br></pre></td></tr></table></figure><p>注释属性</p><p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p><p>n 前提条件 (pre)<br>定义调用这个函数的前提条件</p><p>n 警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p><p>n 备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p><p>n 将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成。</p><p>n 使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 复制一个字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@pre</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(from != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(to != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@warning</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 缓冲区必需足够大，以便容纳的下要拷贝的字串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@example teststrcpy.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param from 要拷贝的字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param to 用于容纳字串的缓冲区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return void</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">strcpy</span><span class="params">(constchar* from, <span class="keyword">char</span>* to)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Include-语句注释"><a href="#Include-语句注释" class="headerlink" title="Include 语句注释"></a>Include 语句注释</h3><p>如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p><h3 id="语句块注释"><a href="#语句块注释" class="headerlink" title="语句块注释"></a>语句块注释</h3><p>语句块的注释可以用在语句块的开头和结束位置：</p><h2 id="编码要求"><a href="#编码要求" class="headerlink" title="编码要求"></a>编码要求</h2><h3 id="不要忽略编译器的警告"><a href="#不要忽略编译器的警告" class="headerlink" title="不要忽略编译器的警告"></a>不要忽略编译器的警告</h3><p>编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p><h3 id="应使用源代码管理器"><a href="#应使用源代码管理器" class="headerlink" title="应使用源代码管理器"></a>应使用源代码管理器</h3><p>根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p><h3 id="固有的类方法成员"><a href="#固有的类方法成员" class="headerlink" title="固有的类方法成员"></a>固有的类方法成员</h3><p>默认构造函数(DefaultConstructor)</p><p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p><p>虚析构函数(Virtual Destructor)</p><p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p><p>拷贝构造函数(Copy Constructor)</p><p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p><p>赋值操作(AssignmentOperator)</p><p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>根名字一般是设计者的名字。比如公司名称等等。</p><p>不要在全局空间使用using语句。</p><h3 id="初始化所有的变量"><a href="#初始化所有的变量" class="headerlink" title="初始化所有的变量"></a>初始化所有的变量</h3><p>无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p><h3 id="保持函数短小精悍"><a href="#保持函数短小精悍" class="headerlink" title="保持函数短小精悍"></a>保持函数短小精悍</h3><p>一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p><h3 id="对空语句进行注释"><a href="#对空语句进行注释" class="headerlink" title="对空语句进行注释"></a>对空语句进行注释</h3><p>For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(*dest++ = *srC++)</span><br><span class="line">   ;<span class="comment">// VOID</span></span><br></pre></td></tr></table></figure><h3 id="不要用if语句的默认方法测试非零值"><a href="#不要用if语句的默认方法测试非零值" class="headerlink" title="不要用if语句的默认方法测试非零值"></a>不要用if语句的默认方法测试非零值</h3><p>If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值。</p><p>建议使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>() != FAIL)</span><br></pre></td></tr></table></figure><p>不建议使用下面的表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>())</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p><h3 id="避免在语句中内含赋值"><a href="#避免在语句中内含赋值" class="headerlink" title="避免在语句中内含赋值"></a>避免在语句中内含赋值</h3><p>只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (EOF != (c= <span class="built_in">getchar</span>()))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确的使用Const"><a href="#正确的使用Const" class="headerlink" title="正确的使用Const"></a>正确的使用Const</h3><p>C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p><h3 id="不要在头文件定义数据"><a href="#不要在头文件定义数据" class="headerlink" title="不要在头文件定义数据"></a>不要在头文件定义数据</h3><p>不要把数据定义放在头文件。</p><h3 id="不要直接使用数字"><a href="#不要直接使用数字" class="headerlink" title="不要直接使用数字"></a>不要直接使用数字</h3><p>直接使用数字，会使源代码难以理解和维护。我们可以用#define或者常量来改变这一状况。</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>如果可以，使用内联函数代替宏。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    <span class="comment">// 取最大数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>使用内联函数可以达到相同的效果，而且更安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt; y ? x : y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x + y</span></span><br></pre></td></tr></table></figure><p>必须写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure><p>和全局变量一样，宏也会与其它名称产生冲突。</p><p>下面两条规则有助于解决这个问题：</p><p>一、在宏名称前加上库的名字</p><p>二、避免使用简单而常用的名字，如：MAX和MIN。</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Coding Style </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
