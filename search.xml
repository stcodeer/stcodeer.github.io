<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown与Mathjax的冲突</title>
      <link href="/2022/01/09/Markdown-Mathjax/"/>
      <url>/2022/01/09/Markdown-Mathjax/</url>
      
        <content type="html"><![CDATA[<p>关于Markdown与Mathjax的冲突以及解决方案。</p><p>为了进一步解决冲突问题，详见<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">Mathjax的配置方法</a>。</p><h1 id="冲突1"><a href="#冲突1" class="headerlink" title="冲突1"></a>冲突1</h1><p>有些特殊符号在Markdown与Mathjax中存在表达冲突的问题，如星号（*）在Markdown中可以表示斜体或加粗，在Mathjax中可以表示乘法。</p><p>为了解决冲突，可以在Mathjax中使用Markdown中的转义符（\）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a \* b$</span><br></pre></td></tr></table></figure><p>将会输出为：</p><p>$a * b$</p><p>这种解决方法会导致Latex的语法发生变化，需要注意。</p><h1 id="冲突2"><a href="#冲突2" class="headerlink" title="冲突2"></a>冲突2</h1><p>为了输出大括号，不能在Mathjax中使用如下语法，此处方案会导致大括号不显示。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\&#123; A \&#125;$</span><br></pre></td></tr></table></figure><p>而应使用：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\lbrace A \rbrace$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$\lbrace A \rbrace$</p><h1 id="冲突3"><a href="#冲突3" class="headerlink" title="冲突3"></a>冲突3</h1><p>由于’\‘会被认作Markdown中的转义符号，因此在Mathjax中无法通过’\%’的方式输出百分号，目前没有很好的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Butterfly 基本用法</title>
      <link href="/2022/01/09/Hexo-basis/"/>
      <url>/2022/01/09/Hexo-basis/</url>
      
        <content type="html"><![CDATA[<p>关于Hexo如何生成，测试，上传博客，博客内的基本语法，以及Butterfly主题如何更改配置文件。</p><h1 id="Hexo语法"><a href="#Hexo语法" class="headerlink" title="Hexo语法"></a>Hexo语法</h1><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>通过配置文件，sources文件夹（包含博客以及其他页面文件）生成public文件夹。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>将public文件夹以本地为服务器，生成博客内容，网址为<a href="http://localhost:4000/">http://localhost:4000/</a>。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>将public文件夹上传至Github，利用Github做服务器，生成博客内容。</p><h2 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清空public文件夹，清空缓存，适用于修改配置文件后，生成public文件夹前。</p><h1 id="Hexo-Markdown-Mathjax-Butterfly-博客内语法"><a href="#Hexo-Markdown-Mathjax-Butterfly-博客内语法" class="headerlink" title="Hexo + Markdown + Mathjax + Butterfly 博客内语法"></a>Hexo + Markdown + Mathjax + Butterfly 博客内语法</h1><h2 id="Hexo前缀（Front-matter）"><a href="#Hexo前缀（Front-matter）" class="headerlink" title="Hexo前缀（Front-matter）"></a>Hexo前缀（Front-matter）</h2><p>在博客前，需要添加Front-matter以确定该博客的基本属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Template</span><br><span class="line">//博客标题</span><br><span class="line">date: 2099-01-01 00:00:00</span><br><span class="line">//博客创建时间，缺省为.md创建时间，如果该时间晚于当前时间，则为定时发布（可在主题config的future中调整）</span><br><span class="line">updated: 2099-01-01 00:00:00</span><br><span class="line">//博客更新时间，缺省为.md更新时间</span><br><span class="line">tags: [Chinese,Hexo]</span><br><span class="line">//博客标签（Chinese,Hexo两个标签并列）</span><br><span class="line">categories: [A,B]</span><br><span class="line">//博客分类（A,B两个分类嵌套，B是子分类）</span><br><span class="line">description: About Hexo.</span><br><span class="line">//博客简介，显示在首页或归档中，博客外</span><br><span class="line">cover: http://xx/1.jpg</span><br><span class="line">//博客封面</span><br><span class="line">comments: true/false</span><br><span class="line">//开启评论功能，默认为true</span><br></pre></td></tr></table></figure><h2 id="Markdown-Mathjax基本语法"><a href="#Markdown-Mathjax基本语法" class="headerlink" title="Markdown+Mathjax基本语法"></a>Markdown+Mathjax基本语法</h2><p>博客基本语法即Markdown+Mathjax语法。</p><h3 id="关于Markdown与Mathjax的冲突"><a href="#关于Markdown与Mathjax的冲突" class="headerlink" title="关于Markdown与Mathjax的冲突"></a>关于Markdown与Mathjax的冲突</h3><p>为了进一步解决冲突问题，详见<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">Mathjax的配置方法</a>。</p><h4 id="冲突1"><a href="#冲突1" class="headerlink" title="冲突1"></a>冲突1</h4><p>有些特殊符号在Markdown与Mathjax中存在表达冲突的问题，如星号（*）在Markdown中可以表示斜体或加粗，在Mathjax中可以表示乘法。</p><p>为了解决冲突，可以在Mathjax中使用Markdown中的转义符（\）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a \* b$</span><br></pre></td></tr></table></figure><p>将会输出为：</p><p>$a * b$</p><p>这种解决方法会导致Latex的语法发生变化，需要注意。</p><h4 id="冲突2"><a href="#冲突2" class="headerlink" title="冲突2"></a>冲突2</h4><p>为了输出大括号，不能在Mathjax中使用:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\&#123; A \&#125;$</span><br></pre></td></tr></table></figure><p>而应使用：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\lbrace A \rbrace$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$\lbrace A \rbrace$</p><h2 id="Butterfly主题自创语法"><a href="#Butterfly主题自创语法" class="headerlink" title="Butterfly主题自创语法"></a>Butterfly主题自创语法</h2><div class="note warning modern"><p>该语法仅适用于Butterfly主题，在其他主题下可能会出现错误。</p></div><h3 id="提示标签"><a href="#提示标签" class="headerlink" title="提示标签"></a>提示标签</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">none</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div class="note modern"><p>none</p></div><div class="note default modern"><p>default</p></div><div class="note primary modern"><p>primary</p></div><div class="note success modern"><p>success</p></div><div class="note info modern"><p>info</p></div><div class="note warning modern"><p>warning</p></div><div class="note danger modern"><p>danger</p></div><h3 id="选择标签"><a href="#选择标签" class="headerlink" title="选择标签"></a>选择标签</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tabname %&#125;</span><br><span class="line">&lt;!-- tab name1 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab name2 --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab name3 --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div class="tabs" id="tabname"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tabname-1">name1</button></li><li class="tab"><button type="button" data-href="#tabname-2">name2</button></li><li class="tab"><button type="button" data-href="#tabname-3">name3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tabname-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>更多更详细的用法见<a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly的标签外挂</a>。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="新建页"><a href="#新建页" class="headerlink" title="新建页"></a>新建页</h2><p>在导览菜单中修改，使得右上角出现选项（<a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%B0%8E%E8%88%AA%E8%8F%9C%E5%96%AE">详细操作</a>）。</p><p>在source/pagename中添加页文件，基本语法与博客文件相同（<a href="https://butterfly.js.org/posts/dc584b87/#Page-Front-matter">详细操作</a>）。</p><p>可以加入个人介绍页，简历页等等。</p><h2 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E7%B6%B2%E7%AB%99%E8%B3%87%E6%96%99">详细操作</a></p><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E9%A0%82%E9%83%A8%E5%9C%96">详细操作</a></p><p>可直接通过主题配置文件中的 disable_top_img: true/false 来控制顶部图的启用与关闭。</p><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h2 id="Footer-设置"><a href="#Footer-设置" class="headerlink" title="Footer 设置"></a>Footer 设置</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%8D%9A%E5%AE%A2%E5%B9%B4%E4%BB%BD">详细操作</a></p><p>可在其中加入备案信息。</p><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><p>Butterfly支持评论，图库，在线聊天，分享，搜索系统，网站验证，站点分析统计，广告，美化特效，CDN等等更多功能。</p><p>详见：<a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安装文档(四) 主题配置-2</a></p><p>Butterfly支持音乐，豆瓣电影，说说，自定义代码配色，自定义侧边栏，图片压缩等等更多功能。</p><p>详见：<a href="https://butterfly.js.org/posts/4073eda/">Butterfly 安装文档(六) 进阶教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数的几何意义</title>
      <link href="/2022/01/07/linear-geometry/"/>
      <url>/2022/01/07/linear-geometry/</url>
      
        <content type="html"><![CDATA[<p>基于3Blue1Brown科普内容的总结，关于线性代数的本质。</p><h1 id="3Blue1Brown原视频链接"><a href="#3Blue1Brown原视频链接" class="headerlink" title="3Blue1Brown原视频链接"></a>3Blue1Brown原视频链接</h1><p><a href="https://www.bilibili.com/medialist/play/watchlater/BV1ys411472E">【官方双语/合集】线性代数的本质 - 系列合集</a></p><h1 id="张成与基"><a href="#张成与基" class="headerlink" title="张成与基"></a>张成与基</h1><p>向量集合的张成是所有能表示的点所构成的线性空间。</p><p>基即最小的向量集合，使得该集合的张成等于当前线性空间。</p><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><p>线性变换是指满足可加性，数乘性的离散函数，有输入，有输出。通俗来说，线性变换的几何意义是原点不变且直线在变换后仍为直线，更直观的表示是原点不变且网格线变换前后保持平行且等距离。</p><h1 id="矩阵与矩阵乘法"><a href="#矩阵与矩阵乘法" class="headerlink" title="矩阵与矩阵乘法"></a>矩阵与矩阵乘法</h1><p>矩阵的几何意义是线性变换，矩阵乘法的几何意义是线性变换的叠加。</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>方阵的行列式的几何定义是有向的放缩倍率。</p><h1 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h1><p>非方阵也是高维到低维的线性变换。</p><h1 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h1><p>点积的式子可以用对偶性来证明，看成对于一个向量的非方阵线性变换，使得其位于另一个向量的直线上。</p><h1 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h1><p>二维叉积是有向面积，就是将其看作二维线性变换后的放缩倍率，即行列式。</p><p>三维叉积的面积即将两个向量和另一个单位向量（看作可变向量，但将其认为是单位向量）看作三维线性变换后得到的放缩倍率，即行列式。但最终得到的行列式实际上是个与两个向量垂直的向量，且长度才为叉积值。此处可以用对偶性来证明，将该行列式等同于求得向量与可变向量的点积，显然无论该可变向量如何变化都是成立的，可变向量在所求向量上的投影=可变向量在六面体的高，所求向量长度=底面积叉积，所以叉积的本质就是这个求得向量。</p><h1 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h1><p>特征向量是线性变换中张成空间不变的向量。</p><p>特征值是特征向量的变化率。（$A*v=\lambda*v$，$A$是线性变换矩阵，$\lambda$是特征值，$v$是特征向量）</p><h1 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h1><p>$A^{-1}*M*A$实际上是在非标准基下进行标准视角下的变换。（比如说旋转$90$度，标准基下乘上$M$即可，但是非标准基下要乘上$A^{-1}*M*A$，$A$是用来转化成标准基的线性变换矩阵）</p><p>如果可以选$n$个特征向量张成整个空间的话，那么可以将这$n$个向量看作新的基底，此时线性变换在该基底下一定是对角阵，即有$A^{-1}*M*A=D$。（$D$是对角阵）（基向量都是特征向量的话，线性变换一定是对角阵）</p><p>方阵快速幂：</p><p><img src="https://s2.loli.net/2022/01/12/edGbqpD8MwLSWtN.png" alt="方阵快速幂1"></p><p><img src="https://s2.loli.net/2022/01/12/LjBYEUGC5ypMlQv.png" alt="方阵快速幂2"></p><p><img src="https://s2.loli.net/2022/01/12/kfto6GVTlyKPpru.png" alt="方阵快速幂3"></p><p><img src="https://s2.loli.net/2022/01/12/DBfA7Whi6JQarGL.png" alt="方阵快速幂4"></p><h1 id="向量的抽象"><a href="#向量的抽象" class="headerlink" title="向量的抽象"></a>向量的抽象</h1><p>满足八大公理的结构都能被看作向量，存在线性变换，也有之前所推导的性质。例如函数也可以看作一种有无穷维度的向量，同样有基底（$1,x^1,x^2,x^3,…$）。线性变换即线性算子（如求导等，可以用无穷阶的方阵表示），点积即内积，特征向量即特征函数等等。</p><p><img src="https://s2.loli.net/2022/01/12/dBSCsLpNVnvT3iy.png" alt="八大公理"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Linear Algebra </tag>
            
            <tag> 3Blue1Brown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2022/01/04/hello-hexo/"/>
      <url>/2022/01/04/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces811E Vladik and Entertaining Flags</title>
      <link href="/2017/06/08/Codeforces811E-Vladik/"/>
      <url>/2017/06/08/Codeforces811E-Vladik/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/06/08/Codeforces811E/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/contest/811/problem/E">Vladik and Entertaining Flags</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/FNgP8xJrMHlCSYm.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑到$n$的范围较小，可以直接通过并查集暴力每一列的联通性，每次询问通过归并查询，可以先用线段树预处理以降低时间复杂度。</p><p>$ls，rs$数组表示当前需要合并的$[l,r]$的左右两边的连通性，归并时向上更新，$l,r$数组表示线段树当前节点的$[l,r]$的连通性，需要提前预处理。对于合并操作，考虑需要合并的两个区间，连通性改变的部分只有两个区间相邻的部分，同样可以通过并查集暴力求解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>][N],l[N*<span class="number">2</span>][<span class="number">13</span>],sum[N*<span class="number">2</span>],r[N*<span class="number">2</span>][<span class="number">13</span>],rs[<span class="number">11</span>],ls[<span class="number">11</span>],n,m,cnt,q;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">13</span>*N*<span class="number">2</span>],flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> f[x]==x?x:f[x]=<span class="built_in">gf</span>(f[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls=x*<span class="number">2</span>,rs=x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    sum[x]=sum[ls]+sum[rs];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[l[ls][i]]=l[ls][i];</span><br><span class="line">        f[r[rs][i]]=r[rs][i];</span><br><span class="line">        f[l[rs][i]]=l[rs][i];</span><br><span class="line">        f[r[ls][i]]=r[ls][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(a[i][mid]==a[i][mid+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1=<span class="built_in">gf</span>(l[rs][i]),t2=<span class="built_in">gf</span>(r[ls][i]);</span><br><span class="line">        <span class="keyword">if</span>(t1!=t2)</span><br><span class="line">        &#123;</span><br><span class="line">            f[t1]=t2;</span><br><span class="line">            sum[x]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    l[x][i]=<span class="built_in">gf</span>(l[ls][i]),r[x][i]=<span class="built_in">gf</span>(r[rs][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll==rr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i][ll]==a[i<span class="number">-1</span>][ll])l[x][i]=r[x][i]=l[x][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span>    l[x][i]=r[x][i]=++cnt,sum[x]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ll,mid,x*<span class="number">2</span>);<span class="built_in">build</span>(mid+<span class="number">1</span>,rr,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(ll,rr,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lss=now*<span class="number">2</span>,rss=now*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=ll&amp;&amp;rr&lt;=y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ls[i]=l[now][i],rs[i]=r[now][i];</span><br><span class="line">            <span class="keyword">return</span> sum[now];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret=sum[now];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[ls[i]]=ls[i];</span><br><span class="line">            f[rs[i]]=rs[i];</span><br><span class="line">            f[l[now][i]]=l[now][i];</span><br><span class="line">            f[r[now][i]]=r[now][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][ll]==a[i][ll<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t1=<span class="built_in">gf</span>(rs[i]),t2=<span class="built_in">gf</span>(l[now][i]);</span><br><span class="line">                <span class="keyword">if</span>(t1!=t2)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[t2]=t1;</span><br><span class="line">                    ret--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ls[i]=<span class="built_in">gf</span>(ls[i]),rs[i]=<span class="built_in">gf</span>(r[now][i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) ret+=<span class="built_in">mergesort</span>(ll,mid,x,y,now*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;y)    ret+=<span class="built_in">mergesort</span>(mid+<span class="number">1</span>,rr,x,y,now*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=m;++t)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][t]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,ll,rr;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ll,&amp;rr);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">mergesort</span>(<span class="number">1</span>,m,ll,rr,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化线段树总结</title>
      <link href="/2017/06/07/Persistent-Segment-Tree/"/>
      <url>/2017/06/07/Persistent-Segment-Tree/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/06/07/%E4%B8%BB%E5%B8%AD%E6%A0%91%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>主席树又称可持久化线段树，相对与普通的线段树，其解决的是各种不适用于结合律的区间问题，诸如区间第$K$大，区间种类个数等。</p><p>线段树的每个结点，保存的是这个区间含有的数字的性质的结合。</p><p>主席树的每个结点，保存的元素以元素大小为第一维位置，同时保证以区间为第二维位置，直接实现是$O(nlog^2n)$的时间空间复杂度，即每一个区间都要建一棵树，考虑每颗线段树的大小和形态是一样的，那么我们便可以利用主席树之间相互进行加减运算的性质，进行可持久化建树。</p><p>具体过程是按区间位置进行建树，每次插入新的数，只需要重新插入一条链，因为对于那些性质没有改变的前缀（如插入元素的位置是$3$，那么节点：$[1,2]$就没有必要改变），只需要重新调用皆可，否则利用原节点建一个新的节点（如插入元素的位置是$3$，那么节点：$[3,4]$的性质一定发生了改变，但又要保证原区间的该节点性质不变，那么便可以先将该节点粘过来，再在此基础上建一个新的节点，插入在当前根节点下），这样时间空间复杂度均降到了$O(nlogn)$（可持久化线段树按权值建树，其时间复杂度实际与权值范围有关（所以要离散化），本文全部以$n$代替）。</p><p>当然，这样实现也会导致整个数据结构实际上完全不是一棵树了，但是却仍满足每个节点最多有两个后继的限制，因此查询时只要调用$l−1,r$两个根节点即可。</p><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="NEERC-2004-K小数"><a href="#NEERC-2004-K小数" class="headerlink" title="NEERC 2004 K小数"></a>NEERC 2004 K小数</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vNyzJkgjq">COGS 1534</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/uPagd2bSBC1wA79.png" alt="题目描述"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>实现与按权值维护的平衡树类似，直接递归查询即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,totn,a[N],b[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ls,rs,sum;&#125;t[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> tot,root[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y=++tot;</span><br><span class="line">    t[y]=t[x];t[y].sum+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;=mid)     <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,v);</span><br><span class="line">    <span class="keyword">else</span>         <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v=t[t[y].ls].sum-t[t[x].ls].sum;</span><br><span class="line">    <span class="keyword">if</span>(v&gt;=k)     <span class="keyword">return</span> <span class="built_in">get</span>(l,mid,t[x].ls,t[y].ls,k);</span><br><span class="line">    <span class="keyword">else</span>         <span class="keyword">return</span> <span class="built_in">get</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k-v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;kthnumber.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;kthnumber.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    totn=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="built_in">insert</span>(<span class="number">1</span>,totn,root[i<span class="number">-1</span>],root[i],<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>,a[i])-b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z),</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[<span class="built_in">get</span>(<span class="number">1</span>,totn,root[x<span class="number">-1</span>],root[y],z)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDOI2009-HH的项链"><a href="#SDOI2009-HH的项链" class="headerlink" title="SDOI2009 HH的项链"></a>SDOI2009 HH的项链</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=pJSmJNqVk">COGS 421</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/LGKbWFM2973pHgl.png" alt="题目描述"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>对于每一个元素，记录其在数列内下一个种类相同的元素的位置（以 $to$ 数组表示），那么问题就转化为了求区间内有多少个元素的 $to$ 值大于查询的右区间位置，将 $to$ 数组插入到主席树中，直接建树求解即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> rs,ls,sum;&#125;t[N*<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],tot,b[N],totn,n,m,root[N],vis[N],to[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y=++tot;</span><br><span class="line">    t[y]=t[x];</span><br><span class="line">    t[y].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)    <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,k);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;v)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=v)<span class="keyword">return</span> t[y].sum-t[x].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(l,mid,t[x].ls,t[y].ls,v)+<span class="built_in">get</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;diff.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;diff.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(vis[x])to[vis[x]]=i;</span><br><span class="line">        vis[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(!to[i])to[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>,n+<span class="number">1</span>,root[i<span class="number">-1</span>],root[i],to[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(<span class="number">1</span>,n+<span class="number">1</span>,root[l<span class="number">-1</span>],root[r],r+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态排名系统"><a href="#动态排名系统" class="headerlink" title="动态排名系统"></a>动态排名系统</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=pxQyzzVgW">COGS 257</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/TzIO5qZslLu9WKX.png" alt="题目描述"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>本题为裸的带修改区间第$K$大，如果直接在例$1$的基础上修改，则会导致超时，因为每次修改都要修改$nlogn$个节点，即最坏情况下每一个根都要修改$log$个没有指向前面节点的节点。那么可以考虑，主席树维护的实际上是数列的前缀的性质，可以利用树状数组优化，即将原先的对于每一个新元素的前缀建树，改为对于树状数组中的前缀建树，那么修改时只要修改$log^2n$个节点即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ls,rs,sum;&#125;t[N];</span><br><span class="line"><span class="keyword">int</span> T,n,m,A[N],B[N],C[N],b[N],a[N],X[N],Y[N],root[N],totx,toty,totn,tot;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y=++tot;</span><br><span class="line">    t[y]=t[x];</span><br><span class="line">    t[y].sum+=v;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)    <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,k,v);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k,v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>,a[x])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>,totn,root[i],root[i],k,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totx;++i)sum-=t[t[X[i]].ls].sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=toty;++i)sum+=t[t[Y[i]].ls].sum;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X[i]].ls;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y[i]].ls;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l,mid,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X[i]].rs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y[i]].rs;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dynrank.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dynrank.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(C));</span><br><span class="line">        totn=tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i),b[++totn]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s,A+i,B+i);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,C+i);</span><br><span class="line">            <span class="keyword">else</span>            b[++totn]=B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>);</span><br><span class="line">        totn=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span>(C[i])</span><br><span class="line">        &#123;</span><br><span class="line">            totx=toty=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i]<span class="number">-1</span>;j;j-=<span class="built_in">lowbit</span>(j))X[++totx]=root[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=B[i];j;j-=<span class="built_in">lowbit</span>(j))    Y[++toty]=root[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[<span class="built_in">query</span>(<span class="number">1</span>,totn,C[i])]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">-1</span>);</span><br><span class="line">            a[A[i]]=B[i];</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="国家集训队2011-数颜色"><a href="#国家集训队2011-数颜色" class="headerlink" title="国家集训队2011 数颜色"></a>国家集训队2011 数颜色</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vNNmNkPak">COGS 1901</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/OGpCSVIrtsglvd5.png" alt="题目描述"></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>同样是记录 $to$ 数组，对于修改操作，可以暴力求出修改后该位置 $to$ 的变化，考虑一下可能造成的在该元素前的元素的 $to$ 指针的变化即可（注意同样要修改主席树），详见代码。（对于$to$数组的查询和修改可以用平衡树优化）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span>ll ls,rs,sum;&#125;t[N*<span class="number">600</span>];</span><br><span class="line">ll n,m,a[N],b[N],X[<span class="number">55</span>],Y[<span class="number">55</span>],A[N],B[N],C[N],to[N],vis[<span class="number">1000001</span>];</span><br><span class="line">ll root[N],totn,tot,totx,toty;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll l,ll r,ll x,ll &amp;y,ll k,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!y)&#123;y=++tot;t[y]=t[x];&#125;</span><br><span class="line">    t[y].sum+=v;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)    <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,k,v);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k,v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=x;i&lt;=n+<span class="number">1</span>;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>,n+<span class="number">1</span>,root[i],root[i],to[x],v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll l,ll r,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;v)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=v)</span><br><span class="line">    &#123;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)sum-=t[X[i]].sum;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)sum+=t[Y[i]].sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ll X1[<span class="number">55</span>],Y1[<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)X1[i]=X[i];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)Y1[i]=Y[i];</span><br><span class="line"></span><br><span class="line">    ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X1[i]].ls;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y1[i]].ls;</span><br><span class="line">    sum+=<span class="built_in">get</span>(l,mid,v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X1[i]].rs;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y1[i]].rs;</span><br><span class="line">    sum+=<span class="built_in">get</span>(mid+<span class="number">1</span>,r,v);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;nt2011_color.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;nt2011_color.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[i]=x;</span><br><span class="line">        <span class="keyword">if</span>(vis[x])to[vis[x]]=i;</span><br><span class="line">        vis[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(!to[i])to[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s,A+i,B+i);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> C[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    sort(b+1,b+totn+1);</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        totx=toty=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(C[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(X,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(X));</span><br><span class="line">            <span class="built_in">memset</span>(Y,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Y));</span><br><span class="line">            <span class="keyword">for</span>(ll j=A[i]<span class="number">-1</span>;j;j-=<span class="built_in">lowbit</span>(j))    X[++totx]=root[j];</span><br><span class="line">            <span class="keyword">for</span>(ll j=B[i];j;j-=<span class="built_in">lowbit</span>(j))    Y[++toty]=root[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(<span class="number">1</span>,n+<span class="number">1</span>,B[i]+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">-1</span>);</span><br><span class="line">            a[A[i]]=B[i];</span><br><span class="line">            to[A[i]]=n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll t=A[i]+<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">            <span class="keyword">if</span>(a[t]==B[i])&#123;to[A[i]]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i]<span class="number">-1</span>;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(to[j]==A[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">-1</span>);</span><br><span class="line">                    to[j]=n+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t=j+<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==a[j])&#123;to[j]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a[j]==B[i]&amp;&amp;to[j]&gt;A[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">-1</span>);</span><br><span class="line">                    to[j]=A[i];</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 6</span></span><br><span class="line"><span class="comment">1 1 1 2 2 2</span></span><br><span class="line"><span class="comment">Q 1 3</span></span><br><span class="line"><span class="comment">R 2 2</span></span><br><span class="line"><span class="comment">Q 1 3</span></span><br><span class="line"><span class="comment">R 3 2</span></span><br><span class="line"><span class="comment">Q 1 3</span></span><br><span class="line"><span class="comment">Q 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Segment Tree </tag>
            
            <tag> Persistent Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年5月 题目总结</title>
      <link href="/2017/05/02/Problems-2017-05/"/>
      <url>/2017/05/02/Problems-2017-05/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/05/02/2017%E5%B9%B45%E6%9C%88%20%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="BZOJ1023-SHOI2008-cactus仙人掌图"><a href="#BZOJ1023-SHOI2008-cactus仙人掌图" class="headerlink" title="BZOJ1023 SHOI2008 cactus仙人掌图"></a>BZOJ1023 SHOI2008 cactus仙人掌图</h1><p>题意为求仙人掌图的直径。这题看起来完全没思路，最后看的题解。get了一种Tarjan的用法，先用其求出DFS树，用dp更新树边的直径最大值，考虑将其他非树边以环形dp更新，由于边的权值均为$1$，所以可以进行单调队列优化。其中利用到了仙人掌的一些性质。</p><h1 id="BZOJ1024-SCOI2009-生日快乐"><a href="#BZOJ1024-SCOI2009-生日快乐" class="headerlink" title="BZOJ1024 SCOI2009 生日快乐"></a>BZOJ1024 SCOI2009 生日快乐</h1><p>搜索，考虑切成$n$块后面积是一样的，那么实际上对于每一个切割后的蛋糕，需要继续处理的操作数的一定的，深搜即可。核心代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">work</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">int</span> k)</span><span class="comment">//x，y为长与宽，k为对于该块蛋糕剩余操作个数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">max</span>(x,y)/<span class="built_in">min</span>(x,y);</span><br><span class="line">    <span class="keyword">double</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(<span class="built_in">work</span>(x,y/k*i,i),<span class="built_in">work</span>(x,y/k*(k-i),k-i)));</span><br><span class="line">    <span class="comment">//取min是因为答案要求最小值，取max是因为属于同一块蛋糕。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(<span class="built_in">work</span>(x/k*i,y,i),<span class="built_in">work</span>(x/k*(k-i),y,k-i)));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BZOJ1025-SCOI2009-游戏"><a href="#BZOJ1025-SCOI2009-游戏" class="headerlink" title="BZOJ1025 SCOI2009 游戏"></a>BZOJ1025 SCOI2009 游戏</h1><p>题意为给定$n$个元素，求在$n$的全排列的置换中的周期（即为各个循环节的公倍数），等价于$n$的整数拆分中的最小公倍数数量，直接枚举显然会超时，不妨用dp处理，枚举质因子以及幂即可。</p><h1 id="BZOJ1026-SCOI2009-windy数"><a href="#BZOJ1026-SCOI2009-windy数" class="headerlink" title="BZOJ1026 SCOI2009 windy数"></a>BZOJ1026 SCOI2009 windy数</h1><p>数位DP（一般是求在$[L,R]$之间有多少满足条件的数，然而并没有学过，膜的题解），先预处理有$k$位时，最高位为$i$时的答案，通过交集，并集的关系求一下即可。</p><h1 id="BZOJ1027-JSOI2007-合金"><a href="#BZOJ1027-JSOI2007-合金" class="headerlink" title="BZOJ1027 JSOI2007 合金"></a>BZOJ1027 JSOI2007 合金</h1><p>构造题，已知$a+b+c=1$，可将第三维浓度去掉，那么目标浓度可由条件浓度转化而来，当且仅当</p><p>$$min(a_{condition}) &lt; a_{target} &lt; max(a_{condition})$$</p><p>$$min(b_{condition}) &lt; b_{target} &lt; max(b_{condition})$$</p><p>那么可以将其转化为二维平面的凸包问题，给定可选点，要求用最少的点使其凸包包含所有目标点。</p><h1 id="BZOJ1028-JSOI2007-麻将"><a href="#BZOJ1028-JSOI2007-麻将" class="headerlink" title="BZOJ1028 JSOI2007 麻将"></a>BZOJ1028 JSOI2007 麻将</h1><p>观察$n,m$的范围，可知贪心就能过。</p><h1 id="BZOJ1029-JSOI2007-建筑抢修"><a href="#BZOJ1029-JSOI2007-建筑抢修" class="headerlink" title="BZOJ1029 JSOI2007 建筑抢修"></a>BZOJ1029 JSOI2007 建筑抢修</h1><p>还是贪心，涨自信题。</p><h1 id="BZOJ1030-JSOI2007-文本生成器"><a href="#BZOJ1030-JSOI2007-文本生成器" class="headerlink" title="BZOJ1030 JSOI2007 文本生成器"></a>BZOJ1030 JSOI2007 文本生成器</h1><p>AC自动机模板题，见博客DNA Sequence，不过这题$m$范围很小，而子串的长度更大，所以不需要矩阵快速幂（会TLE），直接DP即可。</p><h1 id="BZOJ1031-JSOI2007-字符加密"><a href="#BZOJ1031-JSOI2007-字符加密" class="headerlink" title="BZOJ1031 JSOI2007 字符加密"></a>BZOJ1031 JSOI2007 字符加密</h1><p>后缀数组模板题，利用后缀的性质将条件串接到自己后面，这样就包换了所有情况，求sa即可。</p><h1 id="BZOJ1032-JSOI2007-祖码"><a href="#BZOJ1032-JSOI2007-祖码" class="headerlink" title="BZOJ1032 JSOI2007 祖码"></a>BZOJ1032 JSOI2007 祖码</h1><p>区间DP，标程没有考虑到连续消除的问题，导致数据都错了。</p><h1 id="BZOJ1034-ZJOI2008-泡泡堂"><a href="#BZOJ1034-ZJOI2008-泡泡堂" class="headerlink" title="BZOJ1034 ZJOI2008 泡泡堂"></a>BZOJ1034 ZJOI2008 泡泡堂</h1><p>贪心，对于最好情况，先将对手实力值与ZJ实力值排序，如果ZJ最低的实力值比对手最低的实力值大，那么为了战胜对手，将两者比试的代价最小，如果ZJ最高的实力值比对手最高的实力值大时，那么为了战胜对手，此时只要ZJ取一个比对手该实力值高的元素即可，为了方便，可以取最后一个。当两者均不满足时，则与对手实力值最高的元素比试总不能获胜，为了代价最小，将ZJ实力值最小的元素与其进行比试。</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Computation Geometry </tag>
            
            <tag> Graph Theory </tag>
            
            <tag> Tarjan&#39;s Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDOI2017 数字表格</title>
      <link href="/2017/04/27/SDOI2017-Numbers/"/>
      <url>/2017/04/27/SDOI2017-Numbers/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/27/SDOI2017%20%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/">原文</a>）</p></div><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/ha3dQq1exT2tu9A.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><img src="i4.buimg.com/567571/46577fa98c6b973a.png" alt="题解"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line">ull fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][<span class="number">3</span>],ff[N],fs[N],rev[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> ca1[<span class="number">33</span>],ca2[<span class="number">33</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">qpow</span><span class="params">(ull a,ull b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)b+=mod<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=(ret*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    miu[<span class="number">1</span>]=phi[<span class="number">1</span>]=fs[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%mod;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])miu[i]=<span class="number">-1</span>,p[++tot]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;p[j]*i&lt;N;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*p[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)&#123;miu[i*p[j]]=<span class="number">0</span>;phi[i*p[j]]=phi[i]*p[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">            miu[i*p[j]]=-miu[i];</span><br><span class="line">            phi[i*p[j]]=phi[i]*(p[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">    fp[i][<span class="number">0</span>]=<span class="built_in">qpow</span>(f[i],<span class="number">-1</span>),fp[i][<span class="number">1</span>]=<span class="number">1</span>,fp[i][<span class="number">2</span>]=f[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)ff[i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)</span><br><span class="line">    ff[j]=(ull)ff[j]*fp[i][miu[j/i]+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)fs[i]=(ull)fs[i<span class="number">-1</span>]*ff[i]%mod;</span><br><span class="line"></span><br><span class="line">    rev[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(fs[N<span class="number">-1</span>],<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)rev[i]=(ull)rev[i+<span class="number">1</span>]*ff[i+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ull solve(int n,int m)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    ull ret=0;</span></span><br><span class="line"><span class="comment">//    int top=min(n,m);</span></span><br><span class="line"><span class="comment">//    ull i=1,j;</span></span><br><span class="line"><span class="comment">//    while(i&lt;=top)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        j=min(n/(n/i),m/(m/i));</span></span><br><span class="line"><span class="comment">//        (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; </span></span><br><span class="line"><span class="comment">//        i=j+1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return ret;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//ull mobi(ull n,ull m)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    if(n&gt;m)swap(n,m);</span></span><br><span class="line"><span class="comment">//    ull ans=0;</span></span><br><span class="line"><span class="comment">//    for (int i=1,r;i&lt;=n;i=r+1)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        r=min(n/(n/i),m/(m/i));</span></span><br><span class="line"><span class="comment">//        ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return ans;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//ull cheng(ull a,ull b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    ull ret=0;</span></span><br><span class="line"><span class="comment">//    int tmp1=0,tmp2=0;</span></span><br><span class="line"><span class="comment">//    memset(ca1,0,sizeof(ca1));</span></span><br><span class="line"><span class="comment">//    memset(ca2,0,sizeof(ca2));</span></span><br><span class="line"><span class="comment">//    while(a)ca1[++tmp1]=a%10,a/=10;</span></span><br><span class="line"><span class="comment">//    while(b)ca2[++tmp2]=b%10,b/=10;</span></span><br><span class="line"><span class="comment">//    int *x=ca1,*y=ca2;</span></span><br><span class="line"><span class="comment">//    if(tmp2&gt;tmp1)swap(x,y),swap(tmp1,tmp2);</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp2;++i)x[i]*=y[i];</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp2;++i)</span></span><br><span class="line"><span class="comment">//    if(x[i]&gt;10)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        x[i+1]+=x[i]/10;</span></span><br><span class="line"><span class="comment">//        x[i]%=10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp1;++i)y[tmp1+1-i]=x[i];</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp1;++i)ret=(ret*10+(y[i]))%mod;</span></span><br><span class="line"><span class="comment">//    return ret;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m,k;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        ull ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mn=<span class="built_in">min</span>(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,r;i&lt;=mn;i=r+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">            ans=ans*<span class="built_in">qpow</span>(fs[r]*rev[i<span class="number">-1</span>]%mod,(ull)(n/i)*(m/i)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Mobius Inversion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年4月 题目总结</title>
      <link href="/2017/04/25/Problems-2017-04/"/>
      <url>/2017/04/25/Problems-2017-04/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/25/2017%E5%B9%B44%E6%9C%88%20%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="BZOJ1001-BeiJing2006-狼抓兔子"><a href="#BZOJ1001-BeiJing2006-狼抓兔子" class="headerlink" title="BZOJ1001 BeiJing2006 狼抓兔子"></a>BZOJ1001 BeiJing2006 狼抓兔子</h1><p>网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可）</p><h1 id="BZOJ1002-FJOI2007-轮状病毒"><a href="#BZOJ1002-FJOI2007-轮状病毒" class="headerlink" title="BZOJ1002 FJOI2007 轮状病毒"></a>BZOJ1002 FJOI2007 轮状病毒</h1><p>最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度）</p><h1 id="BZOJ1003-ZJOI2006-物流运输"><a href="#BZOJ1003-ZJOI2006-物流运输" class="headerlink" title="BZOJ1003 ZJOI2006 物流运输"></a>BZOJ1003 ZJOI2006 物流运输</h1><p>一道DP题，转移方程为</p><p>$$f[i]=min(f[i],f[j]+k+t[j+1][i] * (i−j))$$</p><h1 id="BZOJ1004-HNOI2008-Cards"><a href="#BZOJ1004-HNOI2008-Cards" class="headerlink" title="BZOJ1004 HNOI2008 Cards"></a>BZOJ1004 HNOI2008 Cards</h1><p>Burnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。</p><h1 id="BZOJ1005-HNOI2008-明明的烦恼"><a href="#BZOJ1005-HNOI2008-明明的烦恼" class="headerlink" title="BZOJ1005 HNOI2008 明明的烦恼"></a>BZOJ1005 HNOI2008 明明的烦恼</h1><p>purfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。</p><h1 id="BZOJ1006-HNOI2008-神奇的国度"><a href="#BZOJ1006-HNOI2008-神奇的国度" class="headerlink" title="BZOJ1006 HNOI2008 神奇的国度"></a>BZOJ1006 HNOI2008 神奇的国度</h1><p>弦图裸题,见上篇博客。</p><h1 id="BZOJ1007-HNOI2008-水平可见直线"><a href="#BZOJ1007-HNOI2008-水平可见直线" class="headerlink" title="BZOJ1007 HNOI2008 水平可见直线"></a>BZOJ1007 HNOI2008 水平可见直线</h1><p>以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。</p><h1 id="BZOJ1008-HNOI2008-越狱"><a href="#BZOJ1008-HNOI2008-越狱" class="headerlink" title="BZOJ1008 HNOI2008 越狱"></a>BZOJ1008 HNOI2008 越狱</h1><p>简单的快速幂，稍微推一下即可得到答案为</p><p>$$qpow(m,n)−(qpow(m−1,n−1)∗m)$$</p><h1 id="BZOJ1009-HNOI2008-GT考试"><a href="#BZOJ1009-HNOI2008-GT考试" class="headerlink" title="BZOJ1009 HNOI2008 GT考试"></a>BZOJ1009 HNOI2008 GT考试</h1><p>用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。</p><h1 id="BZOJ1011-HNOI2008-遥远的行星"><a href="#BZOJ1011-HNOI2008-遥远的行星" class="headerlink" title="BZOJ1011 HNOI2008 遥远的行星"></a>BZOJ1011 HNOI2008 遥远的行星</h1><p>简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2j$即可。</p><h1 id="BZOJ1012-JSOI2008-最大数"><a href="#BZOJ1012-JSOI2008-最大数" class="headerlink" title="BZOJ1012 JSOI2008 最大数"></a>BZOJ1012 JSOI2008 最大数</h1><p>各种数据结构的裸题。</p><h1 id="BZOJ1013-JSOI2008-球形空间产生器"><a href="#BZOJ1013-JSOI2008-球形空间产生器" class="headerlink" title="BZOJ1013 JSOI2008 球形空间产生器"></a>BZOJ1013 JSOI2008 球形空间产生器</h1><p>高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。</p><h1 id="BZOJ4801-BZOJ4月月赛-打牌"><a href="#BZOJ4801-BZOJ4月月赛-打牌" class="headerlink" title="BZOJ4801 BZOJ4月月赛 打牌"></a>BZOJ4801 BZOJ4月月赛 打牌</h1><p>考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。</p><h1 id="BZOJ4810-YNOI2017-由乃的玉米田"><a href="#BZOJ4810-YNOI2017-由乃的玉米田" class="headerlink" title="BZOJ4810 YNOI2017 由乃的玉米田"></a>BZOJ4810 YNOI2017 由乃的玉米田</h1><p>主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。</p><h1 id="Luogu3708-洛谷四月月赛-koishi的数学题"><a href="#Luogu3708-洛谷四月月赛-koishi的数学题" class="headerlink" title="Luogu3708 洛谷四月月赛 koishi的数学题"></a>Luogu3708 洛谷四月月赛 koishi的数学题</h1><p>设$g(x,i)=g(modi)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x−1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。</p><h1 id="BZOJ1015-JSOI2008-星球大战"><a href="#BZOJ1015-JSOI2008-星球大战" class="headerlink" title="BZOJ1015 JSOI2008 星球大战"></a>BZOJ1015 JSOI2008 星球大战</h1><p>考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。</p><h1 id="BZOJ1018-SHOI2008-堵塞的交通"><a href="#BZOJ1018-SHOI2008-堵塞的交通" class="headerlink" title="BZOJ1018 SHOI2008 堵塞的交通"></a>BZOJ1018 SHOI2008 堵塞的交通</h1><p>分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写）</p><h1 id="BZOJ1019-SHOI2008汉诺塔"><a href="#BZOJ1019-SHOI2008汉诺塔" class="headerlink" title="BZOJ1019 SHOI2008汉诺塔"></a>BZOJ1019 SHOI2008汉诺塔</h1><p>第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i−1]$线性相关，于是模拟出来前$20$项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i−1]∗k+b$的递推式））</p><h1 id="BZOJ1020-SHOI2008-安全的航线"><a href="#BZOJ1020-SHOI2008-安全的航线" class="headerlink" title="BZOJ1020 SHOI2008 安全的航线"></a>BZOJ1020 SHOI2008 安全的航线</h1><p>典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍）</p><h1 id="BZOJ1021-SHOI2008-循环的债务"><a href="#BZOJ1021-SHOI2008-循环的债务" class="headerlink" title="BZOJ1021 SHOI2008 循环的债务"></a>BZOJ1021 SHOI2008 循环的债务</h1><p>题目可以进一步简化，即已知每个人初始金钱和构成。</p><h1 id="Luogu3704-SDOI2017-数字表格"><a href="#Luogu3704-SDOI2017-数字表格" class="headerlink" title="Luogu3704 SDOI2017 数字表格"></a>Luogu3704 SDOI2017 数字表格</h1><p>莫比乌斯反演的常见应用，见下篇博客。</p><h1 id="BZOJ1049-HAOI2006-数字序列"><a href="#BZOJ1049-HAOI2006-数字序列" class="headerlink" title="BZOJ1049 HAOI2006 数字序列"></a>BZOJ1049 HAOI2006 数字序列</h1><p>很像暴力的动规，对于第一问，需要用到补集转化的思想，设 $f[i]$ 为前 $i$ 位的最多不变 元素，那么 $f[i]$ 能由 $f[j]$ 转化而来当且仅当 $a[i]-a[j]&gt;=i-j$, 即修改两者之间的 $i-j-1$ 个数使其严格递增，即两者之间只有$1$个元素不变，那么有</p><p>$$f[i]=\max (f[i], f[j]+1)(a[i]-a[j]&gt;=i-j)$$</p><p>时间复杂度为 $O\left(n^{2}\right)$, 无法通过全部数据点，考虑进行优化，观察状态转移方程，易知可以通过减标号的方法转化成LIS问题，即 可在 $O(n \log n)$ 的时间内求解。</p><p>对于第二问，为了简化问题，可以先设 $w(i, j)$ 为将从 $i$ 到 $j$ 的所有元素进行修改的最小代价，设 $g[i]$ 为前 $i$ 位的最小答案。那么根据第一问有</p><p>$$g[i]=\min (g[i], g[j]+w(j+1, i))(f[i]=f[j]+1)$$</p><p>对于 $w$ 的求解，可以记录每一个需要修改的元素的下一个和上一个不需要修改元素的位置，模拟即可。</p><h1 id="Codefores286E-Ladies’-Shop"><a href="#Codefores286E-Ladies’-Shop" class="headerlink" title="Codefores286E Ladies’ Shop"></a>Codefores286E Ladies’ Shop</h1><p>根据题目所给条件，可知要求的 $p$ 个数一定在给定的 $n$ 个数中。</p><p>那么可以根据多项式乘法系数相乘，指数相加的特点，构造生成函数，并求出这 $n$ 个数可以组成的所有情况。已知某个 $n$ 集合中数 $a$ 可以由 $b+c+d$ 生成，那么根据题目中所给条件，可知一定有 $e$ 由 $c+d$ 生成，那么可以将 $a$ 看作由 $b+e$ 生成。</p><p>根据数学归纳法，易证</p><p>$p$ 个数可以选出一些集合（相同的数可重复选），其和可以组成所有给定的 $n$ 个数。（一）</p><p>与以下结论等价:</p><p>$p$ 个数可以选出任何两个元素（相同的数可重复选），其和可以组成所有给定的 $n$ 个数。（二）</p><p>那么生成函数的构造就显而易见了。（将幂作为权值，系数作为出现的次数，并将该生成函数与自身相乘，可以通过FFT优化)</p><p>对于第三个条件 (满足 $|p|$ 的阶最小)，可以结合以贪心的策略。如果生成函数中某项系数大于$1$且在给定集合 $|n|$ 中，则该元素一定可以由另外两个元素组成，那么就不将其加入集合 $|p|$ 中，否则将其加入集合 $|p|$ 中。</p><p>至于无解的判断，易知其等价于:</p><p>生成函数中某项系数不为零且该元素不在给定集合中。</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> AC Automaton </tag>
            
            <tag> String Manipulation </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Polya Theorem </tag>
            
            <tag> Balance Tree </tag>
            
            <tag> Computation Geometry </tag>
            
            <tag> Graph Theory </tag>
            
            <tag> Gaussian Elimination </tag>
            
            <tag> Network Flow </tag>
            
            <tag> Hash </tag>
            
            <tag> Mo&#39;s Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弦图与区间图</title>
      <link href="/2017/04/21/Chordal-Graph/"/>
      <url>/2017/04/21/Chordal-Graph/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/21/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE/">原文</a>）</p></div><h1 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h1><p><a href="https://wenku.baidu.com/view/6f9f2223dd36a32d73758126.html">弦图与区间图-陈丹琦</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="团"><a href="#团" class="headerlink" title="团"></a>团</h2><p>图$G$的一个子图$G’=(V’,E’)$，$G’$为关于$V’$的完全图。</p><h2 id="极大团"><a href="#极大团" class="headerlink" title="极大团"></a>极大团</h2><p>一个团是极大团当它不是其它团的子集。</p><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><p>点数最多的团。</p><h2 id="弦"><a href="#弦" class="headerlink" title="弦"></a>弦</h2><p>连接环中不相邻的两个点的边。</p><h2 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h2><p>一个无向图称为弦图当且仅当图中任意长度大于$3$的环都至少有一个弦。</p><h2 id="单纯点"><a href="#单纯点" class="headerlink" title="单纯点"></a>单纯点</h2><p>设$N(v)$表示与点$v$相邻的点集。一个点称为单纯点当$\lbrace v \rbrace + N(v)$的诱导子图为一个团。</p><h2 id="完美消除序列"><a href="#完美消除序列" class="headerlink" title="完美消除序列"></a>完美消除序列</h2><p>这是一个序列$v_i$，它满足$v_i$在$v_i,…,v_n$的诱导子图中为单纯点。</p><h2 id="弦图的判定"><a href="#弦图的判定" class="headerlink" title="弦图的判定"></a>弦图的判定</h2><p>存在完美消除序列的图为弦图。</p><h2 id="最小色数"><a href="#最小色数" class="headerlink" title="最小色数"></a>最小色数</h2><p>用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。</p><h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><p>最大的一个点集使任意两个点不相邻，$α(G)$为其点数。</p><h2 id="最小团覆盖"><a href="#最小团覆盖" class="headerlink" title="最小团覆盖"></a>最小团覆盖</h2><p>用最少个数的团覆盖所有的点，$κ(G)$为其团数。</p><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><h2 id="完美消除序列-1"><a href="#完美消除序列-1" class="headerlink" title="完美消除序列"></a>完美消除序列</h2><p>可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）（但是可以用堆优化）。</p><h2 id="最小色数的求解"><a href="#最小色数的求解" class="headerlink" title="最小色数的求解"></a>最小色数的求解</h2><p>简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。</p><h2 id="最大独立集的求解"><a href="#最大独立集的求解" class="headerlink" title="最大独立集的求解"></a>最大独立集的求解</h2><p>仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。</p><h2 id="最小团覆盖的求解"><a href="#最小团覆盖的求解" class="headerlink" title="最小团覆盖的求解"></a>最小团覆盖的求解</h2><p><strong>最小团覆盖数=最大独立集数</strong></p><p>（以上一切都不会证）</p><h1 id="HNOI2008-神奇的国度"><a href="#HNOI2008-神奇的国度" class="headerlink" title="HNOI2008 神奇的国度"></a>HNOI2008 神奇的国度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>K国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人A1A2…An之间仅存在N对认识关系:(A1A2)(A2A3)…(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 </p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数$N，M$。表示有$N$个人，$M$对认识关系. 接下来$M$行每行输入一对认识关系。</p><p>$1&lt;=N&lt;=10000,1&lt;=M&lt;=1000000$</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，最少可以分多少队 。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">(1,3)(2)(4)为一种可行方案</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ne,to;&#125;e[<span class="number">20</span>*N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N];</span><br><span class="line"><span class="keyword">bool</span> use[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].ne=head[x];</span><br><span class="line">    e[cnt].to=y;</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1006.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1006.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tot!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(p[i]&gt;p[x]&amp;&amp;!vis[i])x=i;</span><br><span class="line">        vis[x]=<span class="number">1</span>;q[++tot]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)p[e[i].to]++;</span><br><span class="line">        x=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)use[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)use[c[e[i].to]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(use[now])now++;</span><br><span class="line">        c[x]=now;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;ans)ans=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Graph Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学总结</title>
      <link href="/2017/04/10/Combinatorics/"/>
      <url>/2017/04/10/Combinatorics/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/10/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h2><p>做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，…，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M_1+M_2+…+M_N$种方法。</p><h2 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h2><p>做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，…，做第$n$步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。</p><h1 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h1><p>从$n$个不同元素中任取$r(r≦n)$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出$r$个元素的排列数，记为$A(n,r)$。</p><p>对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n−1$种取法，…，第$r$个元素有$n−r+1$种取法，则根据乘法原理可得通项公式。</p><p>$$A(n,r)=\frac {n!} {(n−r)!}$$</p><h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><p>从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为 $C(n, m)$ 。</p><p>根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说 $1,2,3$ 与 $1,3,2$ 是一种组合，但 对排列数则不是。那么在组合数中重复计算的次数即为 $r$ 的全排列</p><p>则有</p><p>$$C(n, r)=\frac{A(n, r)}{r !}$$</p><p>即</p><p>$$C(n, r)=\frac{n !}{r !(n-r) !}$$</p><h1 id="常见定理与组合论证"><a href="#常见定理与组合论证" class="headerlink" title="常见定理与组合论证"></a>常见定理与组合论证</h1><p>$$\text { 1. } C(n, r)=C(n, n-r)$$</p><p>将其表示为一个长度为 $n$ 的二进制串，则组合数为有 $r$ 位为 1 的串的个数，易知其与有 $n-r$ 位为 0 的串的个数等价。</p><p>$$\text { 2. } C(n, r)=C(n-1, r-1)+C(n-1, r)$$</p><p>将其表示为一个长度为 $n$ 的二进制串，利用动态规划的思想，可设 $C(n-1, r-1)$ 表示长度为 $n-1$ 的串且在末尾新加入一个$1$的方案数， $C(n-1, r)$ 表示长度为 $n-1$ 的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为 $C(i, i)=0$）</p><p>$$\text { 3. }2^{n}=\sum_{k} C(n, k)$$</p><p>$2^{n}$ 为长度为 $n$ 的二进制串的总方案数，根据加法原理，易知其等价于长度为 $n$ 的二进制串且有 $0,1,…,n$ 个 $1$ 的方案数和。</p><p>$$\text { 4. }(a+b)^{n}=\sum_{k} C(n, k) a^{k} b^{b-k}$$</p><p>这个定理同样可以直接通过二项式定理求证。</p><p>$$\text { 5. } C(n+m, r)=\sum_{k} C(n, k) * C(m, r-k)$$</p><p>左项可以表示为一个长度为 $a+b$ 的二进制串，右项则可以表示为一个长度为 $a$ 的二进制串拼上一个长度为 $b$ 的二进制串，此处可以转化为定理 $3$，再结合乘法原理即可得证。</p><p>$$\text { 6. }C(n, r)=\frac{n}{r}(n-1, r-1)$$</p><p>结合定理一，可以通过简单的推导得到该定理。</p><p>$$\text { 7. } C(n, m) C(m, r)=C(n, r) C(n-r, m-r)$$</p><p>可以将左式表示为在 $n$ 个学生中选出 $m$ 个组长，再在 $m$ 个组长中选出 $r$ 班干部，则右式可以表示为在 $n$ 个学生中选 $r$ 个班干部，再 在剩余的学生 $n-r$ 中选出 $m-r$ 个不是班干部的组长，易知两者等价。</p><h1 id="可重复组合数"><a href="#可重复组合数" class="headerlink" title="可重复组合数"></a>可重复组合数</h1><p>从 $n$ 个不同元素中，任取 $m(m \leq n)$ 个元素并成一组 (可以重复选择)，叫做从 $n$ 个不同元素中取出 $m$ 个元素的一个可重复组合；从 $n$ 个不同元素中取出 $m(m \leq n)$ 个元素的所有组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的可重复组合数。</p><p>可重复组合即为</p><p>$$C(n+m-1, m)$$</p><p>对于此结论的证明可以逆向来看， $n$ 中选 $m$ 个元素即为将 $m$ 个球放在 $n$ 个盒子内的方案数，每个盒子中允许放 0 到 $m$ 个球。对于 这 $m$ 个球来说，即为 $n-1$ 个断点将其分为了 $n$ 部分。</p><p>不妨将断点用二进制串表示为 0 ，球表示为 1 ，那么在 3 个元素中选 5 个元素的一种方案即可表示为</p><p>$$1-1-1-0-1-0-1$$</p><p>易观察到可重复组合数等于在 $n+m-1$ 个元素中选取 $m$ 个 $1$ 的方案数</p><p>即为</p><p>$$C(n+m-1, m)$$</p><p>可重复组合数同样可以解决如下的问题:</p><p>已知</p><p>$$x_{1}+x_{2}+x_{3}+\ldots \ldots+x_{n}=m\left(x_{i}&gt;=0\right)$$</p><p>求方程的解数。</p><p>此处可以看出答案即为 $C(n+m-1, m)$ ，论证方法同上，该问题同样有很多变式，如改变 $x_{i}$ 的取值范围等，同样可以通过如 上方式得解，此处不再赘述。</p><h1 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h1><p>斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。</p><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><p>$s(n, m)$ 的递推公式:</p><p>$$s(n, m)=(n-1) * s(n-1, m)+s(n-1, m-1)(1&lt;=m&lt;=n-1)$$</p><p>边界条件:</p><p>$$s(n, n)=1(n&gt;=0)$$</p><p>$$s(n, 0)=0(n&gt;=1)$$</p><p>递推关系的说明:</p><p>考虑第 $n$ 个物品， $n$ 可以单独构成一个非空循环排列，这样前 $n-1$ 种物品构成 $m-1$ 个非空循环排列，方法数 为 $s(n-1, m-1)$ 。</p><p>也可以前 $n-1$ 种物品构成 $m$ 个非空循环排列，而第 $n$ 个物品揷入第 $i$ 个物品的左边，这有 $(n-1) \times s(n-1, m)$ 种方法。</p><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>$S(n, m)$ 的递推公式是:</p><p>$$S(n, m)=m \times S(n-1, m)+S(n-1, m-1)(1&lt;=m&lt;=n-1)$$</p><p>边界条件:</p><p>$$s(n, n)=1(n&gt;=0)$$</p><p>$$s(n, 0)=0(n&gt;=1)$$</p><p>递推关系的说明:</p><p>考虑第 $n$ 个物品， $n$ 可以单独构成一个非空集合，此时前 $n-1$ 个物品构成 $m-1$ 个非空的不可辨别的集合，方法数 为 $S(n-1, m-1)$ ；</p><p>也可以前 $n-1$ 种物品构成 $m$ 个非空的不可辨别的集合，第 $n$ 个物品放入任意一个中，这样有 $m \times S(n-1, m)$ 种方法。</p><p>第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。</p><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>一个栈(无穷大)的进栈序列为 $1 , 2 , 3 , \ldots, n$ ，有多少个不同的出栈序列?</p><p>该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有 $n$ 个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数，凸多边形的三角划分数等等，在组合数学中有着广泛的应用。</p><p>令$h(0)=1, h(1)=1$, 则卡特兰数数满足递推式:</p><p>$$h(n)=h(0) \times h(n-1)+h(1) \times h(n-2)+\ldots+h(n-1) \times h(0)(n&gt;=2)$$</p><p>亦或</p><p>$$h(n)=h(n-1) \times(4 \times n-2) /(n+1)$$</p><p>同样可以用组合数表示</p><p>$$h(n)=\frac{C(2 n, n)}{n+1}$$</p><p>或者</p><p>$$h(n)=C(2 n, n)-C(2 n, n-1)$$</p><p>证明可以将出栈入栈的操作集合，看作一个长度为 $2 n$ 的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：$0$和$1$的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，$0$的个数要大于等于$1$的个数（对应栈为空时不能继续出栈)。</p><p>先求出只满足第一个限制的方案数，易知其为 $C(2 n, n)$ 。</p><p>再考虑第二个限制需要排除的方案，易知其前缀必有一处 $1$ 的个数大于 $0$ 的个数，可设此处有 $k$ 个 $0$，$k+1$ 个 $1$ ，剩下的串中 有 $n-k$ 个 $0$，$n-k-1$ 个 $1$ ，将剩下的串按位取反，则得到的新串中共有 $n-1$ 个 $0$，$n+1$ 个 $1$ ，这样的串共有 $C(2 n, n-1)$ 。</p><p>则有</p><p>$$h(n)=C(2 n, n)-C(2 n, n-1)$$</p><p>以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与 原问题等价等条件，才能优美地求解。</p><h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p>在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</p><p>易知</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/05f67b2ce4414f2a1f96e4210a86d71028aa53b6" alt="容斥原理1"></p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0b8e7c1631ec013eed94feb5aa406a573caa3559" alt="容斥原理2"></p><p>则通项公式表示为</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7589a99f7137c74fd85940231971082679f12c3" alt="容斥原理3"></p><p>（在个人讲课ppt中有着详细的证明，后续会整理到博客中）</p><h1 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h1><p>错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。<br>递推式为：</p><p>$$D(n)=(n−1)*(D(n−2)+D(n−1))$$</p><p>初始条件为：</p><p>$$D(1)=0$$</p><p>$$D(2)=1$$</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Combinatorics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transposing is Even More Fun</title>
      <link href="/2017/04/09/Transposing-Is-Even-More-Fun/"/>
      <url>/2017/04/09/Transposing-Is-Even-More-Fun/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/09/Transposing%20is%20Even%20More%20Fun/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vixmxkeaU">COGS 1608</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个$2^a∗2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的…每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ </p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第$1$行数数据组数$c(1&lt;=c&lt;=400000)$</p><p>接下来有$c$行，每行一组测试数据：两个整数$a,b(0&lt;=a+b&lt;=1000000)$ </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 </p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">5 7</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">3744</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。</p><p>以$2^1∗2^2$为例，则置换为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1  </span><br><span class="line">2 3 </span><br><span class="line">4 5</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><p>到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2 4 6</span><br><span class="line">1 3 5 7</span><br></pre></td></tr></table></figure><p>表示为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ 0 1 2 3 4 5 6 7 \</span><br><span class="line">\ 0 2 4 6 1 3 5 7 /</span><br></pre></td></tr></table></figure><p>亦或</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0)(1 2 4)(3 6 5)(7)</span><br></pre></td></tr></table></figure><p>考虑在任意一个循环节中，需要交换的次数即为（ 循环节的长度 - 1 ）次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有</p><p>$$Ans=2^{a+b}−循环节个数$$</p><p>现在的问题就转换成了求解循环节的个数，已知$(1&lt;=c&lt;=400000)$且$(0&lt;=a+b&lt;=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。</p><p>则置换为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000 - 000</span><br><span class="line">001 - 010</span><br><span class="line">010 - 100</span><br><span class="line">011 - 110</span><br><span class="line">100 - 001</span><br><span class="line">101 - 011</span><br><span class="line">110 - 101</span><br><span class="line">111 - 111</span><br></pre></td></tr></table></figure><p>不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了$b$位），我们也可以稍微推算一下，对于矩阵元素$(i,j)$来说，转置使其变为了$(j,i)$，将其表示为队列，则从第 $(i-1) * 2^a+j$位转置为第$(j-1) * 2^b+i$位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为$a+b$，颜色为$0,1$ 两种，循环右移左移即对应项链的旋转。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以a=2，b=4为例。</span><br><span class="line"></span><br><span class="line">则项链为</span><br><span class="line"></span><br><span class="line">      a1</span><br><span class="line">     /  \</span><br><span class="line">    a6   a2</span><br><span class="line">    |    |</span><br><span class="line">    a5   a3</span><br><span class="line">     \  /</span><br><span class="line">      a4   </span><br></pre></td></tr></table></figure><p>但该题的置换群$G= \lbrace 不动，循环右移a位 \rbrace $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a,b)$个点压为一个点。则例图转化为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     a1,2</span><br><span class="line">     /  \</span><br><span class="line"> a5,6 -- a3,4</span><br><span class="line">此时对于任意一个点有2^gcd(a,b)中染色方案。</span><br></pre></td></tr></table></figure><p>则</p><p>$$Ans=2^{a+b}−(\sum_{d|n}k^d \varphi(n/d))/n$$</p><p>原式中</p><p>$$n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$$</p><p>由于原式需要取模，则需要求$n$的逆元，已知$a+b&lt;=1e6$，模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。</p><p>（当时没系统地接触过群论，还不太理解Polya定理的含义）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000003</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N],phi[N],tot,pow2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> c[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">while</span>(x) c[++num] = (x%<span class="number">10</span>)+<span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) <span class="built_in">putchar</span>(c[num--]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=((ll)ans*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=((ll)a*a)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])p[++tot]=i,phi[i]=(i<span class="number">-1</span>)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tot&amp;&amp;i*p[t]&lt;=N<span class="number">-1</span>;++t)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*p[t]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[t]==<span class="number">0</span>)&#123;phi[i*p[t]]=((ll)phi[i]*p[t])%mod;<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*p[t]]=((ll)phi[i]*(p[t]<span class="number">-1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pow2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;++i)pow2[i]=(pow2[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;transp2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;transp2.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">getprime</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span>(a);<span class="built_in">get</span>(b);</span><br><span class="line">        <span class="keyword">int</span> lin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> gcdab=<span class="built_in">gcd</span>(a,b);</span><br><span class="line">        <span class="keyword">int</span> n=(a+b)/gcdab;</span><br><span class="line">        <span class="keyword">int</span> inv;</span><br><span class="line">        inv=<span class="built_in">qpow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=n;++d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%d==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(((ll)pow2[a+b]-lin*inv%mod+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Polya Theorem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSOI2006 同构</title>
      <link href="/2017/04/08/JSOI2006-Omorphism/"/>
      <url>/2017/04/08/JSOI2006-Omorphism/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/08/%E5%90%8C%E6%9E%84/#more">原文</a>）</p></div><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。</p><p>给你$N,M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 </p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P是素数且P&lt;=10^6)$。 </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个正整数，即互不同构的染色图数量模$P$的值。 </p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sample 1:</span><br><span class="line">1 1 2</span><br><span class="line">sample 2:</span><br><span class="line">3 2 97</span><br><span class="line">sample 3:</span><br><span class="line">3 4 97 </span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sample 1:</span><br><span class="line">1</span><br><span class="line">sample 2:</span><br><span class="line">4</span><br><span class="line">sample 3:</span><br><span class="line">20 </span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于本题来说，存在的置换共有$n!$种（即$n$个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对$n$进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$以内。</p><p>关于取模的问题，已知$p$是质数（这个题应该保证了$P&gt;53$），易证两者互质，则可通过费马小定理求逆。</p><p>（当时没系统地接触过群论，还不太理解Polya定理的含义）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line">ll num[N],cnt[N],res,fac[N],n,m,p,ans;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125; </span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;a=(a*a)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(ll now,ll maxl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxl==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a=<span class="number">1</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a=a*<span class="built_in">qpow</span>(num[i],cnt[i])%p*fac[cnt[i]]%p;</span><br><span class="line">            b+=cnt[i]*(cnt[i]<span class="number">-1</span>)/<span class="number">2</span>*num[i]+num[i]/<span class="number">2</span>*cnt[i];</span><br><span class="line">            <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;res;j++)b+=cnt[i]*cnt[j]*<span class="built_in">gcd</span>(num[i],num[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        a=<span class="built_in">qpow</span>(a,p<span class="number">-2</span>)*fac[n]%p;</span><br><span class="line">        ans=(ans+a*<span class="built_in">qpow</span>(m,b)%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;maxl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(now+<span class="number">1</span>,maxl);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*now&lt;=maxl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[res]=now,cnt[res++]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(now+<span class="number">1</span>,maxl-i*now);</span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="comment">//    freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)fac[i]=fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    ans=ans*<span class="built_in">qpow</span>(fac[n],p<span class="number">-2</span>)%p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Polya Theorem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>裴蜀定理总结</title>
      <link href="/2017/03/28/Bezouts-identity/"/>
      <url>/2017/03/28/Bezouts-identity/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/28/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h1><p>已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b)|d$。特别的，一定存在整数$x,y$使得$ax+by=gcd(a,b)$成立。</p><p>裴蜀定理是扩展欧几里得算法的核心。</p><p>（该定理在个人课件中有着详细证明，后续会整理到博客中）</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>（待补充）</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数总结</title>
      <link href="/2017/03/28/Euler-Function/"/>
      <url>/2017/03/28/Euler-Function/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/28/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="欧拉函数的定义"><a href="#欧拉函数的定义" class="headerlink" title="欧拉函数的定义"></a>欧拉函数的定义</h1><p>$\varphi(n)$定义为$1$到$n$中与$n$互质的数的个数。</p><h1 id="欧拉函数的求解"><a href="#欧拉函数的求解" class="headerlink" title="欧拉函数的求解"></a>欧拉函数的求解</h1><h2 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h2><p>$\varphi(n)=n(1−1/p_1)(1−1/p_2)…(1−1/p_{tot})$ (其中$p$为$n$的质因子，$tot$为质因子个数)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;<span class="comment">//与分解质因数相结合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans=ans/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><p>逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前$n$项欧拉函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">2</span>*<span class="built_in">sqrt</span>(N)+<span class="number">1</span>],phi[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++tot]=i;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[t]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[t]==<span class="number">0</span>)&#123;phi[i*prime[t]]=phi[i]*prime[t];<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*prime[t]]=phi[i]*(prime[t]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h1><h2 id="SDOI2008-沙拉公主的困惑"><a href="#SDOI2008-沙拉公主的困惑" class="headerlink" title="SDOI2008 沙拉公主的困惑"></a>SDOI2008 沙拉公主的困惑</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为$1$到$N$的阶乘，但是，政府只发行编号与$M!$互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对$R$取模后的答案即可。$R$是一个质数。</p><p>输入第一行为两个整数$T,R$。$R&lt;=10^9+10,T&lt;=10000$，表示该组中测试数据数目，$R$为模数。</p><p>后面$T$行，每行一对整数$N,M$，见题目描述。</p><p>输出共$T$行，对于每一对$N,M$，输出$1$至$N!$中与$M!$素质的数的数量对$R$取模后的值。</p><p>对于$100 \ percent$的数据，$1 &lt; = M &lt; = N &lt; = 10000000$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意明确$m&lt;=n$，且易知$m!|n!$那么只需要算出$\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\varphi(m!)∗n!/m!(modp)$</p><p>对于$\varphi(m!)$来说，$m!$的值过大，只能利用通项公式来求解，易知$m!$的所有质因数即为$1$到$m$中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> vis[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prime[<span class="number">500500</span>],ans[M+<span class="number">100</span>],fac[M+<span class="number">100</span>],rev[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,p,T,tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;T,&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])prime[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)fac[i]=fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    rev[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])    ans[i]=ans[i<span class="number">-1</span>]*(i<span class="number">-1</span>)%p*rev[i%p]%p;</span><br><span class="line">        <span class="keyword">else</span>                ans[i]=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fac[n]*ans[m]%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元总结</title>
      <link href="/2017/03/28/Multiplicative-Inverse/"/>
      <url>/2017/03/28/Multiplicative-Inverse/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/28/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="乘法逆元的定义"><a href="#乘法逆元的定义" class="headerlink" title="乘法逆元的定义"></a>乘法逆元的定义</h1><p>若$ax≡1(modp)$, 则称$a$关于模$p$的乘法逆元为$x$。</p><p>当$a$与$p$互质时，$a$关于模$p$的乘法逆元有解。如果不互质，则无解。如果$p$为质数，则从$1$到$p-1$的任意数都与p互质，即在$1$到$p-1$之间都恰好有一个关于模$p$的乘法逆元。且$1$到$p-1$中的所有数的逆元对应$1$到$p-1$中的所有数，既是单射也是满射。</p><h1 id="逆元的求解"><a href="#逆元的求解" class="headerlink" title="逆元的求解"></a>逆元的求解</h1><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>逆元一般通过$ExGCD$求解，该方法的时间复杂度为$O(logn)$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;<span class="comment">//NOIP 同余方程    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        x = <span class="number">1</span>;    </span><br><span class="line">        y = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">return</span> a;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">int</span> gcd = <span class="built_in">exgcd</span>(b, a % b, x, y);    </span><br><span class="line">    <span class="keyword">int</span> tmp = x;    </span><br><span class="line">    x = y;    </span><br><span class="line">    y = tmp - (a/b) * y;    </span><br><span class="line">    <span class="keyword">return</span> gcd;    </span><br><span class="line">&#125;    <span class="comment">//inv[n]=(x%p+x)%p;</span></span><br></pre></td></tr></table></figure><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>当$p$为质数时，同样可以通过费马小定理求解。</p><p>已知$n^{p−1}≡1(modp)$(费马小定理)</p><p>那么$inv[n]=n^{p−2}(modp)$。该方法的时间复杂度为$O(logn)$（快速幂）。</p><h2 id="线性求前n项的逆元"><a href="#线性求前n项的逆元" class="headerlink" title="线性求前n项的逆元"></a>线性求前n项的逆元</h2><p>$$inv[n]=(p-p/n) * inv[p \ mod \ n]$$</p><h2 id="递推求前n项的阶乘逆元"><a href="#递推求前n项的阶乘逆元" class="headerlink" title="递推求前n项的阶乘逆元"></a>递推求前n项的阶乘逆元</h2><p>该方法较简单易懂，理论复杂度是上一个方法的$3$倍。据说在某些奇怪的时刻会跑的比上面快。（因为数组的连续访问）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fac为阶乘，rev为阶乘的逆元。</span></span><br><span class="line">fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">rev[N]=<span class="built_in">mod_pow</span>(fac[N],mod<span class="number">-2</span>);<span class="comment">//mod_pow为带取模的快速幂</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)rev[i]=rev[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line"><span class="comment">//可以通过阶乘逆元再一次循环求逆元</span></span><br></pre></td></tr></table></figure><h1 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h1><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>已知$\sum_{i=1}^{p-1} \frac 1 i = \frac A B $,其中$p$为奇质数，求证$A≡0(modp)$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>设$T=lcm(1,2,…,p−1)$</p><p>则有</p><p>$\sum_{i=1}^{p-1} \frac 1 i = 11/i=(T/1+T/2+…+T/(p−1))/T$</p><p>此时只需证明</p><p>$T/1+T/2+…+T/(p−1)≡0(modp)$</p><p>根据性质（见上）我们可以知道，$1$到$p-1$中所有数的逆元对应$1$到$p-1$中的所有数，则原式可以化简为</p><p>$1+2+…+(p−1)≡0(modp)$</p><p>$p∗(p−1)≡0(modp)$</p><p>得证。</p><h2 id="T2-SDOI2008-沙拉公主的困惑"><a href="#T2-SDOI2008-沙拉公主的困惑" class="headerlink" title="T2 SDOI2008 沙拉公主的困惑"></a>T2 SDOI2008 沙拉公主的困惑</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为$1$到$N$的阶乘，但是，政府只发行编号与$M!$互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对$R$取模后的答案即可。$R$是一个质数。</p><p>输入第一行为两个整数$T,R$。$R&lt;=10^9+10,T&lt;=10000$，表示该组中测试数据数目，$R$为模数。</p><p>后面$T$行，每行一对整数$N,M$，见题目描述。</p><p>输出共$T$行，对于每一对$N,M$，输出$1$至$N!$中与$M!$素质的数的数量对$R$取模后的值。</p><p>对于$100 \ percent$的数据，$1 &lt; = M &lt; = N &lt; = 10000000$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意明确$m&lt;=n$，且易知$m!|n!$那么只需要算出$\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\varphi(m!)∗n!/m!(modp)$</p><p>对于$\varphi(m!)$来说，$m!$的值过大，只能利用通项公式来求解，易知$m!$的所有质因数即为$1$到$m$中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> vis[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prime[<span class="number">500500</span>],ans[M+<span class="number">100</span>],fac[M+<span class="number">100</span>],rev[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,p,T,tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;T,&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])prime[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)fac[i]=fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    rev[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])    ans[i]=ans[i<span class="number">-1</span>]*(i<span class="number">-1</span>)%p*rev[i%p]%p;</span><br><span class="line">        <span class="keyword">else</span>                ans[i]=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fac[n]*ans[m]%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Number Theory </tag>
            
            <tag> ExGCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI2005 维修数列</title>
      <link href="/2017/03/21/NOI2005-Sequence/"/>
      <url>/2017/03/21/NOI2005-Sequence/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/21/NOI2005%E7%BB%B4%E4%BF%AE%E6%95%B0%E5%88%97/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2042">Luogu 2042</a></p><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=pSziimjjP">COGS 339</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/GU7WeiEhcKmutQw.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立尽量平衡的结构，而不应直接插入（这样初始形态就会变成一条链），否则会导致时间复杂度过高，同时操作后也要注意更新信息。</p><p>对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。</p><p>对于求和操作，具体实现与线段树相同。</p><p>对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。</p><p>（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入$4e6$个元素，但同时也说明队列中最多只有$5e5$个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用）</p><h2 id="V1（暴力）"><a href="#V1（暴力）" class="headerlink" title="V1（暴力）"></a>V1（暴力）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> tot,root,rev[N],size[N],w[N],fa[N],son[N][<span class="number">2</span>],id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=size[son[x][<span class="number">0</span>]]+size[son[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">        rev[son[x][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">        rev[son[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">        rev[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(fa[x]),<span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],t=(son[y][<span class="number">0</span>]==x);</span><br><span class="line">    <span class="keyword">if</span>(z) son[z][son[z][<span class="number">1</span>]==y]=x;fa[x]=z;</span><br><span class="line">    son[y][!t]=son[x][t];fa[son[y][!t]]=y;</span><br><span class="line">    son[x][t]=y;fa[y]=x;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(z!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[z][<span class="number">0</span>]==y^son[y][<span class="number">0</span>]==x) <span class="built_in">zg</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">zg</span>(y);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">zg</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f) root=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++tot;</span><br><span class="line">        son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        size[x]=<span class="number">1</span>;</span><br><span class="line">        w[x]=v;fa[x]=f;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(son[x][v&gt;w[x]],v,x);</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root;</span><br><span class="line">    <span class="keyword">while</span>(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">int</span> l=son[k][<span class="number">0</span>],r=son[k][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(size[l]+<span class="number">1</span>==rank)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size[l]&gt;=rank)<span class="keyword">return</span> <span class="built_in">find</span>(l,rank);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(r,rank-size[l]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">19</span>];</span><br><span class="line"><span class="keyword">int</span> sum1,ans1,max1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])<span class="built_in">inorder</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(w[x]!=inf&amp;&amp;w[x]!=-inf)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[w[x]]);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])<span class="built_in">inorder</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inordermax</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])<span class="built_in">inordermax</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(w[x]!=inf&amp;&amp;w[x]!=-inf)</span><br><span class="line">    &#123;</span><br><span class="line">        max1=<span class="built_in">max</span>(max1,a[w[x]]);</span><br><span class="line">        sum1+=a[w[x]]*num[x];</span><br><span class="line">        <span class="keyword">if</span>(sum1&gt;<span class="number">0</span>)ans1=<span class="built_in">max</span>(ans1,sum1);</span><br><span class="line">        <span class="keyword">else</span>    sum1=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])<span class="built_in">inordermax</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,m,tmp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">insert</span>(root,-inf,<span class="number">0</span>);<span class="built_in">insert</span>(root,inf,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">insert</span>(root,i,<span class="number">0</span>);</span><br><span class="line">    tmp=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,pos,tt,x;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">find</span>(root,pos+<span class="number">1</span>),ne=<span class="built_in">find</span>(root,pos+<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">update</span>(now),<span class="built_in">update</span>(ne);</span><br><span class="line">            <span class="built_in">splay</span>(now,<span class="number">0</span>);<span class="built_in">splay</span>(ne,root);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[++tmp]),<span class="built_in">insert</span>(son[ne][<span class="number">0</span>],tmp,ne);</span><br><span class="line">            <span class="built_in">update</span>(root),<span class="built_in">update</span>(son[root][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">find</span>(root,pos),ne=<span class="built_in">find</span>(root,pos+tt+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(now,<span class="number">0</span>);<span class="built_in">splay</span>(ne,root);</span><br><span class="line">            fa[son[ne][<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">            son[ne][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">update</span>(ne);<span class="built_in">update</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;pos,&amp;tt,&amp;x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=pos+<span class="number">1</span>;t&lt;=pos+tt;++t)</span><br><span class="line">            a[w[<span class="built_in">find</span>(root,t)]]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">find</span>(root,pos),ne=<span class="built_in">find</span>(root,pos+tt+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">update</span>(now),<span class="built_in">update</span>(ne);</span><br><span class="line">            <span class="built_in">splay</span>(now,<span class="number">0</span>);<span class="built_in">splay</span>(ne,root);</span><br><span class="line">            <span class="keyword">int</span> s=son[ne][<span class="number">0</span>];</span><br><span class="line">            rev[s]^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)</span><br><span class="line">            sum+=a[<span class="built_in">find</span>(root,pos+t)<span class="number">-2</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1=ans1=<span class="number">0</span>;max1=<span class="number">-0x7fffffff</span>;</span><br><span class="line">            <span class="built_in">inordermax</span>(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans1==<span class="number">0</span>?max1:ans1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    inorder(root);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="V2（正解）"><a href="#V2（正解）" class="headerlink" title="V2（正解）"></a>V2（正解）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,root,cnt;</span><br><span class="line"><span class="keyword">int</span> sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][<span class="number">2</span>];;</span><br><span class="line"><span class="keyword">bool</span> tag[N],rev[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sonl=son[x][<span class="number">0</span>],sonr=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(tag[x])</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sonl)tag[sonl]=<span class="literal">true</span>,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];</span><br><span class="line">        <span class="keyword">if</span>(sonr)tag[sonr]=<span class="literal">true</span>,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];</span><br><span class="line">        <span class="keyword">if</span>(v[x]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];</span><br><span class="line">            <span class="keyword">if</span>(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sonl)lx[sonl]=rx[sonl]=<span class="number">0</span>,mx[sonl]=v[x];</span><br><span class="line">            <span class="keyword">if</span>(sonr)lx[sonr]=rx[sonr]=<span class="number">0</span>,mx[sonr]=v[x];</span><br><span class="line">        &#125;</span><br><span class="line">        rev[x]=tag[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">        rev[x]^=<span class="number">1</span>;rev[sonl]^=<span class="number">1</span>;rev[sonr]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(lx[sonl],rx[sonl]);<span class="built_in">swap</span>(lx[sonr],rx[sonr]);</span><br><span class="line">        <span class="built_in">swap</span>(son[sonl][<span class="number">0</span>],son[sonl][<span class="number">1</span>]);<span class="built_in">swap</span>(son[sonr][<span class="number">0</span>],son[sonr][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])<span class="built_in">inorder</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(v[x]!=inf&amp;&amp;v[x]!=-inf)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[x]);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])<span class="built_in">inorder</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sonl=son[x][<span class="number">0</span>],sonr=son[x][<span class="number">1</span>];</span><br><span class="line">    sum[x]=sum[sonl]+sum[sonr]+v[x];</span><br><span class="line">    size[x]=size[sonl]+size[sonr]+<span class="number">1</span>;</span><br><span class="line">    mx[x]=<span class="built_in">max</span>(mx[sonl],mx[sonr]);</span><br><span class="line">    mx[x]=<span class="built_in">max</span>(mx[x],rx[sonl]+v[x]+lx[sonr]);</span><br><span class="line">    lx[x]=<span class="built_in">max</span>(lx[sonl],sum[sonl]+v[x]+lx[sonr]);</span><br><span class="line">    rx[x]=<span class="built_in">max</span>(rx[sonr],sum[sonr]+v[x]+rx[sonl]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],l,r;</span><br><span class="line">    l=(son[y][<span class="number">1</span>]==x);r=l^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==k)k=x;</span><br><span class="line">    <span class="keyword">else</span> son[z][son[z][<span class="number">1</span>]==y]=x;</span><br><span class="line">    fa[son[x][r]]=y;fa[y]=x;fa[x]=z;</span><br><span class="line">    son[y][l]=son[x][r];son[x][r]=y;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(y!=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[y][<span class="number">0</span>]==x^son[z][<span class="number">0</span>]==y)<span class="built_in">rotate</span>(x,k);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> l=son[x][<span class="number">0</span>],r=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(size[l]+<span class="number">1</span>==rk)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(size[l]&gt;=rk)<span class="keyword">return</span> <span class="built_in">find</span>(l,rk);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(r,rk-size[l]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l=son[x][<span class="number">0</span>],r=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">rec</span>(l);<span class="built_in">rec</span>(r);q.<span class="built_in">push</span>(x);</span><br><span class="line">    fa[x]=son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    tag[x]=rev[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">find</span>(root,k),y=<span class="built_in">find</span>(root,k+tt+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">splay</span>(x,root);<span class="built_in">splay</span>(y,son[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> son[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">split</span>(k,tt),y=fa[x];</span><br><span class="line">    v[x]=val;tag[x]=<span class="number">1</span>;sum[x]=size[x]*val;</span><br><span class="line">    <span class="keyword">if</span>(val&gt;=<span class="number">0</span>)lx[x]=rx[x]=mx[x]=sum[x];</span><br><span class="line">    <span class="keyword">else</span> lx[x]=rx[x]=<span class="number">0</span>,mx[x]=val;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rever</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">split</span>(k,tt),y=fa[x];</span><br><span class="line">    <span class="keyword">if</span>(!tag[x])</span><br><span class="line">    &#123;</span><br><span class="line">        rev[x]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(lx[x],rx[x]);</span><br><span class="line">        <span class="built_in">update</span>(y);<span class="built_in">update</span>(fa[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">split</span>(k,tt),y=fa[x];</span><br><span class="line">    <span class="built_in">rec</span>(x);son[y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,now=id[mid],last=id[s];</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[now]=a[l];size[now]=<span class="number">1</span>;</span><br><span class="line">        tag[now]=rev[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[l]&gt;=<span class="number">0</span>)lx[now]=rx[now]=mx[now]=a[l];</span><br><span class="line">        <span class="keyword">else</span> lx[now]=rx[now]=<span class="number">0</span>,mx[now]=a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">build</span>(l,mid<span class="number">-1</span>,mid),<span class="built_in">build</span>(mid+<span class="number">1</span>,r,mid);</span><br><span class="line">    v[now]=a[mid];fa[now]=last;<span class="built_in">update</span>(now);</span><br><span class="line">    son[last][mid&gt;=s]=now;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">    <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())id[i]=q.<span class="built_in">front</span>(),q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">else</span> id[i]=++cnt;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,tt,<span class="number">0</span>);<span class="keyword">int</span> z=id[(<span class="number">1</span>+tt)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">find</span>(root,k+<span class="number">1</span>),y=<span class="built_in">find</span>(root,k+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">splay</span>(x,root);<span class="built_in">splay</span>(y,son[x][<span class="number">1</span>]);</span><br><span class="line">    fa[z]=y;son[y][<span class="number">0</span>]=z;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    mx[<span class="number">0</span>]=a[<span class="number">1</span>]=a[n+<span class="number">2</span>]=-inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)id[i]=i;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    root=(n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;cnt=n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> k,tt,val;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">19</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),<span class="built_in">insert</span>(k,tt);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),<span class="built_in">delet</span>(k,tt);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;X&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mx[root]);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;K&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),val=<span class="built_in">read</span>(),<span class="built_in">modify</span>(k,tt,val);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),<span class="built_in">rever</span>(k,tt);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;G&#x27;</span>)&#123;k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>();<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum[<span class="built_in">split</span>(k,tt)]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        inorder(root);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Balance Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通平衡树</title>
      <link href="/2017/03/19/Normal-Balance-Tree/"/>
      <url>/2017/03/19/Normal-Balance-Tree/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/19/%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vJJxmkUVP">COGS 1829</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：</p><ol><li><p>插入$x$数；</p></li><li><p>删除$x$数(若有多个相同的数，因只删除一个)；</p></li><li><p>查询$x$数的排名(若有多个相同的数，因输出最小的排名)；</p></li><li><p>查询排名为$x$的数；</p></li><li><p>求$x$的前驱(前驱定义为小于$x$，且最大的数)；</p></li><li><p>求$x$的后继(后继定义为大于$x$，且最小的数)。</p></li></ol><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为$n$，表示操作的个数，下面$n$行每行有两个数$opt$和$x$，$opt$表示操作的序号$(1&lt;=opt&lt;=6)$，$x$含义如上所示。</p><p>$n$的数据范围：$n&lt;=100000$</p><p>每个数的数据范围：$[−1e7,1e7]$（BZOJ3224:$[−2e9,2e9]$）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于操作$3,4,5,6$每行输出一个数，表示对应答案。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 106465</span><br><span class="line">4 1</span><br><span class="line">1 317721</span><br><span class="line">1 460929</span><br><span class="line">1 644985</span><br><span class="line">1 84185</span><br><span class="line">1 89851</span><br><span class="line">6 81968</span><br><span class="line">1 492737</span><br><span class="line">5 493598</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">106465</span><br><span class="line">84185</span><br><span class="line">492737</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>各种平衡树的模板题（包括SPLAY，TREAP，SBT等等。然而只会SPLAY）</p><h2 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">splay</span>&#123;</span><span class="keyword">int</span> data,ls,rs,fa,size;&#125;a[N];  </span><br><span class="line"><span class="keyword">int</span> q,root=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;a[x].size=a[a[x].ls].size+a[a[x].rs].size+<span class="number">1</span>;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> y=a[x].fa; </span><br><span class="line">    <span class="keyword">int</span> z=a[y].fa; </span><br><span class="line">    a[y].fa=x;a[x].fa=z;  </span><br><span class="line">    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  </span><br><span class="line">    <span class="keyword">if</span>(y==a[z].ls)    a[z].ls=x;</span><br><span class="line">    <span class="keyword">else</span>             a[z].rs=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=a[x].fa;  </span><br><span class="line">    <span class="keyword">int</span> z=a[y].fa;</span><br><span class="line">    a[y].fa=x,a[x].fa=z;</span><br><span class="line">    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;</span><br><span class="line">    <span class="keyword">if</span>(y==a[z].ls)     a[z].ls=x;</span><br><span class="line">    <span class="keyword">else</span>             a[z].rs=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> s)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (a[x].fa!=s)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> y=a[x].fa;  </span><br><span class="line">        <span class="keyword">int</span> z=a[y].fa;  </span><br><span class="line">        <span class="keyword">if</span>(z==s)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==a[y].ls) <span class="built_in">zig</span>(x);  </span><br><span class="line">            <span class="keyword">else</span>           <span class="built_in">zag</span>(x);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(y==a[z].ls)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(x==a[y].ls) <span class="built_in">zig</span>(y),<span class="built_in">zig</span>(x);  </span><br><span class="line">            <span class="keyword">else</span>           <span class="built_in">zag</span>(x),<span class="built_in">zig</span>(x);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(x==a[y].rs) <span class="built_in">zag</span>(y),<span class="built_in">zag</span>(x);  </span><br><span class="line">            <span class="keyword">else</span>           <span class="built_in">zig</span>(x),<span class="built_in">zag</span>(x);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(x);  </span><br><span class="line">    <span class="keyword">if</span> (s==<span class="number">0</span>) root=x;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> p,x=root;  </span><br><span class="line">    <span class="keyword">while</span> (x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        p=x;  </span><br><span class="line">        <span class="keyword">if</span> (a[x].data&gt;w) x=a[x].ls;  </span><br><span class="line">        <span class="keyword">else</span> x=a[x].rs;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> fa,<span class="keyword">int</span> key)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    x=++tot;  </span><br><span class="line">    a[x].ls=a[x].rs=<span class="number">0</span>;  </span><br><span class="line">    a[x].fa=fa;  </span><br><span class="line">    a[x].data=key;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (root==<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">newnode</span>(root,<span class="number">0</span>,w);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="built_in">Search</span>(w);  </span><br><span class="line">    <span class="keyword">if</span> (w&lt;a[i].data) <span class="built_in">newnode</span>(a[i].ls,i,w);     </span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">newnode</span>(a[i].rs,i,w);</span><br><span class="line">    <span class="built_in">splay</span>(tot,<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root,ans=tot+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[x].data&gt;w)&#123;x=a[x].ls;<span class="keyword">continue</span>;&#125;  </span><br><span class="line">        <span class="keyword">if</span>(a[x].data&lt;w)&#123;x=a[x].rs;<span class="keyword">continue</span>;&#125;  </span><br><span class="line">        <span class="keyword">if</span>(a[x].data==w)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ans=x;</span><br><span class="line">            x=a[x].ls; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(ans==tot+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">while</span>(a[x].rs)x=a[x].rs;<span class="keyword">return</span> x;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">while</span> (a[x].ls)x=a[x].ls;<span class="keyword">return</span> x;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpre1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">getmax</span>(a[root].ls);&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getne1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">getmin</span>(a[root].rs);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">get</span>(w);  </span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">int</span> pp=<span class="built_in">getpre1</span>(x),nn=<span class="built_in">getne1</span>(x);  </span><br><span class="line">    <span class="built_in">splay</span>(pp,<span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">splay</span>(nn,root);  </span><br><span class="line">    <span class="keyword">int</span> y=a[x].fa;  </span><br><span class="line">    a[x].fa=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(x==a[y].ls) a[y].ls=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>           a[x].ls=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(root);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">get</span>(w);  </span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> a[a[x].ls].size;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findkth</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> s=a[a[x].ls].size;  </span><br><span class="line">    <span class="keyword">if</span> (k==s+<span class="number">1</span>) <span class="keyword">return</span> a[x].data;  </span><br><span class="line">    <span class="keyword">if</span> (s&gt;=k) <span class="keyword">return</span> <span class="built_in">findkth</span>(a[x].ls,k);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findkth</span>(a[x].rs,k-s<span class="number">-1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpre</span><span class="params">(<span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> y=<span class="built_in">get</span>(w);  </span><br><span class="line">    <span class="built_in">insert</span>(w);  </span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">-1</span>)<span class="built_in">splay</span>(y,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">getmax</span>(a[root].ls);  </span><br><span class="line">    <span class="built_in">delet</span>(w);  </span><br><span class="line">    <span class="keyword">return</span> a[ans].data;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getne</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">insert</span>(w);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">getmin</span>(a[root].rs);</span><br><span class="line">    <span class="built_in">delet</span>(w);</span><br><span class="line">    <span class="keyword">return</span> a[ans].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root=tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">insert</span>(-inf);<span class="built_in">insert</span>(inf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)       <span class="built_in">insert</span>(k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="built_in">delet</span>(k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">findkth</span>(root,k+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getpre</span>(k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getne</span>(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> tot,root,size[N],num[N],key[N],fa[N],son[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=size[son[x][<span class="number">0</span>]]+size[son[x][<span class="number">1</span>]]+num[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//push_down(fa[x]);push_down(x); </span></span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],t=(son[y][<span class="number">0</span>]==x);</span><br><span class="line">    <span class="keyword">if</span>(z) son[z][son[z][<span class="number">1</span>]==y]=x;fa[x]=z;</span><br><span class="line">    son[y][!t]=son[x][t];fa[son[y][!t]]=y;</span><br><span class="line">    son[x][t]=y;fa[y]=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(z!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[z][<span class="number">0</span>]==y^son[y][<span class="number">0</span>]==x) <span class="built_in">zg</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">zg</span>(y);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">zg</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f) root=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++tot;</span><br><span class="line">        son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        size[x]=num[x]=<span class="number">1</span>;</span><br><span class="line">        key[x]=v;fa[x]=f;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v==key[x])</span><br><span class="line">    &#123;</span><br><span class="line">        num[x]++;size[x]++;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(son[x][v&gt;key[x]],v,x);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root;</span><br><span class="line">    <span class="keyword">while</span>(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">get</span>(x);<span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(num[x]&gt;<span class="number">1</span>) &#123;num[x]--;size[x]--;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!son[x][<span class="number">0</span>]||!son[x][<span class="number">1</span>]) root=son[x][<span class="number">0</span>]+son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=son[x][<span class="number">1</span>];<span class="keyword">while</span>(son[y][<span class="number">0</span>]) y=son[y][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">splay</span>(y,x);</span><br><span class="line">        son[y][<span class="number">0</span>]=son[x][<span class="number">0</span>];fa[son[y][<span class="number">0</span>]]=y;</span><br><span class="line">        root=y;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[root]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrank</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(root,v,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=size[son[root][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">delet</span>(v);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=root;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=size[son[y][<span class="number">0</span>]]||x&gt;size[son[y][<span class="number">0</span>]]+num[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=size[son[y][<span class="number">0</span>]]) y=son[y][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> x-=size[son[y][<span class="number">0</span>]]+num[y],y=son[y][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(root,v,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x=son[root][<span class="number">0</span>];<span class="keyword">while</span>(son[x][<span class="number">1</span>]) x=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">delet</span>(v);</span><br><span class="line">    <span class="keyword">return</span> key[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ne</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(root,v,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x=son[root][<span class="number">1</span>];<span class="keyword">while</span>(son[x][<span class="number">0</span>]) x=son[x][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">delet</span>(v);</span><br><span class="line">    <span class="keyword">return</span> key[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)         <span class="built_in">insert</span>(root,y,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">2</span>)         <span class="built_in">delet</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">3</span>)         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getrank</span>(y));</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">4</span>)         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">kth</span>(y));</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">5</span>)         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">pre</span>(y));</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">6</span>)        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ne</span>(y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Balance Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ2778 DNA Sequence</title>
      <link href="/2017/03/18/DNA-Sequence/"/>
      <url>/2017/03/18/DNA-Sequence/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/18/DNA%20Sequence/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://poj.org/problem?id=2778">POJ 2778</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments.</p><p>Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. </p><p>First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.</p><p>Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. </p><p>Output An integer, the number of DNA sequences, mod 100000.</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">AT</span><br><span class="line">AC</span><br><span class="line">AG</span><br><span class="line">AA</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目大意为给定$n$个病毒串，求不包含这些病毒串且长度为$m$的资源串个数（均由A,G,C,T组成）。</p><p>这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即$res[i][t]$存的是从$i$到$t$恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res′=res^m$时，$res′[i][t]$表示从$i$到$t$恰好走$m$步能到达的方案数。</p><p>有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点$0$<br>到叶节点$i$的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其$fail$指针指向病毒串），只需要传递一下即可。</p><p>刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又$TLE$了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。（看来当时还没理解AC自动机的原理）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N =<span class="number">200</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf =<span class="number">255</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,tr[N][<span class="number">4</span>],tot,tmp,fail[N];</span><br><span class="line"><span class="keyword">int</span> idd[N];</span><br><span class="line"><span class="keyword">bool</span> tag[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ss[<span class="number">4</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">martix</span>&#123;</span><span class="keyword">long</span> <span class="keyword">long</span> a[N][N];&#125;res,ans;</span><br><span class="line">martix <span class="keyword">operator</span> * (martix c,martix b)</span><br><span class="line">&#123;</span><br><span class="line">    martix ret;</span><br><span class="line">    <span class="built_in">memset</span>(ret.a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ret.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;=tot;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=tot;++k)</span><br><span class="line">        ret.a[i][t]+=c.a[i][k]*b.a[k][t];</span><br><span class="line">        ret.a[i][t]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;idd[ss[<span class="number">0</span>]]=<span class="number">0</span>;idd[ss[<span class="number">1</span>]]=<span class="number">1</span>;idd[ss[<span class="number">2</span>]]=<span class="number">2</span>;idd[ss[<span class="number">3</span>]]=<span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now][idd[s[i]]]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[now][idd[s[i]]]=++tot;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)tr[tot][j]=<span class="number">-1</span>;    </span><br><span class="line">        <span class="comment">//    tag[tot]=0;</span></span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][idd[s[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[now]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;fail[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">0</span>][j]!=<span class="number">-1</span>)q.<span class="built_in">push</span>(tr[<span class="number">0</span>][j]),fail[tr[<span class="number">0</span>][j]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tr[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tag[fail[x]])tag[x]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">        <span class="keyword">if</span>(tr[x][j]!=<span class="number">-1</span>)fail[tr[x][j]]=tr[fail[x]][j],q.<span class="built_in">push</span>(tr[x][j]);    </span><br><span class="line">        <span class="keyword">else</span> tr[x][j] =tr[fail[x]][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">    <span class="keyword">if</span>(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)tr[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="built_in">getfail</span>();</span><br><span class="line">    <span class="built_in">slove</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;++i)ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;cout&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m&amp;<span class="number">1</span>) ans=ans*res;</span><br><span class="line">        m/=<span class="number">2</span>;</span><br><span class="line">        res=res*res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> anss=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;++i)(anss+=ans.a[<span class="number">0</span>][i])%=mod;</span><br><span class="line">    cout&lt;&lt;anss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> AC Automaton </tag>
            
            <tag> String Manipulation </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>病毒侵袭</title>
      <link href="/2017/03/17/AC-template/"/>
      <url>/2017/03/17/AC-template/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/17/%E7%97%85%E6%AF%92%E5%85%A5%E4%BE%B5/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2896">HDU 2896</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~</p><p>但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。</p><p>万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个整数$N(1&lt;=N&lt;=500)$，表示病毒特征码的个数。</p><p>接下来$N$行，每行表示一个病毒特征码，特征码字符串长度在$20—200$之间。</p><p>每个病毒都有一个编号，依此为$1 \sim N$。</p><p>不同编号的病毒特征码不会相同。</p><p>在这之后一行，有一个整数$M（1&lt;=M&lt;=1000）$，表示网站数。</p><p>接下来$M$行，每行表示一个网站源码，源码字符串长度在$7000—10000$之间。</p><p>每个网站都有一个编号，依此为$1 \sim M$。</p><p>以上字符串中字符都是$ASCII$码可见字符（不包括回车）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web 网站编号: 病毒编号 病毒编号 ...</span><br></pre></td></tr></table></figure><p>冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。</p><p>最后一行输出统计信息，如下格式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">total: 带病毒网站数</span><br></pre></td></tr></table></figure><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">2</span><br><span class="line">aaabbbccc</span><br><span class="line">bbaacc</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web 1: 1 2 3</span><br><span class="line">total: 1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>AC自动机模板题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">501</span>*<span class="number">201</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1001</span>],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">bool</span> use[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> noww)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now][s[i]]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[now][s[i]]=++tot;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxf;++j)tr[tot][j]=<span class="number">-1</span>;</span><br><span class="line">            tag[tot]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[now]=noww;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxf;++i)</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">0</span>][i]!=<span class="number">-1</span>)</span><br><span class="line">    fail[tr[<span class="number">0</span>][i]]=<span class="number">0</span>,q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">else</span> tr[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxf;++j)</span><br><span class="line">        <span class="keyword">if</span>(tr[x][j]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;q.<span class="built_in">push</span>(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        tr[x][j]=tr[fail[x]][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> noww)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(use,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(use));</span><br><span class="line">    tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        now=tr[now][s[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=now;j;j=fail[j])</span><br><span class="line">        <span class="keyword">if</span>(tag[j]&amp;&amp;!use[tag[j]])</span><br><span class="line">        ans[++tmp]=tag[j],use[tag[j]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        ans2++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;web %d:&quot;</span>,noww);</span><br><span class="line">        <span class="built_in">sort</span>(ans+<span class="number">1</span>,ans+tmp+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tmp;++j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,ans[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxf;++i)tr[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="built_in">getfail</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),<span class="built_in">solve</span>(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;total: %d\n&quot;</span>,ans2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> AC Automaton </tag>
            
            <tag> String Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟赛 2017-03-17</title>
      <link href="/2017/03/17/NOIP-2017-3-17/"/>
      <url>/2017/03/17/NOIP-2017-3-17/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/17/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B%202017%203%2017/">原文</a>）</p></div><h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问题。今天，他想到了一个十分有意思的题目：</p><p>首先，花花会在$x$轴正半轴和$y$轴正半轴分别挑选$n$个点。随后，他将$x$轴的点与$y$轴的点一一连接，形成$n$条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅有一种。最后，花花会给出$m$个询问。对于每个询问，将会给定一个点$P(x_p,y_p)$，问线段$OP$（$O$ 为坐标原点）与$n$条线段会产生多少个交点？</p><p>输入第 $1$ 行包含一个正整数 $n$，表示线段的数量；</p><p>第 $2$ 行包含 $n$ 个正整数，表示花花在 $x$ 轴选取的点的横坐标；</p><p>第 $3$ 行包含 $n$ 个正整数，表示花花在 $y$ 轴选取的点的纵坐标；</p><p>第 $4$ 行包含一个正整数 $m$，表示询问数量；</p><p>随后 $m$ 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 5 3</span><br><span class="line">3 5 4</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $40 \ percent $ 的数据：$n,m ≤ 10$</p><p>另有 $20 \ percent $ 的数据：$n,m ≤ 100$</p><p>另有 $20 \ percent $ 的数据：$n,m ≤ 1000$</p><p>对于 $100 \ percent $ 的数据：$n,m ≤ 10^5,y &lt; 2^{31}$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y_p$ 与 $y_mid$ 大小即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x[N],y[N];</span><br><span class="line"><span class="keyword">double</span> a[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">get</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">get</span>(x[i]);<span class="built_in">sort</span>(x+<span class="number">1</span>,x+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">get</span>(y[i]);<span class="built_in">sort</span>(y+<span class="number">1</span>,y+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,xx,yy;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span>(xx);<span class="built_in">get</span>(yy);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n,mid;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));</span><br><span class="line">            <span class="keyword">double</span> yt=a[mid]*(db)xx+y[mid];</span><br><span class="line">            <span class="keyword">if</span>(yt&lt;=(db)yy) l=mid;</span><br><span class="line">            <span class="keyword">else</span>          r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="花花的聚会"><a href="#花花的聚会" class="headerlink" title="花花的聚会"></a>花花的聚会</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>花花住在 H 国。H 国有 $n$ 个城市，其中 $1$ 号城市为其首都。城市间有$n − 1$条单向道路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市走到首都的路径是唯一的。</p><p>过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 $m$ 种过路券，每张过路券以三个整数表示：$v,k,w$：你可以在城市 $v$ 以价格 $w$ 买到一张过路券。这张券可以使用 $k$ 次。这意味着，拿着这张券通过了 $k$ 条道路之后，这张券就不能再使用了。</p><p>请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，并且在所在的城市再买一张。</p><p>花花家在首都。他有 $q$ 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。</p><p>花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮他么？</p><p>输入的第一行包含两个空格隔开的整数 $n$ 和 $m$，表示 H 国的城市数量和过路券的种数。</p><p>之后的 $n − 1$ 行各自包含两个数 $a_i$ 和 $b_i$ ，代表城市 $a_i$ 到城市 $b_i$ 间有一条单向道路。</p><p>之后的 $m$ 行每行包括三个整数 $v_i$ ,$k_i$ 和 $w_i$ ，表示一种过路券。</p><p>下一行包含一个整数 $q$，表示花花朋友的数量。</p><p>之后的 $q$ 行各自包含一个整数，表示花花朋友的所在城市。</p><p>输出共 $q$ 行，每一行代表一位朋友的路费。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7</span><br><span class="line">3 1</span><br><span class="line">2 1</span><br><span class="line">7 6</span><br><span class="line">6 3</span><br><span class="line">5 3</span><br><span class="line">4 3</span><br><span class="line">7 2 3</span><br><span class="line">7 1 1</span><br><span class="line">2 3 5</span><br><span class="line">3 6 2</span><br><span class="line">4 2 4</span><br><span class="line">5 3 10</span><br><span class="line">6 1 20</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">22</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $40 \ percent$ 的数据：$n,m,q ≤ 10,w_i ≤ 10$</p><p>另有 $20 \ percent$ 的数据：$n,m,q ≤ 500,w_i ≤ 100$</p><p>另有 $20 \ percent$ 的数据：$n,m,q ≤ 5000,w_i ≤ 1000$</p><p>对于 $100 \ percent$ 的数据：$n,m,q ≤ 10^5 ,w_i ≤ 10000,1 ≤ v_i,k_i ≤ n$</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：</p><p>$$f[y] = min {\lbrace f[x] + w[y][i] \rbrace} ( x 为 y 祖先, dep[x] - dep[y] &gt; = k[y][i] )$$</p><p>对于寻找$min \lbrace f[x] \rbrace $的操作，则可以通过倍增或树链剖分的方法实现。(要开 $long long$ 不然会爆)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxlogn =<span class="number">21</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> deep[N],head[N],head2[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> st[N][maxlogn],minn[N][maxlogn],f[N];</span><br><span class="line"><span class="keyword">int</span> tot,tot2,n,m,qu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edg</span>&#123;</span><span class="keyword">int</span> t,ne;&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edg2</span>&#123;</span><span class="keyword">int</span> k,w,ne;&#125;e2[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].ne=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e2[++tot2].k=k;</span><br><span class="line">    e2[tot2].w=w;</span><br><span class="line">    e2[tot2].ne=head2[x];</span><br><span class="line">    head2[x]=tot2;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[x][<span class="number">0</span>]=pre;minn[x][<span class="number">0</span>]=f[pre];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxlogn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[x][i]=st[st[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        minn[x][i]=<span class="built_in">min</span>(minn[x][i<span class="number">-1</span>],minn[st[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=x==<span class="number">1</span>?<span class="number">0</span>:inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head2[x];i;i=e2[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp=inf,y=x,k=e2[i].k,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>)tmp=<span class="built_in">min</span>(tmp,minn[y][p]),y=st[y][p];</span><br><span class="line">            p++;k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x]=<span class="built_in">min</span>(f[x],tmp+e2[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(y!=pre)<span class="built_in">getf</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;party.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;party.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,k,w;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;k,&amp;w),<span class="built_in">in2</span>(x,k,w);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;qu);<span class="built_in">getf</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=qu;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[x]);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一些功能。</p><p>功能列表如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; w</span><br><span class="line"></span><br><span class="line">w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。</span><br><span class="line">该命令将选定光标向左移动，如果已经是最左端则不移动。</span><br><span class="line">命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。</span><br><span class="line"></span><br><span class="line">&gt; w</span><br><span class="line"></span><br><span class="line">w 同上。</span><br><span class="line">与&lt; 命令不同的是，该命令将光标向右移动。</span><br><span class="line">命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。</span><br><span class="line"></span><br><span class="line">I w c</span><br><span class="line"></span><br><span class="line">w 同上。</span><br><span class="line">c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。</span><br><span class="line">该命令始终输出“T”。</span><br><span class="line"></span><br><span class="line">D w</span><br><span class="line"></span><br><span class="line">w 同上。</span><br><span class="line">代表删除该光标右侧的一个字符。</span><br><span class="line">命令执行成功时输出“T”，若光标右侧没有字符输出“F”。</span><br><span class="line"></span><br><span class="line">R</span><br><span class="line"></span><br><span class="line">代表翻转左光标和右光标之间的字符。</span><br><span class="line">该命令只有左光标在右光标左侧时才能执行。</span><br><span class="line">（两光标重合时也不能执行）</span><br><span class="line">命令执行成功时输出“T”，否则输“F”。</span><br><span class="line"></span><br><span class="line">S</span><br><span class="line"></span><br><span class="line">代表显示当前处理的文本。</span><br><span class="line">该命令只输出文本，不输出“T”和“F”。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。</p><p>注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。</p><p>输入第一行是初始时文本编辑器内容。</p><p>第二行是一个正整数 $N$，$N$ 表示操作次数。</p><p>接下来有 $N$ 行，每行有一个命令，命令格式如上方表格。</p><p>对于每个命令，按上方表格要求执行并输出。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goodykc</span><br><span class="line">11</span><br><span class="line">I R u</span><br><span class="line">I R l</span><br><span class="line">&gt; L</span><br><span class="line">&gt; L</span><br><span class="line">&gt; L</span><br><span class="line">&gt; L</span><br><span class="line">R</span><br><span class="line">D R</span><br><span class="line">&lt; R</span><br><span class="line">D R</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">goodluck</span><br></pre></td></tr></table></figure><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $40 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $≤ 100$，数据不包含翻转（Reverse）操作；</p><p>另有 $30 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $ ≤ 10^5$ ，数据不包含翻转（Reverse）操作；</p><p>另有 $20 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $ ≤ 10^5$ ，数据包含翻转（Reverse）操作；</p><p>对于 $100 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $ ≤ 4 × 10^6$ ，输出文件大小 $≤ 20MB$。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。</p><p>具体的实现代码十分清楚，但还有许多细节要注意，因为 $l,r$ 的相对位置可能互换，所以只能写左开右开或左闭右闭区间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot,m,pos[<span class="number">2</span>],cnt[<span class="number">2</span>],pre[N],next[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> opreator,ch[N],str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">()</span></span>&#123;<span class="built_in">getchar</span>();<span class="keyword">return</span> <span class="built_in">getchar</span>()==<span class="string">&#x27;L&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> opreator,<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    ch[tot]=c;</span><br><span class="line">    <span class="keyword">int</span> u=pos[opreator],v=next[u];</span><br><span class="line"></span><br><span class="line">    pre[tot]=u;next[tot]=v;</span><br><span class="line">    next[u]=tot;pre[v]=tot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt[opreator^<span class="number">1</span>]&gt;=cnt[opreator])cnt[opreator^<span class="number">1</span>]++;</span><br><span class="line"></span><br><span class="line">    pos[opreator]=tot;cnt[opreator]++;</span><br><span class="line">    <span class="keyword">if</span> (pos[opreator^<span class="number">1</span>]==u)pos[opreator^<span class="number">1</span>]=tot;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll</span><span class="params">(<span class="keyword">int</span> opreator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[opreator]==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> u=pos[opreator],v=pre[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next[v]!=u)<span class="built_in">swap</span>(next[v],pre[v]);</span><br><span class="line"></span><br><span class="line">    pos[opreator]=v; cnt[opreator]--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rl</span><span class="params">(<span class="keyword">int</span> opreator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next[pos[opreator]]==<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> u=next[pos[opreator]],v=next[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre[v]!=u)<span class="built_in">swap</span>(next[v],pre[v]);</span><br><span class="line"></span><br><span class="line">    pos[opreator]=u;cnt[opreator]++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> opreator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next[pos[opreator]]== <span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> u = pos[opreator], v = next[u], w = next[v];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre[w]!=v) <span class="built_in">swap</span>(next[w], pre[w]);</span><br><span class="line">    <span class="keyword">if</span> (cnt[opreator^<span class="number">1</span>]&gt;cnt[opreator])cnt[opreator^<span class="number">1</span>]--;</span><br><span class="line">    <span class="keyword">if</span> (pos[opreator^<span class="number">1</span>]==v)pos[opreator^<span class="number">1</span>]=u;</span><br><span class="line"></span><br><span class="line">    next[u]= w;pre[w]=u;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[<span class="number">1</span>]-cnt[<span class="number">0</span>]&lt;=<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt[<span class="number">1</span>]-cnt[<span class="number">0</span>]==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> now=pos[<span class="number">0</span>],ne=next[now],c=pos[<span class="number">1</span>],d=next[c];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(pre[ne], next[ne]);<span class="built_in">swap</span>(pre[c],next[c]);</span><br><span class="line">    next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;</span><br><span class="line">    pos[<span class="number">1</span>]=ne;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[next[u]]!= u)<span class="built_in">swap</span>(pre[next[u]],next[next[u]]);</span><br><span class="line">        u=next[u];</span><br><span class="line">        <span class="keyword">if</span> (u==<span class="number">2</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(ch[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">2</span>;</span><br><span class="line">    pre[<span class="number">1</span>]=<span class="number">-1</span>;next[<span class="number">1</span>]= <span class="number">2</span>;</span><br><span class="line">    pre[<span class="number">2</span>]=<span class="number">1</span>;next[<span class="number">2</span>]=<span class="number">-1</span>;</span><br><span class="line">    pos[<span class="number">0</span>]=pos[<span class="number">1</span>]=cnt[<span class="number">0</span>]=cnt[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        ch[tot]=str[i];</span><br><span class="line">        pre[tot]= i==<span class="number">0</span>?<span class="number">1</span>:tot<span class="number">-1</span>;</span><br><span class="line">        next[tot]= i==len<span class="number">-1</span>?<span class="number">2</span>:tot+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next[<span class="number">1</span>]=<span class="number">3</span>;pre[<span class="number">2</span>]=tot;</span><br><span class="line">        pos[<span class="number">1</span>]=tot;cnt[<span class="number">1</span>]=len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">act</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(opreator==<span class="string">&#x27;&lt;&#x27;</span>)         <span class="built_in">ll</span>(<span class="built_in">move</span>());</span><br><span class="line">    <span class="keyword">if</span>(opreator==<span class="string">&#x27;&gt;&#x27;</span>)         <span class="built_in">rl</span>(<span class="built_in">move</span>());</span><br><span class="line">    <span class="keyword">if</span>(opreator==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="built_in">move</span>();</span><br><span class="line">        <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (c&lt;<span class="number">33</span>||c&gt;<span class="number">126</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">in</span>(d,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opreator==<span class="string">&#x27;D&#x27;</span>)         <span class="built_in">D</span>(<span class="built_in">move</span>());</span><br><span class="line">    <span class="keyword">if</span> (opreator==<span class="string">&#x27;R&#x27;</span>)         <span class="built_in">R</span>();</span><br><span class="line">    <span class="keyword">if</span> (opreator==<span class="string">&#x27;S&#x27;</span>)         <span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        opreator=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (opreator!=<span class="string">&#x27;&lt;&#x27;</span>&amp;&amp; opreator!=<span class="string">&#x27;&gt;&#x27;</span>&amp;&amp;!(opreator &gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp; opreator &lt;=<span class="string">&#x27;Z&#x27;</span>))opreator=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">act</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Linked List </tag>
            
            <tag> Computation Geometry </tag>
            
            <tag> Chain Subdivision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAOI2007 理想的正方形</title>
      <link href="/2017/03/14/HAOI2007-square/"/>
      <url>/2017/03/14/HAOI2007-square/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/14/%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2216">Luogu 2216</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/Tnt2a1BP8wdcMIV.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二维滑动窗口，先对每一行建立双端队列，记录每一个$1*n$的长方体中的极值，将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n*1$的长方体(在原矩阵中为$n*n$的正方形)中的极值（$miny[i][t],maxy[i][t]$存储的是以$(i,t)$为右下角端点的$n*n$正方形的极值信息），枚举即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e3</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];</span><br><span class="line"><span class="keyword">int</span> y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];</span><br><span class="line"><span class="keyword">int</span> mapp[N][N],a,b,n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=inf;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get</span>(a),<span class="built_in">get</span>(b),<span class="built_in">get</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)<span class="built_in">get</span>(mapp[i][t]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--;</span><br><span class="line">        x1[++tailx1[i]]=t;</span><br><span class="line">        <span class="keyword">while</span>(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++;</span><br><span class="line">        minx[i][t]=mapp[i][x1[headx1[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--;</span><br><span class="line">        x2[++tailx2[i]]=t;</span><br><span class="line">        <span class="keyword">while</span>(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++;</span><br><span class="line">        maxx[i][t]=mapp[i][x2[headx2[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--;</span><br><span class="line">        y1[++taily1[t]]=i;</span><br><span class="line">        <span class="keyword">while</span>(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++;</span><br><span class="line">        miny[i][t]=minx[y1[heady1[t]]][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--;</span><br><span class="line">        y2[++taily2[t]]=i;</span><br><span class="line">        <span class="keyword">while</span>(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++;</span><br><span class="line">        maxy[i][t]=maxx[y2[heady2[t]]][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">if</span>(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟赛 2017-03-12</title>
      <link href="/2017/03/12/NOIP-2017-3-12/"/>
      <url>/2017/03/12/NOIP-2017-3-12/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/13/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B%202017%203%2012/">原文</a>）</p></div><h1 id="Blue"><a href="#Blue" class="headerlink" title="Blue"></a>Blue</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。</p><p>他最近开始研究青蛙过河的问题，可以简化成：数轴上 $0$ 为岸边，$L$ 为河对岸。$(0,L)$中间存在 $n$ 个石子。已知青蛙一跳可以跳距离 $D$，而且不能沾水。求问能不能跳到河对岸。</p><p>当然他觉得这个问题非常 naïve，于是在思考如果青蛙有$m$个，且石头被踩过之后就会沉下去，$m$ 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。</p><p>输入第一行为一个正整数 $T$ 代表数据组数。每组数据第一行四个正整数：$n、m、D、L$。</p><p>第二行 $n$ 个升序正整数 $a_i$ 代表第 $i$ 个石子坐标为 $a_i$。保证没有重复且都小于 $L$。</p><p>输出 $T$ 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10 9 16 30</span><br><span class="line">2 4 6 9 11 15 18 19 25 27 </span><br><span class="line">10 1 23 30</span><br><span class="line">10 11 13 14 15 16 18 26 27 29 </span><br><span class="line">10 7 28 30</span><br><span class="line">2 3 7 9 12 15 20 24 27 28 </span><br><span class="line">10 3 18 30</span><br><span class="line">1 6 9 14 18 19 22 27 28 29 </span><br><span class="line">10 7 10 30</span><br><span class="line">1 2 4 6 18 19 20 22 23 26 </span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">Excited</span><br><span class="line">Excited</span><br><span class="line">Excited</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$10 \ percent$的数据保证 $m=1$</p><p>对于另外$10 \ percent$的数据保证 $D=L$</p><p>对于另外$10 \ percent$的数据保证 $n=L−1$</p><p>对于另外$30 \ percent$的数据保证 $n&lt;=100,L&lt;=10^5$</p><p>对于$100 \ percent$的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$</p><p>数据范围中的 $n、m$ 皆代表题目描述中 $n、m$ 的总和。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和$d$的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。</p><p>具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了…</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tt,n,m,d,l,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)b[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> anss=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">1</span>;now&lt;=n;++now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[now]-b[++anss]&lt;=d)b[anss]=a[now];</span><br><span class="line">        <span class="keyword">if</span>(anss==ans)anss=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)</span><br><span class="line">    <span class="keyword">if</span>(l-b[i]&gt;d)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(d),<span class="built_in">read</span>(l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">int</span> ll=<span class="number">0</span>,rr=m,mid;</span><br><span class="line">        <span class="keyword">while</span>(ll!=rr)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=ll+rr+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid))    ll=mid;</span><br><span class="line">            <span class="keyword">else</span>            rr=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rr==m)    <span class="built_in">printf</span>(<span class="string">&quot;Excited\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Weed"><a href="#Weed" class="headerlink" title="Weed"></a>Weed</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。</p><p>为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。</p><p>电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为$v_i$的金坷垃，或者除掉最新$v_i$层（不是量）撒的金坷垃。如果上面只留有不足$v_i$层金坷垃，那么就相当于电脑上面没有金坷垃了。</p><p>duyege非常严谨，一开始先给你$m$个上述操作要你依次完成。然后又对实验步骤进行了$q$次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最终金坷垃的量有多少。</p><p>输入第一行为两个正整数$m、q$，接下来$m$行每行$2$个整数$k、v_i$。$k$为$0$时撒金坷垃，为$1$时除金坷垃。接下来$q$行每行$3$个整数$c_i、k、v_i$，$c_i$代表被更改的操作是第$c_i$个，后面$2$个数描述更改为这样的操作。</p><p>输出 $q$ 行代表每次金坷垃的量为多少。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">0 10</span><br><span class="line">1 5</span><br><span class="line">0 13</span><br><span class="line">0 18</span><br><span class="line">0 2</span><br><span class="line">1 1</span><br><span class="line">0 8</span><br><span class="line">0 9</span><br><span class="line">1 3</span><br><span class="line">0 7</span><br><span class="line">9 0 3</span><br><span class="line">10 1 7</span><br><span class="line">6 0 8</span><br><span class="line">10 0 5</span><br><span class="line">8 1 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">58</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">66</span><br><span class="line">41</span><br></pre></td></tr></table></figure><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$30 \ percent$的数据，$m&lt;=1000,q&lt;=1000$</p><p>对于另外$20 \ percent$的数据，每次 $k=1$ 时都会将金坷垃清空。</p><p>对于$100 \ percent$的数据，$m&lt;=2*10^5,q&lt;=2*10^5,v_i&lt;=10^4$</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现…</p><p>题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build</span>&#123;</span><span class="keyword">int</span> sum,in,out;&#125;tr[<span class="number">8</span>*N];</span><br><span class="line"><span class="keyword">int</span> n,q,k,a[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pot&gt;=tr[x].in)            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!pot)                    <span class="keyword">return</span> tr[x].sum;</span><br><span class="line">    <span class="keyword">if</span>(pot&lt;=tr[x*<span class="number">2</span>+<span class="number">1</span>].in)</span><br><span class="line">    <span class="keyword">return</span> tr[x].sum-tr[x*<span class="number">2</span>+<span class="number">1</span>].sum+<span class="built_in">find</span>(x*<span class="number">2</span>+<span class="number">1</span>,pot);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x*<span class="number">2</span>,pot-tr[x*<span class="number">2</span>+<span class="number">1</span>].in+tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].in=tr[x*<span class="number">2</span>+<span class="number">1</span>].in+<span class="built_in">max</span>(<span class="number">0</span>,tr[x*<span class="number">2</span>].in-tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">    tr[x].out=tr[x*<span class="number">2</span>].out+<span class="built_in">max</span>(<span class="number">0</span>,tr[x*<span class="number">2</span>+<span class="number">1</span>].out-tr[x*<span class="number">2</span>].in);</span><br><span class="line">    tr[x].sum=tr[x*<span class="number">2</span>+<span class="number">1</span>].sum+<span class="built_in">find</span>(x*<span class="number">2</span>,tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l]&lt;<span class="number">0</span>)    tr[x].out=-a[l];</span><br><span class="line">        <span class="keyword">else</span>        tr[x].in=<span class="number">1</span>,tr[x].sum=a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x*<span class="number">2</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(x*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pot,<span class="keyword">int</span> w,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;tr[x],<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[x]));</span><br><span class="line">        <span class="keyword">if</span>(w&lt;<span class="number">0</span>)        tr[x].out=-w;</span><br><span class="line">        <span class="keyword">else</span>        tr[x].in=<span class="number">1</span>,tr[x].sum=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pot&gt;mid)    <span class="built_in">change</span>(x*<span class="number">2</span>+<span class="number">1</span>,pot,w,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">else</span>        <span class="built_in">change</span>(x*<span class="number">2</span>,pot,w,l,mid);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(k),<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(k)a[i]*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,w;</span><br><span class="line">        <span class="built_in">read</span>(x);<span class="built_in">read</span>(k);<span class="built_in">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span>(k)w*=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,x,w,<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Drink"><a href="#Drink" class="headerlink" title="Drink"></a>Drink</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个遥远的国度有一个腰缠万贯的资本家Link，每一个拜访他的人都可以得到一份丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了Link家。Link智商超群（不然也赚不到这么多资本），所以决定用特殊的方法赏赐毒液哥。</p><p>Link的藏宝库是一个$N * M$棋盘，每个格子里都有宝物。Link会对棋盘做$Q$次操作，每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转$90$度）。毒液哥不仅财富值被Link碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财的他想知道最后棋盘内所有的宝物价值以方便他挑选。</p><p>作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）和资产阶级代表（Link）之间的贫富差距么。</p><p>输入第一行三个数 $N, M, Q$ 分别表示棋盘的行数、列数和操作个数。</p><p>接下来 $N$ 行每行 $M$ 个数表示一开始棋盘上宝物的价值。</p><p>接下来 $Q$ 行每行 $3$ 个数 $x, y, c$ 表示操作区域为以第 $x$ 行第 $y$ 列为左上角的边长为 $c$ 的正方形。</p><p>输出一个 $N * M$ 的矩阵表示最后的棋盘。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">1 1 3</span><br><span class="line">3 3 2</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 5 1 4 </span><br><span class="line">2 7 6 8 </span><br><span class="line">3 7 2 3 </span><br><span class="line">5 6 8 4 </span><br></pre></td></tr></table></figure><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $30 \ percent$的数据，$N, M, Q &lt;= 100$.</p><p>对于另外 $30 \ percent$的数据，保证所有 $Q$ 个正方形两两之间不相交或相等。</p><p>对于 $100 \ percent$的数据, $N, M, Q &lt;= 1000$，棋盘内所有数取值都为 $0 ~ 9$。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（$p=0$），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（$p=(p+1)%4$），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @Author: 閫搁棽</span></span><br><span class="line"><span class="comment">* @Date:   2016-09-25 13:04:44</span></span><br><span class="line"><span class="comment">* @Last Modified by:   閫搁棽</span></span><br><span class="line"><span class="comment">* @Last Modified time: 2016-10-01 10:19:00</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstdio&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstdlib&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstring&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 2005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Eps</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Get(x, a) (x ? x -&gt; a : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Num = <span class="number">0</span>, Flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            Flag = -Flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        Num = Num * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> Num * Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">int</span> A[MAX_SIZE * MAX_SIZE][<span class="number">4</span>], Map[MAX_SIZE][MAX_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> &amp;Direction, <span class="keyword">int</span> &amp;Now, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Next = A[Now][j - Direction + <span class="number">4</span> &amp; <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(Direction = <span class="number">0</span>; A[Next][j - Direction + <span class="number">6</span> &amp; <span class="number">3</span>] != Now; ++Direction);</span><br><span class="line">    Now = Next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="comment">//    freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            Map[i][j] = <span class="built_in">Get_Int</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (N + <span class="number">2</span>) * (M + <span class="number">2</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][<span class="number">0</span>] = i - M - <span class="number">2</span>;</span><br><span class="line">        A[i][<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        A[i][<span class="number">2</span>] = i + M + <span class="number">2</span>;</span><br><span class="line">        A[i][<span class="number">3</span>] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">Get_Int</span>(), y = <span class="built_in">Get_Int</span>(), c = <span class="built_in">Get_Int</span>();</span><br><span class="line">        <span class="keyword">int</span> Direction = <span class="number">0</span>, Now = <span class="number">1</span>;</span><br><span class="line">        vector&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; Border[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line">            <span class="built_in">Move</span>(Direction, Now, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; ++i)</span><br><span class="line">            <span class="built_in">Move</span>(Direction, Now, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Border[j][<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(Direction, Now));</span><br><span class="line">                <span class="built_in">Move</span>(Direction, Now, j);</span><br><span class="line">                Border[j][<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(Direction, Now));</span><br><span class="line">                <span class="built_in">Move</span>(Direction, Now, j + <span class="number">2</span> &amp; <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(i != c)</span><br><span class="line">                    <span class="built_in">Move</span>(Direction, Now, j + <span class="number">1</span> &amp; <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Now = Border[j][<span class="number">1</span>][i];</span><br><span class="line">                A[Now.second][j + <span class="number">6</span> - Now.first &amp; <span class="number">3</span>] = Border[j + <span class="number">3</span> &amp; <span class="number">3</span>][<span class="number">0</span>][i].second;</span><br><span class="line">                Now = Border[j][<span class="number">0</span>][i];</span><br><span class="line">                A[Now.second][j + <span class="number">4</span> - Now.first &amp; <span class="number">3</span>] = Border[j + <span class="number">1</span> &amp; <span class="number">3</span>][<span class="number">1</span>][i].second;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Direction = <span class="number">0</span>, Now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Move</span>(Direction, Now, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = Direction, Next = Now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Move</span>(temp, Next, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Map[(Next - <span class="number">1</span>) / (M + <span class="number">2</span>)][(Next - <span class="number">1</span>) % (M + <span class="number">2</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Greedy </tag>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCOI2010 股票交易</title>
      <link href="/2017/03/11/SCOI2010-stock/"/>
      <url>/2017/03/11/SCOI2010-stock/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/11/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2569">Luogu 2569</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/1CEApHJgZcvU6Xs.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="o-t∗maxp-2-算法"><a href="#o-t∗maxp-2-算法" class="headerlink" title="$o(t∗maxp^2)$算法"></a>$o(t∗maxp^2)$算法</h2><p>$o(t∗maxp^2)$算法有70分，还是比较良心的。</p><p>这题转移方程也不难想，可以设$dp[i][j]$为第$i$天后手中还剩$t$张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买$3$张股票，那么$dp[1][4]$是便是无效的，不妨将$dp$数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2017</span>;</span><br><span class="line"><span class="keyword">int</span> n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;maxp,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,ap+i,bp+i,as+i,bs+i);</span><br><span class="line">  <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;<span class="comment">//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j]);<span class="comment">//该天没有操作</span></span><br><span class="line">          <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;=<span class="built_in">min</span>(j+bs[i],maxp);++k)</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][k]+(k-j)*bp[i]);<span class="comment">//卖出</span></span><br><span class="line">          <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="built_in">max</span>(j-as[i],<span class="number">0</span>);k&lt;j;++k)</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][k]-(j-k)*ap[i]);<span class="comment">//买入</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="o-t∗maxp-算法（单调队列）"><a href="#o-t∗maxp-算法（单调队列）" class="headerlink" title="$o(t∗maxp)$算法（单调队列）"></a>$o(t∗maxp)$算法（单调队列）</h2><p>此题单调队列优化思想不难，但是还要注意各种细节。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2017</span>;</span><br><span class="line"><span class="keyword">int</span> n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;maxp,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,ap+i,bp+i,as+i,bs+i);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as[i];++j)    dp[i][j]=-ap[i]*j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)    dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)<span class="comment">//买入 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;<span class="built_in">max</span>(<span class="number">0</span>,j-as[i]))head++;</span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][q[head]]-(j-q[head])*ap[i]);</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i-w<span class="number">-1</span>][j]+j*ap[i]&gt;=dp[i-w<span class="number">-1</span>][q[tail]]+q[tail]*ap[i])tail--;</span><br><span class="line">                q[++tail]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=maxp;j&gt;=<span class="number">0</span>;--j)<span class="comment">//卖出 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&gt;<span class="built_in">min</span>(maxp,j+bs[i]))head++;</span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][q[head]]+(q[head]-j)*bp[i]);</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i-w<span class="number">-1</span>][j]+j*bp[i]&gt;=dp[i-w<span class="number">-1</span>][q[tail]]+q[tail]*bp[i])tail--;</span><br><span class="line">                q[++tail]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化 题目列表</title>
      <link href="/2017/03/10/dp-list/"/>
      <url>/2017/03/10/dp-list/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8/">原文</a>）</p></div><h1 id="单调队列优化dp"><a href="#单调队列优化dp" class="headerlink" title="单调队列优化dp"></a>单调队列优化dp</h1><p>BZOJ 1855、BZOJ 2442、BZOJ 2500、BZOJ 1047</p><h1 id="单调栈优化dp"><a href="#单调栈优化dp" class="headerlink" title="单调栈优化dp"></a>单调栈优化dp</h1><p>BZOJ 1057、BZOJ 1683、BZOJ 3956、BZOJ 3611</p><h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><p>BZOJ 1879、BZOJ 1087、BZOJ 2669、BZOJ 3812</p><h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675</p><h1 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h1><p>POJ1160 HDU2829 HDU3480 HDU3506 HDU3516</p><h1 id="斜率优化DP和四边形不等式优化DP题单整理"><a href="#斜率优化DP和四边形不等式优化DP题单整理" class="headerlink" title="斜率优化DP和四边形不等式优化DP题单整理"></a>斜率优化DP和四边形不等式优化DP题单整理</h1><p><a href="http://blog.csdn.net/shiwei408/article/details/8791011">http://blog.csdn.net/shiwei408/article/details/8791011</a></p><p><a href="http://blog.csdn.net/tomorrowtodie/article/details/52279807">http://blog.csdn.net/tomorrowtodie/article/details/52279807</a></p><p><a href="http://blog.csdn.net/u014800748/article/details/45750737">http://blog.csdn.net/u014800748/article/details/45750737</a></p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNOI2008 玩具装箱Toy（详解）</title>
      <link href="/2017/03/10/HNOI2008-toy/"/>
      <url>/2017/03/10/HNOI2008-toy/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/10/%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P3195">Luogu 3195</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/5sVo4uDBrpAwcMW.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>设$dp[i]$为处理前$i$个玩具的最小花费，$a[i]$为前$i$个玩具长度的前缀和。</p><p>易得转移方程为$dp[i]=min \lbrace  dp[j]+(i−j−1+a[i]−a[j]−l)^2 \rbrace (0 \leq i &lt; j \leq n)$</p><p>此方法时间复杂度为$O(n^2)$，只能水到20分。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,dp[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>+a[i]-a[j]-l)*(i-j<span class="number">-1</span>+a[i]-a[j]-l));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。</p><p>斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，一般可以通过决策表的方法进行验证，对于此题来说，数据容易生成，可以尝试一下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,dp[N],a[N],best[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>+a[i]-a[j]-l)*(i-j<span class="number">-1</span>+a[i]-a[j]-l))，best[i]=j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,best[i]);<span class="comment">//决策表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>易观察到$best[i]$单调不降，满足决策单调性。</p><p>证明见下：</p><p>对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有</p><p>$$dp[k]+(i−k−1+a[i]−a[k]−l)^2 &lt; dp[j]+(i−j−1+a[i]−a[j]−l)^2$$</p><p>$$dp[k]−dp[j] &lt; (i−j−1+a[i]−a[j]−l)^2−(i−k−1+a[i]−a[k]−l)^2$$</p><p>对于该方程，可设</p><p>$$b[i]=a[i]+i$$</p><p>$$l=l+1$$</p><p>则有</p><p>$$dp[k]−dp[j]&lt;(b[i]−b[j]−l)^2−(b[i]−b[k]−l)^2$$</p><p>化简得</p><p>$$((dp[k]+b[k]^2)−(dp[j]+b[j]^2))/(b[k]−b[j])&lt;2b[i]−2l$$</p><p>此时的形式为点斜式方程：</p><p>$$(yk−yj)/(xk−xj) &lt; ansi$$</p><p>已知$b[i]$为前缀和的形式，所以$b[i]$单调递增，可知斜率为单调递增。则适用决策单调性。</p><p>设</p><p>$$g[k,j]=(yk−yj)/(xk−xj)$$</p><p>则当且仅当$g[A1,A2] &lt; b[i]−2l$时，由$A1$转移而来优于$A2$。</p><p><strong>当$g[c,b] &lt; g[b,a]$时,易证得$b$必不为最优决策。</strong></p><p><strong>当$g[c,b] &lt; ansi$，此时$c$决策优于$b$，则$b$一定不为最优决策。</strong></p><p><strong>当$g[c,b]&gt;=ansi$，此时$b$决策优于$c$，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时$b$决策不优于$a$决策。</strong></p><p><strong>综上所述，则可将所有满足$g[c,b] &lt; g[b,a]$的决策$b$排除掉。此时函数满足上凸的性质，即有斜率递减。</strong></p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p><strong>以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：</strong></p><p><strong>1： 用单调队列维护点集信息。</strong></p><p><strong>2： 求解$dp[i]$，可以从队首开始扫描，当$g(head+1,head) &lt; ansi$时，可知$head+1$优于$head$，故继续扫描，直到不满足条件，此时$bext[i]=head$,即使$dp[i]$最优的决策为队首。</strong></p><p><strong>3： 当加入点$i$，我们要维护队列的上凸性质,即从队尾开始扫描，判断$g(i,tail)$是否小于$g(tail，tail-1)$，如果满足，则可删除$tail$，并继续扫描，直到不满足该条件，则$i$在此处入队，队列仍满足上凸性质。</strong></p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,a[N],b[N],dp[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">g</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k,<span class="keyword">long</span> <span class="keyword">long</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)b[i]=a[i]+i;</span><br><span class="line">    l++;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="built_in">g</span>(q[head+<span class="number">1</span>],q[head])&lt;<span class="number">2</span>*b[i]<span class="number">-2</span>*l)head++;</span><br><span class="line">        <span class="keyword">int</span> j=q[head];</span><br><span class="line">        dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="built_in">g</span>(i,q[tail])&lt;<span class="built_in">g</span>(q[tail],q[tail<span class="number">-1</span>]))tail--;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组十三题</title>
      <link href="/2017/03/08/Suffix-Array-13problems/"/>
      <url>/2017/03/08/Suffix-Array-13problems/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98/#more">原文</a>）</p></div><h1 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h1><p><a href="https://wenku.baidu.com/view/ed1be61e10a6f524ccbf85fd.html">后缀数组——处理字符串的有力工具–罗穗骞</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="POJ1743-Musical-Theme"><a href="#POJ1743-Musical-Theme" class="headerlink" title="POJ1743 Musical Theme"></a>POJ1743 Musical Theme</h2><p>本题题目描述与论文略有差别。</p><p>应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..））</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">1</span>,j=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>,maxsa=<span class="number">-1</span>,minsa=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(h[i]&lt;k)maxsa=<span class="number">-1</span>,minsa=inf;</span><br><span class="line">    <span class="keyword">if</span>(sa[i]&lt;minsa)minsa=sa[i];</span><br><span class="line">    <span class="keyword">if</span>(sa[i]&gt;maxsa)maxsa=sa[i];</span><br><span class="line">    <span class="keyword">if</span>(maxsa-minsa&gt;k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">break</span>;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    s[<span class="number">0</span>]=s[<span class="number">1</span>]-x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;++i)s[i]=s[i+<span class="number">1</span>]-s[i];</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)s[i]+=<span class="number">150</span>;</span><br><span class="line">    <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">getheight</span>(n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1e6</span>,ans;</span><br><span class="line">    <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">can</span>(ans,n))  l=ans;</span><br><span class="line">        <span class="keyword">else</span>      r=ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(l)&gt;=<span class="number">5</span>?l:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3261-Milk-Patterns"><a href="#POJ3261-Milk-Patterns" class="headerlink" title="POJ3261 Milk Patterns"></a>POJ3261 Milk Patterns</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];</span><br><span class="line"><span class="keyword">int</span> s[N],k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&lt;ans)tot=<span class="number">0</span>;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot==k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,s+i);</span><br><span class="line">    <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">getheight</span>(n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n+<span class="number">1</span>,ans,mid;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n))ans=l=mid;</span><br><span class="line">        <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ694-Distinct-Substrings"><a href="#SPOJ694-Distinct-Substrings" class="headerlink" title="SPOJ694 Distinct Substrings"></a>SPOJ694 Distinct Substrings</h2><p>这题论文中的方法不太好想，可以换一种思路。</p><p>易证长度为$len$的字符串一共有$(len+1)∗len/2$个子串。</p><p>而其中重复的字串个数则为height数组的总和，减去即可。</p><p>以这一组数据为例，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sa[i-1]  abba</span><br><span class="line">sa[i]    abcd //height[i] = 2</span><br></pre></td></tr></table></figure><p>两者相同的字串有$2∗(2+1)/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。</p><p>这个例子中只应减去$a,ab$这两个重复字符，之后必有两个后缀为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bba</span><br><span class="line">bcd //height = 1</span><br></pre></td></tr></table></figure><p>重复的子串$b$ 将在此处减掉。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e4</span>+<span class="number">5</span>;       </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;       </span><br><span class="line"><span class="keyword">char</span> s[N];   </span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],tong[N],wv[N];      </span><br><span class="line"><span class="keyword">int</span> rank[N],height[N];      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> t;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);  </span><br><span class="line">    <span class="keyword">while</span>(t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);  </span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);   </span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,<span class="number">128</span>);  </span><br><span class="line">        <span class="built_in">calheight</span>(n);  </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=n*(n+<span class="number">1</span>)/<span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        ans-=height[i];  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ705-不同的子串"><a href="#SPOJ705-不同的子串" class="headerlink" title="SPOJ705 不同的子串"></a>SPOJ705 不同的子串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,i=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line"><span class="built_in">getheight</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)sa[i]++;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans+=n-sa[i]-(i==<span class="number">1</span>?<span class="number">0</span>:h[i])+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URAL1297-Palindrome"><a href="#URAL1297-Palindrome" class="headerlink" title="URAL1297 Palindrome"></a>URAL1297 Palindrome</h2><p>这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tong[N],wv[N],wa[N],wb[N];</span><br><span class="line"><span class="keyword">int</span> rank1[N],height[N],sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=a[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)rank1[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank1[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank1[i]<span class="number">-1</span>];a[i+k]==a[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preRMQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">1</span>;i++)dp[i][<span class="number">0</span>]=height[i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=<span class="number">2</span>*n+<span class="number">1</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=<span class="number">2</span>*n+<span class="number">1</span>;i++)</span><br><span class="line">    dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=rank1[l],b=rank1[r];</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">int</span> t=(<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="built_in"><span class="keyword">double</span></span>(b-a+<span class="number">1</span>))/<span class="built_in">log</span>(<span class="number">2.00</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[a][t],dp[b-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,res,flag,max;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        max=<span class="number">0</span>;</span><br><span class="line">        n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)a[i]=(<span class="keyword">int</span>)s[i];</span><br><span class="line">        a[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)a[i+n+<span class="number">1</span>]=<span class="built_in"><span class="keyword">int</span></span>(s[n-i<span class="number">-1</span>]);</span><br><span class="line">        a[<span class="number">2</span>*n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(<span class="number">2</span>*n+<span class="number">2</span>,<span class="number">123</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">preRMQ</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">lcp</span>(i,<span class="number">2</span>*n-i)*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;res)max=res,flag=i;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res=<span class="built_in">lcp</span>(i,<span class="number">2</span>*n-i+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;res) max=res,flag=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max%<span class="number">2</span>==<span class="number">1</span>)<span class="keyword">for</span>(i=flag-max/<span class="number">2</span>;i&lt;=flag+max/<span class="number">2</span>;i++)   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(i=flag-max/<span class="number">2</span>;i&lt;=flag+max/<span class="number">2</span><span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ2406-Power-Strings"><a href="#POJ2406-Power-Strings" class="headerlink" title="POJ2406 Power Strings"></a>POJ2406 Power Strings</h2><p>本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个$logn$。</p><h2 id="POJ3693-Maximum-repetition-substring"><a href="#POJ3693-Maximum-repetition-substring" class="headerlink" title="POJ3693 Maximum repetition substring"></a>POJ3693 Maximum repetition substring</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];</span><br><span class="line"><span class="keyword">int</span> k,now,jj,maxr,cnt;</span><br><span class="line"><span class="keyword">int</span> d[N][<span class="number">21</span>],ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prermq</span><span class="params">(<span class="keyword">int</span>*a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)d[i][<span class="number">0</span>]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;++j)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;n;++i)</span><br><span class="line">d[i][j]=<span class="built_in">min</span>(d[i][j<span class="number">-1</span>],d[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">askrmq</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">l=rank[l],r=rank[r];</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="built_in">swap</span>(l,r);</span><br><span class="line">l++;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>))&lt;=r-l+<span class="number">1</span>)k++;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(d[l][k],d[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ccase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(tong,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tong));</span><br><span class="line"><span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">ccase++;</span><br><span class="line">k=now=jj=maxr=cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line"><span class="built_in">getheight</span>(n);</span><br><span class="line"><span class="built_in">prermq</span>(h,n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;n;j+=i) </span><br><span class="line">&#123;</span><br><span class="line">k=<span class="built_in">askrmq</span>(j,j+i);</span><br><span class="line">now=k/i+<span class="number">1</span>;</span><br><span class="line">jj=j-(i-k%i);</span><br><span class="line"><span class="keyword">if</span> (jj&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">askrmq</span>(jj,jj+i)&gt;=(i-k%i))++now;</span><br><span class="line"><span class="keyword">if</span>(now&gt;maxr)    &#123;cnt=<span class="number">0</span>;maxr=now;ans[cnt++]=i;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(now==maxr)  ans[cnt++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">askrmq</span>(sa[i],sa[i]+ans[j])&gt;=(maxr<span class="number">-1</span>)*ans[j])</span><br><span class="line">&#123;</span><br><span class="line">    jj=sa[i],k=ans[j];</span><br><span class="line">    <span class="keyword">goto</span> dd;</span><br><span class="line">&#125;</span><br><span class="line">dd:;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,ccase);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxr*k;++i)<span class="built_in">putchar</span>(s[jj++]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ687-重复的字符串"><a href="#SPOJ687-重复的字符串" class="headerlink" title="SPOJ687 重复的字符串"></a>SPOJ687 重复的字符串</h2><p>暂略。</p><h2 id="POJ2774-Long-Long-Message"><a href="#POJ2774-Long-Long-Message" class="headerlink" title="POJ2774 Long Long Message"></a>POJ2774 Long Long Message</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],wv[N],tong[maxf+<span class="number">1</span>],rank[N],h[N];</span><br><span class="line"><span class="keyword">char</span> s[N],ss[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;m=p,j&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,i=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;longlongmessage.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;longlongmessage.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),m=<span class="built_in">strlen</span>(ss);</span><br><span class="line">    s[n]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+m;++i)s[i]=ss[i-n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> l=n+m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">da</span>(l+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">geth</span>(l);</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=l;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i<span class="number">-1</span>]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i<span class="number">-1</span>]&lt;n)))</span><br><span class="line">        maxx=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3415-Common-Substrings"><a href="#POJ3415-Common-Substrings" class="headerlink" title="POJ3415 Common Substrings"></a>POJ3415 Common Substrings</h2><p>暂略。</p><h2 id="POJ3294-生命形态"><a href="#POJ3294-生命形态" class="headerlink" title="POJ3294 生命形态"></a>POJ3294 生命形态</h2><p>本题和上题都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">111</span>][<span class="number">10001</span>],s[N];</span><br><span class="line"><span class="keyword">int</span> nn[<span class="number">111</span>],tt;</span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">111</span>];</span><br><span class="line"><span class="keyword">int</span> ll[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,p=<span class="number">1</span>,<span class="built_in">swap</span>(x,y),x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(j=sa[rank[i]<span class="number">-1</span>],k?k--:<span class="number">0</span>;s[j+k]==s[i+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> ansg;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tot1=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));  tot1=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nowq,nowt;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])nowt=t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;</span><br><span class="line">                <span class="keyword">if</span>(!inq[nowq])tot1++,inq[nowq]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!inq[nowt])tot1++,inq[nowt]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot1&gt;=k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> lll=inf,rrr=<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> tot1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));  tot1=<span class="number">0</span>;</span><br><span class="line">              lll=inf;rrr=<span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">int</span> nowq,nowt;</span><br><span class="line">              <span class="keyword">if</span>(sa[i<span class="number">-1</span>]&lt;lll)lll=sa[i<span class="number">-1</span>];<span class="keyword">if</span>(sa[i<span class="number">-1</span>]&gt;rrr)rrr=sa[i<span class="number">-1</span>];</span><br><span class="line">              <span class="keyword">if</span>(sa[i]&lt;lll)lll=sa[i];<span class="keyword">if</span>(sa[i]&gt;rrr)rrr=sa[i];</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])nowt=t;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;</span><br><span class="line">              <span class="keyword">if</span>(!inq[nowq])tot1++,inq[nowq]=<span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span>(!inq[nowt])tot1++,inq[nowt]=<span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span>(tot1==k)ll[++ansg]=lll;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tt)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(wa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wa));</span><br><span class="line">        <span class="built_in">memset</span>(wb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wb));</span><br><span class="line">        <span class="built_in">memset</span>(wv,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wv));</span><br><span class="line">        <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">        <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">memset</span>(nn,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nn));</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">2</span>;</span><br><span class="line">        ansg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss[i]);</span><br><span class="line">            nn[i]=<span class="built_in">strlen</span>(ss[i]);</span><br><span class="line">            nn[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;nn[i];++t)s[tot++]=ss[i][t];</span><br><span class="line">            nn[i]+=nn[i<span class="number">-1</span>]+(i==tt?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i!=tt)s[tot++]=tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        nn[tt]++;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">        <span class="built_in">geth</span>(n);</span><br><span class="line">        k=(tt)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n+<span class="number">1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n,<span class="number">0</span>))  l=mid;</span><br><span class="line">            <span class="keyword">else</span>      r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);<span class="keyword">goto</span> dd;&#125;</span><br><span class="line">        <span class="built_in">can</span>(l,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansg;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;l;++t)<span class="keyword">if</span>(s[ll[i]+t]!=s[ll[i<span class="number">-1</span>]+t])&#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=ll[i];t&lt;=ll[i]+l<span class="number">-1</span>;++t)<span class="built_in">putchar</span>(s[t]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dd:;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ220-破译进攻计划"><a href="#SPOJ220-破译进攻计划" class="headerlink" title="SPOJ220 破译进攻计划"></a>SPOJ220 破译进攻计划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];</span><br><span class="line"><span class="keyword">char</span> s[N],ss[<span class="number">13</span>][<span class="number">15031</span>];</span><br><span class="line"><span class="keyword">int</span> inq[<span class="number">13</span>],maxq[<span class="number">13</span>],minq[<span class="number">13</span>];</span><br><span class="line"><span class="keyword">int</span> tt,num;</span><br><span class="line"><span class="keyword">bool</span> use[<span class="number">13</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>,p=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            tot=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">            <span class="built_in">memset</span>(maxq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maxq));</span><br><span class="line">            <span class="built_in">memset</span>(minq,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(minq));</span><br><span class="line">            <span class="built_in">memset</span>(use,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(use));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=num;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t])</span><br><span class="line">            &#123;</span><br><span class="line">                inq[t]++;</span><br><span class="line">                minq[t]=<span class="built_in">min</span>(minq[t],sa[i]);</span><br><span class="line">                maxq[t]=<span class="built_in">max</span>(maxq[t],sa[i]);</span><br><span class="line">                <span class="keyword">if</span>(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot==num)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=num;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])</span><br><span class="line">            &#123;</span><br><span class="line">                inq[t]++;</span><br><span class="line">                minq[t]=<span class="built_in">min</span>(minq[t],sa[i<span class="number">-1</span>]);</span><br><span class="line">                maxq[t]=<span class="built_in">max</span>(maxq[t],sa[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot==num)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    nn[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">        <span class="built_in">memset</span>(wa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wa));</span><br><span class="line">        <span class="built_in">memset</span>(wb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wb));</span><br><span class="line">        <span class="built_in">memset</span>(wv,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wv));</span><br><span class="line">        <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>,qiguaizifu=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss[i]);</span><br><span class="line">            nn[i]=<span class="built_in">strlen</span>(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;nn[i];++t)</span><br><span class="line">            s[tot++]=ss[i][t];</span><br><span class="line">            s[tot++]=qiguaizifu++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)nn[i]+=(nn[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">        <span class="built_in">geth</span>(n);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n))  l=mid;</span><br><span class="line">            <span class="keyword">else</span>      r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ1226-Substrings"><a href="#POJ1226-Substrings" class="headerlink" title="POJ1226 Substrings"></a>POJ1226 Substrings</h2><p>暂略。</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Chinese </tag>
            
            <tag> String Manipulation </tag>
            
            <tag> Suffix Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ Coding Style</title>
      <link href="/2017/03/07/C-C++-Coding-Style/"/>
      <url>/2017/03/07/C-C++-Coding-Style/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/07/c++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">原文</a>）</p></div><p>C/C++代码规范。包括命名规则，排版规则，文档及注释，编码要求等等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://www.ipicbed.com/images/2022/01/08/C-CodingStyle.png" alt="C/C++ Google Coding Style"></p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="起个合适的名字"><a href="#起个合适的名字" class="headerlink" title="起个合适的名字"></a>起个合适的名字</h2><h3 id="类的名称"><a href="#类的名称" class="headerlink" title="类的名称"></a>类的名称</h3><p>类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p><p>类的名字不需要告诉我们，它从哪个类继承而来的。</p><p>有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p><h3 id="方法和函数的名称"><a href="#方法和函数的名称" class="headerlink" title="方法和函数的名称"></a>方法和函数的名称</h3><p>方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p><p>函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p><p>可以加一些必要的后缀：</p><p>Max – 表示取最大值。</p><p>Cnt – 表示当前的计数值。</p><p>Key – 表示键值。</p><p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p><p>前缀也同样有用：</p><p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p><p>Get – 用于获取一个值。</p><p>Set – 用于设置一个值。</p><p>例如：IsHitRetryLimit。</p><h3 id="含有度量单位的名称"><a href="#含有度量单位的名称" class="headerlink" title="含有度量单位的名称"></a>含有度量单位的名称</h3><p>如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint32 mTimeoutMsecs;</span><br><span class="line">uint32 mMyWeightLbs;</span><br></pre></td></tr></table></figure><h3 id="缩写名称不要全部大写"><a href="#缩写名称不要全部大写" class="headerlink" title="缩写名称不要全部大写"></a>缩写名称不要全部大写</h3><p>无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FluidOz</span>;</span>            <span class="comment">// 而不是 FluidOZ</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkAbcKey</span>;</span>      <span class="comment">// 而不是 NetworkABCKey</span></span><br></pre></td></tr></table></figure><h2 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h2><p>用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p><p>名字的第一个字母应大写。</p><p>不含有下划线。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>;</span></span><br></pre></td></tr></table></figure><h2 id="类库或程序库命名"><a href="#类库或程序库命名" class="headerlink" title="类库或程序库命名"></a>类库或程序库命名</h2><p>使用命名空间防止名字冲突。</p><p>如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p><p>例如：（Tong Su 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TsLinkList</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数的命名"><a href="#方法和函数的命名" class="headerlink" title="方法和函数的命名"></a>方法和函数的命名</h2><p>使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoIt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类属性的命名"><a href="#类属性的命名" class="headerlink" title="类属性的命名"></a>类属性的命名</h2><p>属性（通常是非公有数据成员）名字以字母’m’开头。</p><p>在 ‘m(m_)’ 后面，使用与类名相同的规则。</p><p>‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">VarAbc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ErrorNumber</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mVarAbc;</span><br><span class="line"><span class="keyword">int</span> mErrorNumber;</span><br><span class="line">String* mpName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数参数的命名"><a href="#方法和函数参数的命名" class="headerlink" title="方法和函数参数的命名"></a>方法和函数参数的命名</h2><p>第一个字母必须小写。</p><p>第一个字母后面的单词使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StartYourEngines</span><span class="params">(Engine&amp;rSomeEngine,Engine&amp;rAnotherEngine)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量的命名"><a href="#局部变量的命名" class="headerlink" title="局部变量的命名"></a>局部变量的命名</h2><p>所有字母都用小写。</p><p>使用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NameOneTwo::HandleError</span><span class="params">(<span class="keyword">int</span> errorNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error= <span class="built_in">OsErr</span>();</span><br><span class="line">Time time_of_error;</span><br><span class="line">ErrorProcessor error_processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针变量的命名前缀"><a href="#指针变量的命名前缀" class="headerlink" title="指针变量的命名前缀"></a>指针变量的命名前缀</h2><p>指针变量多数情况应在前面加 ‘p’。</p><p>星号应靠近类型，而不是变量名。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String* pName=<span class="keyword">new</span> String;</span><br></pre></td></tr></table></figure><p>特别的：String* pName, name; 应分成两行来写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String* pName;</span><br><span class="line">String  name;</span><br></pre></td></tr></table></figure><h2 id="引用变量和返回引用函数的命名前缀"><a href="#引用变量和返回引用函数的命名前缀" class="headerlink" title="引用变量和返回引用函数的命名前缀"></a>引用变量和返回引用函数的命名前缀</h2><p>引用必须用‘r’作前缀修饰。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(StatusInfo&amp;rStatus)</span></span>;</span><br><span class="line"><span class="function">StatusInfo&amp; <span class="title">rStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">constStatusInfo&amp; <span class="title">Status</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 这里返回的是常量引用，所以不符合本规则</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StatusInfo&amp; mrStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局变量的命名前缀"><a href="#全局变量的命名前缀" class="headerlink" title="全局变量的命名前缀"></a>全局变量的命名前缀</h2><p>全局变量总是以 ‘g(g_)’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger g_Log;</span><br><span class="line">Logger* g_pLog;</span><br></pre></td></tr></table></figure><h2 id="全局常量的命名"><a href="#全局常量的命名" class="headerlink" title="全局常量的命名"></a>全局常量的命名</h2><p>全局常量全部大写，并以下划线分隔单词。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intA_GLOBAL_CONSTANT = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="静态变量的命名前缀"><a href="#静态变量的命名前缀" class="headerlink" title="静态变量的命名前缀"></a>静态变量的命名前缀</h2><p>静态变量以 ‘s’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">staticStatusInfo m_sStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类型typedef的命名"><a href="#自定义类型typedef的命名" class="headerlink" title="自定义类型typedef的命名"></a>自定义类型typedef的命名</h2><p>类型定义名称指的是用typedef定义的名称。</p><p>类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint16  ModuleType;</span><br><span class="line"><span class="keyword">typedef</span> uint32  SystemType;</span><br></pre></td></tr></table></figure><h2 id="宏定义的命名"><a href="#宏定义的命名" class="headerlink" title="宏定义的命名"></a>宏定义的命名</h2><p>所有单词的字母都用大写，并使用下划线分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) blah</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ERR(err) blah</span></span><br></pre></td></tr></table></figure><h2 id="C-函数的命名"><a href="#C-函数的命名" class="headerlink" title="C 函数的命名"></a>C 函数的命名</h2><p>C++项目中，应尽量少用C函数。</p><p>C函数使用GNU规范，所有字母都使用小写，并用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，为了兼容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” <span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>或在C/C++中推荐使用下面的格式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#ifdef__cplusplus__</span><br><span class="line"><span class="keyword">extern</span> “C”&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">#ifdef__cplusplus__</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="枚举的命名"><a href="#枚举的命名" class="headerlink" title="枚举的命名"></a>枚举的命名</h2><p>所有字母都大写，并用下划线作为单词分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">enumPinStateType&#123;</span><br><span class="line">PIN_OFF,</span><br><span class="line">PIN_ON;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>STATE_ERR,STATE_OPEN,STATE_RUNNING,STATE_DYING&#125;;</span><br></pre></td></tr></table></figure><h1 id="排版规则"><a href="#排版规则" class="headerlink" title="排版规则"></a>排版规则</h1><h2 id="布局和模板"><a href="#布局和模板" class="headerlink" title="布局和模板"></a>布局和模板</h2><h3 id="类的布局模板"><a href="#类的布局模板" class="headerlink" title="类的布局模板"></a>类的布局模板</h3><p>请使用下面的模板来创建一个新的类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment"> * 用一行来描述类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *#include &quot;XX.h&quot; &lt;BR&gt;</span></span><br><span class="line"><span class="comment"> *-llib</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类的详细说明</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @seesomething</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="comment">// 在这里包含系统头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含项目头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含局部头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置前置引用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XX</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 类的生命周期控制函数，如构造和析构，以及状态机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***Default constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">/***Copy constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">const</span> XX&amp; from);</span><br><span class="line"><span class="comment">/***Destructor.*/</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 在这里放置类的运算操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Assignment operator.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@param from THe value to assign to this object.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@return A reference to this object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">XX&amp; <span class="keyword">operator</span>=(XX&amp;from); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的操作                      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置属性存取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的状态查询</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 内联方法定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>定义的顺序是: public, protected, private。</p><p>要清楚public/protected/private都应该放置哪些东西。</p><h3 id="保护头文件不被重复包含"><a href="#保护头文件不被重复包含" class="headerlink" title="保护头文件不被重复包含"></a>保护头文件不被重复包含</h3><p>应使用宏定义来保护头文件不被重复包含：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>如果使用命名空间的时候，要把命名空间加到文件名前面：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="方法和函数的布局"><a href="#方法和函数的布局" class="headerlink" title="方法和函数的布局"></a>方法和函数的布局</h3><p>对于有较多参数的函数的写法。</p><p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg1, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg2,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg4)</span></span>; </span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(<span class="keyword">int</span> arg1 </span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg2</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg3</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg4)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="尽量使一行不要超过78个字母"><a href="#尽量使一行不要超过78个字母" class="headerlink" title="尽量使一行不要超过78个字母"></a>尽量使一行不要超过78个字母</h2><p>有许多编辑器屏幕只有78个字母宽。</p><h2 id="保证一行只写一条语句"><a href="#保证一行只写一条语句" class="headerlink" title="保证一行只写一条语句"></a>保证一行只写一条语句</h2><p>一行最多只写一条语句。</p><p>一行只定义一个变量。</p><h2 id="圆括号规则"><a href="#圆括号规则" class="headerlink" title="圆括号规则"></a>圆括号规则</h2><p>圆括号与关键字之间应放一个空格。</p><p>圆括号与函数名之间不要有空格。</p><p>Return 语句不要使用圆括号。</p><h2 id="使用goto-continue-break-和"><a href="#使用goto-continue-break-和" class="headerlink" title="使用goto continue break 和?:"></a>使用goto continue break 和?:</h2><h3 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h3><p>尽量避免使用Goto 语句。</p><h3 id="Continue-and-Break"><a href="#Continue-and-Break" class="headerlink" title="Continue and Break"></a>Continue and Break</h3><p>Continue和break实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p><h3 id="A-B-C"><a href="#A-B-C" class="headerlink" title="A?B:C"></a>A?B:C</h3><p>用括号把条件表达式括起来。</p><p>不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p><p>操作语句应分行写，除非它们能够简洁的放在一行当中。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(condition) ?<span class="built_in">funct1</span>() : <span class="built_in">func2</span>();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(condition)</span><br><span class="line">? longstatement</span><br><span class="line">: anotherlong statement;</span><br></pre></td></tr></table></figure><h2 id="运算符号的规则"><a href="#运算符号的规则" class="headerlink" title="运算符号的规则"></a>运算符号的规则</h2><p>一元操作符如（!、~ 等等）应贴近操作对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IsOk)</span><br><span class="line">    <span class="keyword">return</span> ++v;</span><br></pre></td></tr></table></figure><p>二元操作符如（+、%、== 等等）应在前后留空格。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 == v2)</span><br><span class="line">     <span class="keyword">return</span> v1 * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。</p><h2 id="变量声明语句块"><a href="#变量声明语句块" class="headerlink" title="变量声明语句块"></a>变量声明语句块</h2><p>变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。</p><p>声明语句块必须要对齐。类型，变量，等号和初始化值要分别对齐。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DWORD      mDword;</span><br><span class="line">DWORD*     mpDword;</span><br><span class="line"><span class="keyword">char</span>*      mpChar;</span><br><span class="line"><span class="keyword">char</span>       mChar;</span><br><span class="line"></span><br><span class="line">mDword     =    <span class="number">0</span>;</span><br><span class="line">mpDword    =    <span class="literal">NULL</span>;</span><br><span class="line">mpChar     =    <span class="literal">NULL</span>;</span><br><span class="line">mChar      =    <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="文档及注释"><a href="#文档及注释" class="headerlink" title="文档及注释"></a>文档及注释</h1><p>应当使用文档自动生成工具，来生成相关的程序文档。</p><h2 id="文件或程序库的文档注释"><a href="#文件或程序库的文档注释" class="headerlink" title="文件或程序库的文档注释"></a>文件或程序库的文档注释</h2><p>可以为整个文件编写文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @file file.h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Abrief file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Amore elaborated file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="类文档注释"><a href="#类文档注释" class="headerlink" title="类文档注释"></a>类文档注释</h2><p>在类定义前面应加上类说明文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** WindowsNT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @brief Windows Nice Try.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Bill Gates</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Several species of small furryanimals gathered together</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *          in a cave and grooving with a pict.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @version 4.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @date   1996-1998</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug It crashes a lot and requires hugeamounts of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug The class introduces the more bugs, thelonger it is used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning This class may explode in your face.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning If you inherit anything from thisclass, you&#x27;re doomed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsNT</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数文档注释"><a href="#函数文档注释" class="headerlink" title="函数文档注释"></a>函数文档注释</h2><p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 赋值操作符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param val 将要赋给本对象的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return 本对象的引用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">XX&amp;  <span class="keyword">operator</span> =(XX&amp; val);</span><br></pre></td></tr></table></figure><p>注释属性</p><p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p><p>n 前提条件 (pre)<br>定义调用这个函数的前提条件</p><p>n 警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p><p>n 备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p><p>n 将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成。</p><p>n 使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 复制一个字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@pre</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(from != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(to != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@warning</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 缓冲区必需足够大，以便容纳的下要拷贝的字串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@example teststrcpy.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param from 要拷贝的字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param to 用于容纳字串的缓冲区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return void</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">strcpy</span><span class="params">(constchar* from, <span class="keyword">char</span>* to)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Include-语句注释"><a href="#Include-语句注释" class="headerlink" title="Include 语句注释"></a>Include 语句注释</h2><p>如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p><h2 id="语句块注释"><a href="#语句块注释" class="headerlink" title="语句块注释"></a>语句块注释</h2><p>语句块的注释可以用在语句块的开头和结束位置：</p><h1 id="编码要求"><a href="#编码要求" class="headerlink" title="编码要求"></a>编码要求</h1><h2 id="不要忽略编译器的警告"><a href="#不要忽略编译器的警告" class="headerlink" title="不要忽略编译器的警告"></a>不要忽略编译器的警告</h2><p>编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p><h2 id="应使用源代码管理器"><a href="#应使用源代码管理器" class="headerlink" title="应使用源代码管理器"></a>应使用源代码管理器</h2><p>根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p><h2 id="固有的类方法成员"><a href="#固有的类方法成员" class="headerlink" title="固有的类方法成员"></a>固有的类方法成员</h2><p>默认构造函数(DefaultConstructor)</p><p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p><p>虚析构函数(Virtual Destructor)</p><p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p><p>拷贝构造函数(Copy Constructor)</p><p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p><p>赋值操作(AssignmentOperator)</p><p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p><h2 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h2><p>根名字一般是设计者的名字。比如公司名称等等。</p><p>不要在全局空间使用using语句。</p><h2 id="初始化所有的变量"><a href="#初始化所有的变量" class="headerlink" title="初始化所有的变量"></a>初始化所有的变量</h2><p>无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p><h2 id="保持函数短小精悍"><a href="#保持函数短小精悍" class="headerlink" title="保持函数短小精悍"></a>保持函数短小精悍</h2><p>一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p><h2 id="对空语句进行注释"><a href="#对空语句进行注释" class="headerlink" title="对空语句进行注释"></a>对空语句进行注释</h2><p>For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(*dest++ = *srC++)</span><br><span class="line">   ;<span class="comment">// VOID</span></span><br></pre></td></tr></table></figure><h2 id="不要用if语句的默认方法测试非零值"><a href="#不要用if语句的默认方法测试非零值" class="headerlink" title="不要用if语句的默认方法测试非零值"></a>不要用if语句的默认方法测试非零值</h2><p>If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值。</p><p>建议使用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>() != FAIL)</span><br></pre></td></tr></table></figure><p>不建议使用下面的表达式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>())</span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p><h2 id="避免在语句中内含赋值"><a href="#避免在语句中内含赋值" class="headerlink" title="避免在语句中内含赋值"></a>避免在语句中内含赋值</h2><p>只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (EOF != (c= <span class="built_in">getchar</span>()))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确的使用Const"><a href="#正确的使用Const" class="headerlink" title="正确的使用Const"></a>正确的使用Const</h2><p>C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p><h2 id="不要在头文件定义数据"><a href="#不要在头文件定义数据" class="headerlink" title="不要在头文件定义数据"></a>不要在头文件定义数据</h2><p>不要把数据定义放在头文件。</p><h2 id="不要直接使用数字"><a href="#不要直接使用数字" class="headerlink" title="不要直接使用数字"></a>不要直接使用数字</h2><p>直接使用数字，会使源代码难以理解和维护。我们可以用#define或者常量来改变这一状况。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>如果可以，使用内联函数代替宏。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    <span class="comment">// 取最大数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>使用内联函数可以达到相同的效果，而且更安全：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt; y ? x : y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x + y</span></span><br></pre></td></tr></table></figure><p>必须写成：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure><p>和全局变量一样，宏也会与其它名称产生冲突。</p><p>下面两条规则有助于解决这个问题：</p><p>一、在宏名称前加上库的名字</p><p>二、避免使用简单而常用的名字，如：MAX和MIN。</p>]]></content>
      
      
      <categories>
          
          <category> Coding Itself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Coding Style </tag>
            
            <tag> Chinese </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
