<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>政治性抑郁，失范性自杀</title>
      <link href="/2022/08/23/2020-08-31-suicide/"/>
      <url>/2022/08/23/2020-08-31-suicide/</url>
      
        <content type="html"><![CDATA[<p>“一个人的精神是否健康，从根本上讲，并不是个人的事，而是取决于他所处的社会的结构。” ———— 《健全的社会》</p><p>本文为转载，原作者为于 2020 年 08 月 31 日选择结束自己生命的一名南京航空航天大学学生。</p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>很抱歉大家，突然就要说告别了。在大家看到这条定时说说的时候，我已经于宿舍九楼活动室自杀，在＠到的人当中，烦请其中的亲戚告知我的父母。我的空间有一条写给母亲的遗书，仅对她可见，请务必吩咐她看一看。</p><p>疫情以来在家里沉下来考虑了很久，终究是做出了这个决定。想写下一些最后的心思，却不知为谁去写，教谁来听。纯当一个可怜人的叨叨自语，姑妄听之吧。</p><p>很多年来自己一直强装正常，其实心早已如死灰槁木，人似行尸走肉。强装的总归是不自然，相信身边很多人都能或多或少察觉到我的异处。</p><p>我一直是个很极端的理想主义者，对人和社会常常有极大的洁癖。在资本盛行的年代，所有的美丽成为利己的粉饰，所有的资源成为剥削的剃刀。人们有的被生计就已经折磨得不成样，有的为了单薄的体面如履薄冰。多数人都无法获得自由与尊严，混沌一生，终是个悲剧；而剩下的却也不得不精明地吸血，时而卑鄙折节。上寻下索，都是一张张冷血的脸，精致地把弱肉强食奉为圣经。人与人之间，多的是相互计算与榨取，灯火辉煌的世界为一片空前残忍，杀人不见血的丛林。在这世界，看到的不是一个个人，而是一串串衡量价值的数字。价值，也多逃不开掌权者的需求，躲不过资本的青睐。几年前我就开始想，为了加大自己的数字而去成为一个奴隶究竟有什么意义。想想自己的未来，靠一门自身无感的知识谋求生计，为立足去接受自己所抗拒的规则，去逢迎不喜欢的人们，去站到自己的对立面，拿着那些扭曲的价值又该货与何处，换得何物？在这种环境下，我曾经选择过得很犬儒，不管遇到什么，都会先想起戴奥真尼斯那句“你挡住了我的太阳”。可是犬儒终究是一种逃避，我只是一个被当下环境塑造的普通人，到底还是无法超脱于社会。在另一个极端，也曾想过做一个像岳昕，沈梦雨，顾佳悦，张云帆那样逆流而上的人，奈何力有所不及，智有所不能，意有所不坚。在荆棘丛中自处已是不易，遑论杀出一条血路来。火焰燃烧得越旺盛，熄灭后的灰烬却也越多。对周遭已无渴求，继续下去又是为了什么呢？当拒绝妥协却又难以改变的时候，便用血写下最后一首耻辱的诗。</p><p>并不想为自己的行为做什么辩解，讨论什么对错，这只是一份自白，试图寻求些许理解。或许有一千个不应如此的理由，可世事又何曾在每一个具体的人身上都按照理想的大道理运行呢？这个世界或许还有许多美丽未曾经历，许多未知值得探索，可都被当下持续的痛苦所击溃。纵使千不该万不该，作为一个自私的病人，并不打算遵守亲朋对其亲朋，社会对其成员的期许与规范，亦不想为了飘渺的希望继续忍受可预见的苦难。</p><p>突然想到一句咏叹调，remember me，but forget my fate，很美好，却是无法兼得的，那便请彻底忘了我，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Read Think Write </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年08月17日 书单</title>
      <link href="/2022/08/17/2022-08-17-book-list/"/>
      <url>/2022/08/17/2022-08-17-book-list/</url>
      
        <content type="html"><![CDATA[<p>“加缪给了我们答案，作为一个成年人，或者说对付，或者说忍受，或者说享受（反正本质上都是一回事）这个世界的态度，就是置身事外，自得其乐。用无所事事，用有节制的爱，用适可而止的绝望。这是一种乐观的悲观主义，一种积极的消极，一种无力的力量。” ———— 《村上春树教会了我们》</p><p>局外人 加缪（柳鸣九译）</p><p>鼠疫 加缪（刘方译）</p><p>西西弗神话 加缪（沈志明译）</p><p>我是猫 夏目漱石（焦海利译）</p><p>心 夏目漱石（林少华译）</p><p>三四郎 夏目漱石（竺家荣译）</p><p>从此以后 夏目漱石（竺家荣译）</p><p>门 夏目漱石（竺家荣译）</p><p>斜阳 太宰治（钟甘英译）</p><p>人间失格 太宰治（葛青译）</p><p>女生徒 太宰治（陆求实译）</p><p>飞鸟集 泰戈尔（王钦刚译）</p><p>新月集 泰戈尔（王钦刚译）</p><p>流萤集 泰戈尔（王钦刚译）</p><p>挪威的森林 村上春树（林少华译）</p><p>国富论 亚当斯密（高格译）</p><p>狂人日记 鲁迅</p><p>雪国 川端康成（叶渭渠，唐月梅译）</p><p>志摩的诗（徐志摩诗歌精选集） 徐志摩</p><p>了不起的盖茨比 菲茨杰拉德（陈伯雨译）</p><p>老舍经典作品集（茶馆，龙须沟，西望长安，全家福） 老舍</p><p>边城 沈从文</p><p>罗生门 芥川龙之介（焦海利译）</p><p>月亮与六便士 毛姆（焦海利译）</p><p>瓦尔登湖 梭罗（高格译）</p>]]></content>
      
      
      <categories>
          
          <category> Read Think Write </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Book List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 15-卷积神经网络</title>
      <link href="/2022/08/06/d2l-15/"/>
      <url>/2022/08/06/d2l-15/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/06/iHGsMt27VJlDPCR.png" alt="15-卷积神经网络.png"></p><p><img src="https://s2.loli.net/2022/08/06/fjLu9A8nDQtX6CS.png" alt="15-卷积神经网络-1.png"></p><p>原本权重为二维，输入输出为一维向量，可以理解为从输入和输出分别选一个包含节点。</p><p>现在权重变为四维，输入输出为二维矩阵，可以理解为从输入和输出分别选一个包含宽高的节点。</p><p><img src="https://s2.loli.net/2022/08/06/qejW4Z3IfYVu6LP.png" alt="15-卷积神经网络-2.png"></p><p><img src="https://s2.loli.net/2022/08/06/nWatmZLbhCKGcDx.png" alt="15-卷积神经网络-3.png"></p><p><img src="https://s2.loli.net/2022/08/06/WifDsZNzjJR9rIg.png" alt="15-卷积神经网络-4.png"></p><p>交叉相关和卷积本质一样，只差了个负号。</p><p><img src="https://s2.loli.net/2022/08/06/QJjRIXcZKGgAfFz.png" alt="15-卷积神经网络-5.png"></p><p><img src="https://s2.loli.net/2022/08/06/MaSUECqvXen8WRh.png" alt="15-卷积神经网络-6.png"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 8-使用GPU进行深度学习</title>
      <link href="/2022/08/05/d2l-8/"/>
      <url>/2022/08/05/d2l-8/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/05/2HMljK7AhrxvVZz.png" alt="8-使用GPU进行深度学习.png"></p><p><img src="https://s2.loli.net/2022/08/05/hLbxDdBpa7lFoRP.png" alt="8-使用GPU进行深度学习-1.png"></p><p><img src="https://s2.loli.net/2022/08/05/6Ts2xS1ivnp5lkX.png" alt="8-使用GPU进行深度学习-2.png"></p><p><img src="https://s2.loli.net/2022/08/05/74lSFfGxELdymiU.png" alt="8-使用GPU进行深度学习-3.png"></p><p><img src="https://s2.loli.net/2022/08/05/G1WyO86TEYdRD9w.png" alt="8-使用GPU进行深度学习-4.png"></p><p><img src="https://s2.loli.net/2022/08/05/YxhzW2Ovnol1buF.png" alt="8-使用GPU进行深度学习-5.png"></p><p><img src="https://s2.loli.net/2022/08/05/GaYm1jtuy5H2IvU.png" alt="8-使用GPU进行深度学习-6.png"></p><p>这一章比较实用，所以截了一些代码的截图。</p><p>图中的方法不仅能用来加速深度学习，同样能显著提升运用 python 进行其他数据科学运算的速度。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 7-深度学习硬件CPU与GPU</title>
      <link href="/2022/08/05/d2l-7/"/>
      <url>/2022/08/05/d2l-7/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/05/nKZf3OogqCs4M6x.png" alt="7-深度学习硬件CPU与GPU.png"></p><p><img src="https://s2.loli.net/2022/08/05/odpVEwLQX6A2b4g.png" alt="7-深度学习硬件CPU与GPU-1.png"></p><p><img src="https://s2.loli.net/2022/08/05/wa2lFU7TnoKp1DG.png" alt="7-深度学习硬件CPU与GPU-2.png"></p><p><img src="https://s2.loli.net/2022/08/05/HYKBXbLPoy2R5gF.png" alt="7-深度学习硬件CPU与GPU-3.png"></p><p><img src="https://s2.loli.net/2022/08/05/HCWSjABP3RUy2V4.png" alt="7-深度学习硬件CPU与GPU-4.png"></p><p><img src="https://s2.loli.net/2022/08/05/iRaQ1jUw3ndMksF.png" alt="7-深度学习硬件CPU与GPU-5.png"></p><p><img src="https://s2.loli.net/2022/08/05/RS4xdEU7XZlqYcO.png" alt="7-深度学习硬件CPU与GPU-6.png"></p><p><img src="https://s2.loli.net/2022/08/05/r5ly9O7hUpmEzwJ.png" alt="7-深度学习硬件CPU与GPU-7.png"></p><p><img src="https://s2.loli.net/2022/08/05/vzOBZ4PRQUEwC3H.png" alt="7-深度学习硬件CPU与GPU-8.png"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 6-损失函数</title>
      <link href="/2022/08/04/d2l-6/"/>
      <url>/2022/08/04/d2l-6/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/04/rViwjz5pkYnPX23.png" alt="6-损失函数.png"></p><p>L2 Loss 优势在于离最优点越近，梯度越小，起到微调的效果，且使得损失函数收敛。劣势在于当离最优点过远时，梯度可能会过于大，导致在最优点的两侧反复横跳，收敛过慢。</p><p><img src="https://s2.loli.net/2022/08/04/zRCu7tmnBMsvVqD.png" alt="6-损失函数-1.png"></p><p>L2 Loss 优势在于离最优点过远时，梯度不会特别大。劣势在于当离最优点过近时，无法进一步逼近，无法收敛。</p><p><img src="https://s2.loli.net/2022/08/04/pcEmSzlw4BP293W.png" alt="6-损失函数-2.png"></p><p>可以看到 L1 Loss 和 L2 Loss 的优势是互补的，因此有 Huber’s Robust Loss 在离最优点近时采用 L2，在离最优点远时采用 L1，结合了两者的优势。 </p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 5-多层感知机</title>
      <link href="/2022/08/04/d2l-5/"/>
      <url>/2022/08/04/d2l-5/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/04/vG8DkhjKWwenVYr.png" alt="5-感知机.png"></p><p><img src="https://s2.loli.net/2022/08/04/QVbAWsehZUHT6jc.png" alt="5-感知机-1.png"></p><p><img src="https://s2.loli.net/2022/08/04/T23hbkE6yolRNJj.png" alt="5-感知机-2.png"></p><p><img src="https://s2.loli.net/2022/08/04/hPm9Wz682QHTp3N.png" alt="5-感知机-3.png"></p><p><img src="https://s2.loli.net/2022/08/04/3c5lzkvjMOVeFNG.png" alt="5-感知机-4.png"></p><p><img src="https://s2.loli.net/2022/08/04/wRep6V9WNrvhmgM.png" alt="5-感知机-5.png"></p><p><img src="https://s2.loli.net/2022/08/04/MNa1Jte8oqrh5pU.png" alt="5-感知机-6.png"></p><p><img src="https://s2.loli.net/2022/08/04/ARP81vzSjLcGegk.png" alt="5-感知机-7.png"></p><p><img src="https://s2.loli.net/2022/08/04/PErQnYbizBTgFAl.png" alt="5-感知机-8.png"></p><p><img src="https://s2.loli.net/2022/08/04/t8jlQIxa3X45UgB.png" alt="5-感知机-9.png"></p><p><img src="https://s2.loli.net/2022/08/04/GRAlBFdegO8xD3m.png" alt="5-感知机-10.png"></p><p><img src="https://s2.loli.net/2022/08/04/rhxkwIBOL8CQVF9.png" alt="5-感知机-11.png"></p><p>关于多层感知机的知识，还需要结合更深入的学习进一步理解。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 4-softmax回归</title>
      <link href="/2022/08/04/d2l-4/"/>
      <url>/2022/08/04/d2l-4/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/04/LgvYfFOD9sVAZyr.png" alt="4-softmax回归.png"></p><p><img src="https://s2.loli.net/2022/08/04/bzuh95CwAomBqtg.png" alt="4-softmax回归-1.png"></p><p><img src="https://s2.loli.net/2022/08/04/9E8uQoD4fGvrzpm.png" alt="4-softmax回归-2.png"></p><p><img src="https://s2.loli.net/2022/08/04/MDP3obvdruQmcke.png" alt="4-softmax回归-3.png"></p><p>softmax 可以看作支持多分类的逻辑回归，关于逻辑回归的推导可看<a href="https://zhuanlan.zhihu.com/p/95132284">logistic回归原理与实现</a>，关于 softmax 的推导，可看<a href="https://zhuanlan.zhihu.com/p/98061179">softmax回归原理与实现</a></p><p>softmax 的数学基础来自统计学习方法，收到热力统计学启发而得。</p><p>关于 softmax 的数学内容，在 d2l 教材中有着更详细的说明。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 3-梯度下降</title>
      <link href="/2022/08/03/d2l-3/"/>
      <url>/2022/08/03/d2l-3/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/04/aBCA4ieqn1xrbN2.png" alt="3-梯度下降.png"></p><p><img src="https://s2.loli.net/2022/08/04/aTYW25r6ifmjn3d.png" alt="3-梯度下降-1.png"></p><p><img src="https://s2.loli.net/2022/08/04/v7Dq286zkNEJxQe.png" alt="3-梯度下降-2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL 2 常用命令</title>
      <link href="/2022/08/01/WSL2-Useage/"/>
      <url>/2022/08/01/WSL2-Useage/</url>
      
        <content type="html"><![CDATA[<h3 id="查看所有-WSL-分发的状态和版本"><a href="#查看所有-WSL-分发的状态和版本" class="headerlink" title="查看所有 WSL 分发的状态和版本"></a>查看所有 WSL 分发的状态和版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure><h3 id="运行指定分发"><a href="#运行指定分发" class="headerlink" title="运行指定分发"></a>运行指定分发</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -d &lt;分发&gt;</span><br></pre></td></tr></table></figure><h3 id="终止指定分发"><a href="#终止指定分发" class="headerlink" title="终止指定分发"></a>终止指定分发</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -t &lt;分发&gt;</span><br></pre></td></tr></table></figure><h3 id="终止所有分发"><a href="#终止所有分发" class="headerlink" title="终止所有分发"></a>终止所有分发</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><h3 id="注销指定分发并删除根文件系统"><a href="#注销指定分发并删除根文件系统" class="headerlink" title="注销指定分发并删除根文件系统"></a>注销指定分发并删除根文件系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --unregister &lt;分发&gt;</span><br></pre></td></tr></table></figure><h3 id="将指定的-tar-文件作为新分发导入"><a href="#将指定的-tar-文件作为新分发导入" class="headerlink" title="将指定的 tar 文件作为新分发导入"></a>将指定的 tar 文件作为新分发导入</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br></pre></td></tr></table></figure><h3 id="将分发导出到-tar-文件"><a href="#将分发导出到-tar-文件" class="headerlink" title="将分发导出到 tar 文件"></a>将分发导出到 tar 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> &lt;Distro[分发]&gt; &lt;FileName[文件名，包含文件全路径]&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding Itself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> WSL 2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL 2 下配置深度学习环境</title>
      <link href="/2022/08/01/WSL2-Deep-Learning/"/>
      <url>/2022/08/01/WSL2-Deep-Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么用-WSL-2-？"><a href="#为什么用-WSL-2-？" class="headerlink" title="为什么用 WSL 2 ？"></a>为什么用 WSL 2 ？</h2><p>WSL 2 是一种在 Windows 中内置的 Linux 子系统，在深度学习上约有 20% 的性能损失。</p><p>相比直接使用 Linux 系统，WSL 2 可以方便的使用 Windows 下的软件。</p><p>相比直接使用 Windows 系统，WSL 2 实际是 Linux 环境，对深度学习有着更好的支持。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>通过 <a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">使用 WSL 在 Windows 上安装 Linux</a> 中的方式，完成 WSL 2 + Ubuntu 22.04 的安装和配置。</p><p>WSL 2 只需在 Windows 10 下安装显卡驱动，不需要在 Linux 子系统中额外安装显卡驱动。</p><p>通过 <a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html#installing-nvidia-drivers">CUDA Support for WSL 2</a> 中的方式，完成 CUDAToolkit 11.6 的安装和配置。</p><p>通过 <a href="https://conda.io/en/latest/miniconda.html">Miniconda 3 安装</a> 中的方式，完成 Miniconda 3 的安装和配置。</p><p>通过 <a href="https://developer.nvidia.cn/zh-cn/cudnn">NVIDIA CUDA® 深度神经网络库 (cuDNN) </a> 中的方式，完成 cuDNN 8.4.1 的安装和配置。</p><p>通过<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode">开始通过适用于 Linux 的 Windows 子系统使用 Visual Studio Code</a>中的方式，以 ssh remote 的方式，远程连接到 Linux 系统中，在 Windows 10 下编写代码，在 Linux 环境中运行。</p><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>由于本文通过 ssh remote 的方式远程连接到 Linux 子系统中，无法显示 Linux 子系统中运行的图形界面（如 matplotlib，gedit等），因此可以通过 VcXsrv + Remote X11 in VSCode 的方式同样将图形界面远程连接到 Windows 下，详情见<a href="https://www.jianshu.com/p/d9482de4ab6e">WSL中使用pyplot作图</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Coding Itself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> WSL 2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 2-自动求导</title>
      <link href="/2022/07/25/d2l-2/"/>
      <url>/2022/07/25/d2l-2/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/04/sbkA19KlMdnOGv5.png" alt="2-自动求导.png"></p><p><img src="https://s2.loli.net/2022/08/04/1dFCfbnt8UA3LiQ.png" alt="2-自动求导-1.png"></p><p><img src="https://s2.loli.net/2022/08/04/kFMVJtHoz4UbKPp.png" alt="2-自动求导-2.png"></p><p><img src="https://s2.loli.net/2022/08/04/bFxYpoIW4Vstged.png" alt="2-自动求导-3.png"></p><p><img src="https://s2.loli.net/2022/08/04/YuMGnU8mS1jsrgQ.png" alt="2-自动求导-4.png"></p><p><img src="https://s2.loli.net/2022/08/04/d9ucS8oQ7fmjwyJ.png" alt="2-自动求导-5.png"></p><h3 id="反向传播相比正向传播的优势"><a href="#反向传播相比正向传播的优势" class="headerlink" title="反向传播相比正向传播的优势"></a>反向传播相比正向传播的优势</h3><ol><li><p>自带剪枝。</p></li><li><p>对所有变量求偏导可以在一次传播过程中完成。</p></li></ol><h3 id="反向传播相比正向传播的劣势"><a href="#反向传播相比正向传播的劣势" class="headerlink" title="反向传播相比正向传播的劣势"></a>反向传播相比正向传播的劣势</h3><ol><li>空间复杂度为$O(n)$，每个没有被剪枝的节点都需要同时存储在内存中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记 1-矩阵求导</title>
      <link href="/2022/07/23/d2l-1/"/>
      <url>/2022/07/23/d2l-1/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p><a href="https://github.com/d2l-ai/">Github主页</a><br><a href="https://courses.d2l.ai/zh-v2/">课程主页</a><br><a href="https://zh-v2.d2l.ai/">教材</a></p></div><p><img src="https://s2.loli.net/2022/08/04/2T3v8wf57lZzHoU.png" alt="1-矩阵求导.png"></p><p><img src="https://s2.loli.net/2022/08/04/WYEPlTUzCZd9SGk.png" alt="1-矩阵求导-1.png"></p><p><img src="https://s2.loli.net/2022/08/04/kHB6UhNdvMYmAqX.png" alt="1-矩阵求导-2.png"></p><p><img src="https://s2.loli.net/2022/08/04/9ZkYIe1maxTi5s4.png" alt="1-矩阵求导-3.png"></p><p>关于矩阵求导的详细技巧，可见<a href="https://zhuanlan.zhihu.com/p/24709748">矩阵求导术</a>一文。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> d2l </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown与Mathjax的冲突</title>
      <link href="/2022/01/09/Markdown-Mathjax/"/>
      <url>/2022/01/09/Markdown-Mathjax/</url>
      
        <content type="html"><![CDATA[<p>关于Markdown与Mathjax的冲突以及解决方案。</p><p>为了进一步解决冲突问题，详见<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">Mathjax的配置方法</a>。</p><h1 id="冲突1"><a href="#冲突1" class="headerlink" title="冲突1"></a>冲突1</h1><p>有些特殊符号在Markdown与Mathjax中存在表达冲突的问题，如星号（*）在Markdown中可以表示斜体或加粗，在Mathjax中可以表示乘法。</p><p>为了解决冲突，可以在Mathjax中使用Markdown中的转义符（\）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a \* b$</span><br></pre></td></tr></table></figure><p>将会输出为：</p><p>$a * b$</p><p>这种解决方法会导致Latex的语法发生变化，需要注意。</p><h1 id="冲突2"><a href="#冲突2" class="headerlink" title="冲突2"></a>冲突2</h1><p>为了输出大括号，不能在Mathjax中使用如下语法，此处方案会导致大括号不显示。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\&#123; A \&#125;$</span><br></pre></td></tr></table></figure><p>而应使用：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\lbrace A \rbrace$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$\lbrace A \rbrace$</p><h1 id="冲突3"><a href="#冲突3" class="headerlink" title="冲突3"></a>冲突3</h1><p>由于’\‘会被认作Markdown中的转义符号，因此在Mathjax中无法通过’\%’的方式输出百分号，目前没有很好的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Butterfly 基本用法</title>
      <link href="/2022/01/09/Hexo-basis/"/>
      <url>/2022/01/09/Hexo-basis/</url>
      
        <content type="html"><![CDATA[<p>关于Hexo如何生成，测试，上传博客，博客内的基本语法，以及Butterfly主题如何更改配置文件。</p><h1 id="Hexo语法"><a href="#Hexo语法" class="headerlink" title="Hexo语法"></a>Hexo语法</h1><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>通过配置文件，sources文件夹（包含博客以及其他页面文件）生成public文件夹。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>将public文件夹以本地为服务器，生成博客内容，网址为<a href="http://localhost:4000/">http://localhost:4000/</a>。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>将public文件夹上传至Github，利用Github做服务器，生成博客内容。</p><h2 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清空 public 文件夹，清空缓存，适用于修改配置文件后，生成 public 文件夹前。（调用此命令后，应将 MyBlog 文件夹中的 CNAME 和 readme.md 放入 public 文件夹中）</p><h1 id="Hexo-Markdown-Mathjax-Butterfly-博客内语法"><a href="#Hexo-Markdown-Mathjax-Butterfly-博客内语法" class="headerlink" title="Hexo + Markdown + Mathjax + Butterfly 博客内语法"></a>Hexo + Markdown + Mathjax + Butterfly 博客内语法</h1><h2 id="Hexo前缀（Front-matter）"><a href="#Hexo前缀（Front-matter）" class="headerlink" title="Hexo前缀（Front-matter）"></a>Hexo前缀（Front-matter）</h2><p>在博客前，需要添加Front-matter以确定该博客的基本属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Template</span><br><span class="line">//博客标题</span><br><span class="line">date: 2099-01-01 00:00:00</span><br><span class="line">//博客创建时间，缺省为.md创建时间，如果该时间晚于当前时间，则为定时发布（可在主题config的future中调整）</span><br><span class="line">updated: 2099-01-01 00:00:00</span><br><span class="line">//博客更新时间，缺省为.md更新时间</span><br><span class="line">tags: [Chinese,Hexo]</span><br><span class="line">//博客标签（Chinese,Hexo两个标签并列）</span><br><span class="line">categories: [A,B]</span><br><span class="line">//博客分类（A,B两个分类嵌套，B是子分类）</span><br><span class="line">description: About Hexo.</span><br><span class="line">//博客简介，显示在首页或归档中，博客外</span><br><span class="line">cover: http://xx/1.jpg</span><br><span class="line">//博客封面</span><br><span class="line">comments: true/false</span><br><span class="line">//开启评论功能，默认为true</span><br></pre></td></tr></table></figure><h2 id="Markdown-Mathjax基本语法"><a href="#Markdown-Mathjax基本语法" class="headerlink" title="Markdown+Mathjax基本语法"></a>Markdown+Mathjax基本语法</h2><p>博客基本语法即Markdown+Mathjax语法。</p><h3 id="关于Markdown与Mathjax的冲突"><a href="#关于Markdown与Mathjax的冲突" class="headerlink" title="关于Markdown与Mathjax的冲突"></a>关于Markdown与Mathjax的冲突</h3><p>为了进一步解决冲突问题，详见<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">Mathjax的配置方法</a>。</p><h4 id="冲突1"><a href="#冲突1" class="headerlink" title="冲突1"></a>冲突1</h4><p>有些特殊符号在Markdown与Mathjax中存在表达冲突的问题，如星号（*）在Markdown中可以表示斜体或加粗，在Mathjax中可以表示乘法。</p><p>为了解决冲突，可以在Mathjax中使用Markdown中的转义符（\）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a \* b$</span><br></pre></td></tr></table></figure><p>将会输出为：</p><p>$a * b$</p><p>这种解决方法会导致Latex的语法发生变化，需要注意。</p><h4 id="冲突2"><a href="#冲突2" class="headerlink" title="冲突2"></a>冲突2</h4><p>为了输出大括号，不能在Mathjax中使用:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\&#123; A \&#125;$</span><br></pre></td></tr></table></figure><p>而应使用：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\lbrace A \rbrace$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$\lbrace A \rbrace$</p><h2 id="Butterfly主题自创语法"><a href="#Butterfly主题自创语法" class="headerlink" title="Butterfly主题自创语法"></a>Butterfly主题自创语法</h2><div class="note warning modern"><p>该语法仅适用于Butterfly主题，在其他主题下可能会出现错误。</p></div><h3 id="提示标签"><a href="#提示标签" class="headerlink" title="提示标签"></a>提示标签</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">none</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div class="note modern"><p>none</p></div><div class="note default modern"><p>default</p></div><div class="note primary modern"><p>primary</p></div><div class="note success modern"><p>success</p></div><div class="note info modern"><p>info</p></div><div class="note warning modern"><p>warning</p></div><div class="note danger modern"><p>danger</p></div><h3 id="选择标签"><a href="#选择标签" class="headerlink" title="选择标签"></a>选择标签</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tabname %&#125;</span><br><span class="line">&lt;!-- tab name1 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab name2 --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab name3 --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div class="tabs" id="tabname"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tabname-1">name1</button></li><li class="tab"><button type="button" data-href="#tabname-2">name2</button></li><li class="tab"><button type="button" data-href="#tabname-3">name3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tabname-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>更多更详细的用法见<a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly的标签外挂</a>。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="新建页"><a href="#新建页" class="headerlink" title="新建页"></a>新建页</h2><p>在导览菜单中修改，使得右上角出现选项（<a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%B0%8E%E8%88%AA%E8%8F%9C%E5%96%AE">详细操作</a>）。</p><p>在source/pagename中添加页文件，基本语法与博客文件相同（<a href="https://butterfly.js.org/posts/dc584b87/#Page-Front-matter">详细操作</a>）。</p><p>可以加入个人介绍页，简历页等等。</p><h2 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E7%B6%B2%E7%AB%99%E8%B3%87%E6%96%99">详细操作</a></p><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E9%A0%82%E9%83%A8%E5%9C%96">详细操作</a></p><p>可直接通过主题配置文件中的 disable_top_img: true/false 来控制顶部图的启用与关闭。</p><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h2 id="Footer-设置"><a href="#Footer-设置" class="headerlink" title="Footer 设置"></a>Footer 设置</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%8D%9A%E5%AE%A2%E5%B9%B4%E4%BB%BD">详细操作</a></p><p>可在其中加入备案信息。</p><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><p>Butterfly支持评论，图库，在线聊天，分享，搜索系统，网站验证，站点分析统计，广告，美化特效，CDN等等更多功能。</p><p>详见：<a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安装文档(四) 主题配置-2</a></p><p>Butterfly支持音乐，豆瓣电影，说说，自定义代码配色，自定义侧边栏，图片压缩等等更多功能。</p><p>详见：<a href="https://butterfly.js.org/posts/4073eda/">Butterfly 安装文档(六) 进阶教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数的几何意义</title>
      <link href="/2022/01/07/linear-geometry/"/>
      <url>/2022/01/07/linear-geometry/</url>
      
        <content type="html"><![CDATA[<p>基于3Blue1Brown科普内容的总结，关于线性代数的本质。</p><h1 id="3Blue1Brown原视频链接"><a href="#3Blue1Brown原视频链接" class="headerlink" title="3Blue1Brown原视频链接"></a>3Blue1Brown原视频链接</h1><p><a href="https://www.bilibili.com/medialist/play/watchlater/BV1ys411472E">【官方双语/合集】线性代数的本质 - 系列合集</a></p><h1 id="张成与基"><a href="#张成与基" class="headerlink" title="张成与基"></a>张成与基</h1><p>向量集合的张成是所有能表示的点所构成的线性空间。</p><p>基即最小的向量集合，使得该集合的张成等于当前线性空间。</p><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><p>线性变换是指满足可加性，数乘性的离散函数，有输入，有输出。通俗来说，线性变换的几何意义是原点不变且直线在变换后仍为直线，更直观的表示是原点不变且网格线变换前后保持平行且等距离。</p><h1 id="矩阵与矩阵乘法"><a href="#矩阵与矩阵乘法" class="headerlink" title="矩阵与矩阵乘法"></a>矩阵与矩阵乘法</h1><p>矩阵的几何意义是线性变换，矩阵乘法的几何意义是线性变换的叠加。</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>方阵的行列式的几何定义是有向的放缩倍率。</p><h1 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h1><p>非方阵也是高维到低维的线性变换。</p><h1 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h1><p>点积的式子可以用对偶性来证明，看成对于一个向量的非方阵线性变换，使得其位于另一个向量的直线上。</p><h1 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h1><p>二维叉积是有向面积，就是将其看作二维线性变换后的放缩倍率，即行列式。</p><p>三维叉积的面积即将两个向量和另一个单位向量（看作可变向量，但将其认为是单位向量）看作三维线性变换后得到的放缩倍率，即行列式。但最终得到的行列式实际上是个与两个向量垂直的向量，且长度才为叉积值。此处可以用对偶性来证明，将该行列式等同于求得向量与可变向量的点积，显然无论该可变向量如何变化都是成立的，可变向量在所求向量上的投影=可变向量在六面体的高，所求向量长度=底面积叉积，所以叉积的本质就是这个求得向量。</p><h1 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h1><p>特征向量是线性变换中张成空间不变的向量。</p><p>特征值是特征向量的变化率。（$A*v=\lambda*v$，$A$是线性变换矩阵，$\lambda$是特征值，$v$是特征向量）</p><h1 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h1><p>$A^{-1}*M*A$实际上是在非标准基下进行标准视角下的变换。（比如说旋转$90$度，标准基下乘上$M$即可，但是非标准基下要乘上$A^{-1}*M*A$，$A$是用来转化成标准基的线性变换矩阵）</p><p>如果可以选$n$个特征向量张成整个空间的话，那么可以将这$n$个向量看作新的基底，此时线性变换在该基底下一定是对角阵，即有$A^{-1}*M*A=D$。（$D$是对角阵）（基向量都是特征向量的话，线性变换一定是对角阵）</p><p>方阵快速幂：</p><p><img src="https://s2.loli.net/2022/01/12/edGbqpD8MwLSWtN.png" alt="方阵快速幂1"></p><p><img src="https://s2.loli.net/2022/01/12/LjBYEUGC5ypMlQv.png" alt="方阵快速幂2"></p><p><img src="https://s2.loli.net/2022/01/12/kfto6GVTlyKPpru.png" alt="方阵快速幂3"></p><p><img src="https://s2.loli.net/2022/01/12/DBfA7Whi6JQarGL.png" alt="方阵快速幂4"></p><h1 id="向量的抽象"><a href="#向量的抽象" class="headerlink" title="向量的抽象"></a>向量的抽象</h1><p>满足八大公理的结构都能被看作向量，存在线性变换，也有之前所推导的性质。例如函数也可以看作一种有无穷维度的向量，同样有基底（$1,x^1,x^2,x^3,…$）。线性变换即线性算子（如求导等，可以用无穷阶的方阵表示），点积即内积，特征向量即特征函数等等。</p><p><img src="https://s2.loli.net/2022/01/12/dBSCsLpNVnvT3iy.png" alt="八大公理"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Linear Algebra </tag>
            
            <tag> 3Blue1Brown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2022/01/04/hello-hexo/"/>
      <url>/2022/01/04/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算理论笔记 2-非正则语言，乔姆斯基范式</title>
      <link href="/2020/05/16/Theory-of-Computation-2/"/>
      <url>/2020/05/16/Theory-of-Computation-2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/08/05/mBxQle2zPFvSN3y.png" alt="2-1.png"></p><p><img src="https://s2.loli.net/2022/08/05/SDXBov2EwJbZdjR.png" alt="2-2.png"></p><p><img src="https://s2.loli.net/2022/08/05/ykaN7pqDIwiOXKe.png" alt="2-3.png"></p><p><img src="https://s2.loli.net/2022/08/05/CgBcxrukUL37oGd.png" alt="2-4.png"></p><p><img src="https://s2.loli.net/2022/08/05/9XUCu7GVbTQ3z1k.png" alt="2-5.png"></p><p><img src="https://s2.loli.net/2022/08/05/A5FUXRsjnCTVKgB.png" alt="2-6.png"></p><p><img src="https://s2.loli.net/2022/08/05/3ILcjORKmrZFP27.png" alt="2-7.png"></p><p><img src="https://s2.loli.net/2022/08/05/6VgrLQmd48h2Ewj.png" alt="2-8.png"></p><p><img src="https://s2.loli.net/2022/08/05/PVQ9mKHSX6Mwn71.png" alt="2-9.png"></p><p>因为0的个数和1的个数要保持一致，所以沿途要记录0的个数与1的个数的差，每个差值对应都要一个状态，而这个值可能是无限的，所以无法用有穷状态机表示。（D中01和10最多差1，所以是正则的）</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算理论笔记 1-DFA与NFA形式化定义，文法的歧义性</title>
      <link href="/2020/05/15/Theory-of-Computation-1/"/>
      <url>/2020/05/15/Theory-of-Computation-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/08/05/OegpHPKY2yJaIZ4.png" alt="1.png"></p><p><img src="https://s2.loli.net/2022/08/05/dCLgTx8Wnvlz7oE.png" alt="2.png"></p><p><img src="https://s2.loli.net/2022/08/05/GMdoNYTxnCQa5Iz.png" alt="3.png"></p><p><img src="https://s2.loli.net/2022/08/05/ibkyBhHeqm52YSZ.png" alt="4.png"></p><p><img src="https://s2.loli.net/2022/08/05/CVUmsOPNKZtJygL.png" alt="5.png"></p><p><img src="https://s2.loli.net/2022/08/05/NyauvhrCek8LVSf.png" alt="6.png"></p><p><img src="https://s2.loli.net/2022/08/05/gzbTJltL7pF1jiU.png" alt="7.png"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性基四题</title>
      <link href="/2017/12/01/Linear-Basis-4problems/"/>
      <url>/2017/12/01/Linear-Basis-4problems/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/12/01/%E7%BA%BF%E6%80%A7%E5%9F%BA%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="POI2003-Sequences-without-Stammers"><a href="#POI2003-Sequences-without-Stammers" class="headerlink" title="POI2003 Sequences without Stammers"></a>POI2003 Sequences without Stammers</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://darkbzoj.tk/problem/2606">BZOJ 2606</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>第一行包含两个整数$N$和$M$，表示该无向图中点的数目与边的数目。 接下来$M$行描述$M$条边，每行三个整数$S_i,T_i,D_i$，表示$S_i$与$T_i$之间存在一条权值为 $D_i$的无向边。 图中可能有重边或自环。</p><p>仅包含一个整数，表示最大的$XOR$和（十进制结果），注意输出后加换行回车。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸线性基，曾经在CF上做过这题，大致思路就是将所有能遍历到的环插入线性基内，因为一定能通过经过一条路径绕环一圈再从这个路径回来的方式，使得答案异或上环的权值，那么任取一条$1$到$n$的路径到线性基中求异或最大值即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XOR</span>&#123;</span></span><br><span class="line">    ll a[<span class="number">63</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)x^=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;!a[i])&#123;</span><br><span class="line">            a[i]=x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">62</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>((a[j]&gt;&gt;i)&amp;<span class="number">1</span>)a[j]^=x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">sum</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">0</span>)x^=a[i];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],n,m;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll d[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to;ll w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,ll w)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    d[x]=w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[y])T.<span class="built_in">add</span>(d[x]^d[y]^e[i].w);</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">dfs</span>(y,w^e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;w),<span class="built_in">in</span>(x,y,w),<span class="built_in">in</span>(y,x,w);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,T.<span class="built_in">sum</span>(d[n]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BZOJ2844-albus就是要第一个出场"><a href="#BZOJ2844-albus就是要第一个出场" class="headerlink" title="BZOJ2844 albus就是要第一个出场"></a>BZOJ2844 albus就是要第一个出场</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://darkbzoj.tk/problem/2844">BZOJ 2844</a></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>此题实际上为求$k$小线性基的对偶问题，如不考虑重复的话，直接二分皆可解决。考虑上重复的问题，不妨设$cnt$为线性基底个数，那么显然不重复的异或值只有$2^{cnt}$中，即有$n−cnt$个线性无关变量，即每一种异或值都可以经过2n−cnt种变换仍不改变，即每一种异或值共重复了$2^{n−cnt}$次，去重二分后计算上重复次数即可得到答案。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">10086</span>;</span><br><span class="line"><span class="keyword">int</span> n,q[N],Q,cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Xor</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N],b[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)x^=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;!a[i])&#123;</span><br><span class="line">            a[i]=x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">31</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>((a[j]&gt;&gt;i)&amp;<span class="number">1</span>)a[j]^=x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">31</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i])b[++cnt]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;(<span class="number">1</span>&lt;&lt;cnt))<span class="keyword">return</span> <span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">        <span class="keyword">if</span>((k&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>)ret^=b[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=ret*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]),T.<span class="built_in">add</span>(q[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">    T.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(T.<span class="built_in">kth</span>(mid)&gt;=Q)r=mid;</span><br><span class="line">        <span class="keyword">else</span>    l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(<span class="number">1ll</span>+<span class="built_in">qpow</span>(<span class="number">2</span>,n-cnt)*(ll)l)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="CQOI2013-新Nim游戏"><a href="#CQOI2013-新Nim游戏" class="headerlink" title="CQOI2013 新Nim游戏"></a>CQOI2013 新Nim游戏</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://darkbzoj.tk/problem/3105">BZOJ 3105</a></p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>对于后手玩家来说，只要存在多个基底异或值为零，即可将其余所有火柴删除，使得所有最后普通$nim$游戏有异或值为$0$，即后手胜。那么先手玩家为了避免这种情况需要删除所以可能导致异或值为$0$的情况，即可能有线性无关变量的情况（易知不存在先手必败的情况），那么如何将第一个人删除的尽可能少，可以将所有火柴排个序，从大到小插入线性基中，如果为线性无关变量，则直接统计进答案即可。（具体证明需要考虑拟阵，暂时没学）（现在学了，还是不会证）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Xor</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">32</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)x^=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;!a[i])&#123;</span><br><span class="line">            a[i]=x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">31</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>((a[j]&gt;&gt;i)&amp;<span class="number">1</span>)a[j]^=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)<span class="keyword">if</span>(!T.<span class="built_in">add</span>(a[i]))ans+=a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5 5 6 6 5 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="SCOI2016-幸运数字"><a href="#SCOI2016-幸运数字" class="headerlink" title="SCOI2016 幸运数字"></a>SCOI2016 幸运数字</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://darkbzoj.tk/problem/4568">BZOJ 4568</a></p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>该题实际上就是将$x$到$y$中所有权值插入线性基中求异或最大值即为答案，观察$n&lt;=20000$的性质，可以通过倍增维护,每次查询启发式合并即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Xor</span>&#123;</span></span><br><span class="line">    ll a[<span class="number">61</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)x^=a[i];</span><br><span class="line">        <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;!a[i])&#123;</span><br><span class="line">            a[i]=x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">60</span>;++j)</span><br><span class="line">            <span class="keyword">if</span>((a[j]&gt;&gt;i)&amp;<span class="number">1</span>)a[j]^=x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">mx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ll ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(((ret&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">0</span>)ret^=a[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;g[N][<span class="number">15</span>],R;</span><br><span class="line"></span><br><span class="line"><span class="function">Xor <span class="title">mix</span><span class="params">(Xor a,Xor b)</span></span>&#123;</span><br><span class="line">    Xor c;c.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> cnta=<span class="number">0</span>,cntb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)<span class="keyword">if</span>(a.a[i])cnta++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)<span class="keyword">if</span>(b.a[i])cntb++;</span><br><span class="line">    <span class="keyword">if</span>(cnta&gt;=cntb)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)c.a[i]=a.a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(b.a[i])c.<span class="built_in">add</span>(b.a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)c.a[i]=b.a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(a.a[i])c.<span class="built_in">add</span>(a.a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt,n,m,Q,f[N][<span class="number">15</span>],d[N],fa[N];</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,ne;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=fa[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;g[y][<span class="number">0</span>].<span class="built_in">add</span>(a[x]);</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">15</span>;++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        g[i][j]=<span class="built_in">mix</span>(g[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>],g[i][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    R.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])&#123;</span><br><span class="line">        R=<span class="built_in">mix</span>(R,g[x][i]);</span><br><span class="line">        x=f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(f[x][i]!=f[y][i])&#123;</span><br><span class="line">        R=<span class="built_in">mix</span>(R,g[x][i]);R=<span class="built_in">mix</span>(R,g[y][i]);</span><br><span class="line">        x=f[x][i],y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    R.<span class="built_in">add</span>(a[f[x][<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//  cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">lca</span>(x,y);</span><br><span class="line">    R.<span class="built_in">add</span>(a[x]);R.<span class="built_in">add</span>(a[y]);</span><br><span class="line">    <span class="keyword">return</span> R.<span class="built_in">mx</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();Q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=Q;++i)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">11 5 7 9</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Linear Basis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机九题</title>
      <link href="/2017/12/01/AC-9problems/"/>
      <url>/2017/12/01/AC-9problems/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/12/01/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="AC自动机（简单版）"><a href="#AC自动机（简单版）" class="headerlink" title="AC自动机（简单版）"></a>AC自动机（简单版）</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P3808">Luogu 3808</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>AC自动机裸题，如果不加$last$优化会TLE。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>],f[N],cnt;</span><br><span class="line"><span class="keyword">int</span> l[N];</span><br><span class="line"><span class="keyword">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[x][c]==<span class="number">-1</span>)&#123;</span><br><span class="line">            ch[x][c]=++cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)ch[cnt][j]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x=ch[x][c];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">    <span class="keyword">if</span>(~ch[<span class="number">0</span>][i])l[ch[<span class="number">0</span>][i]]=f[ch[<span class="number">0</span>][i]]=<span class="number">0</span>,q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">else</span>    ch[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//    static int g[N];</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tag[ch[f[x]][i]])l[ch[x][i]]=ch[f[x]][i];</span><br><span class="line">            <span class="keyword">else</span>    l[ch[x][i]]=l[ch[f[x]][i]];</span><br><span class="line">            <span class="keyword">if</span>(~ch[x][i])f[ch[x][i]]=ch[f[x]][i],q.<span class="built_in">push</span>(ch[x][i]);</span><br><span class="line">            <span class="keyword">else</span>    ch[x][i]=ch[f[x]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        x=ch[x][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j;j=l[j])</span><br><span class="line">        <span class="keyword">if</span>(!vis[j])vis[j]=<span class="number">1</span>,ret+=tag[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)ch[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),<span class="built_in">add</span>(s);</span><br><span class="line">    <span class="built_in">getfail</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">get</span>(s)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AC自动机（加强版）"><a href="#AC自动机（加强版）" class="headerlink" title="AC自动机（加强版）"></a>AC自动机（加强版）</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P3796">Luogu 3796</a></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>AC自动机裸题。不加$last$优化也能过，多组数据注意清零。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr[N][<span class="number">26</span>],f[N],cnt,ans[N];</span><br><span class="line"><span class="keyword">int</span> l[N];</span><br><span class="line"><span class="keyword">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[x][c]==<span class="number">-1</span>)&#123;</span><br><span class="line">            tr[x][c]=++cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)tr[cnt][j]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x=tr[x][c];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[x]=fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">    <span class="keyword">if</span>(~tr[<span class="number">0</span>][i])l[tr[<span class="number">0</span>][i]]=f[tr[<span class="number">0</span>][i]]=<span class="number">0</span>,q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">else</span>    tr[<span class="number">0</span>][i]=<span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[x][i]==<span class="number">-1</span>)&#123;tr[x][i]=tr[f[x]][i];<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">int</span> y=tr[x][i];</span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">            f[y]=tr[f[x]][i];</span><br><span class="line"><span class="comment">//            l[y]=tag[f[y]]?f[y]:l[f[y]];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        x=tr[x][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j;j=f[j])</span><br><span class="line">        <span class="keyword">if</span>(tag[j])ans[tag[j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">256</span>][<span class="number">256</span>];</span><br><span class="line"><span class="keyword">char</span> s1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)tr[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]),<span class="built_in">add</span>(s[i],i);</span><br><span class="line">        <span class="built_in">getfail</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s1);<span class="built_in">get</span>(s1);</span><br><span class="line">        <span class="keyword">int</span> res=*<span class="built_in">max_element</span>(ans+<span class="number">1</span>,ans+n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(ans[i]==res)<span class="built_in">put</span>(s[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)tag[i]=f[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HNOI2006-最短母串"><a href="#HNOI2006-最短母串" class="headerlink" title="HNOI2006 最短母串"></a>HNOI2006 最短母串</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P2322">Luogu 2322</a></p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>考虑$n$很小的性质，第一眼以为是状态压缩DP暴力转移（实际也能做，但是很难写），正解应该是将在AC自动机上DP。根据AC自动机的性质，易知一条路径即代表一个字符串。设$f[i][S]$表示当前走到第$i$号节点，已经覆盖串的集合为$S$的最小步数状态数为$50n2^n$，直接用BFS更新即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e2</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">13</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;X,Y;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt,tr[N][<span class="number">26</span>],f[N],tag[N],pos[N];</span><br><span class="line">    <span class="keyword">int</span> d[N][<span class="number">1</span>&lt;&lt;<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">int</span> prex[N][<span class="number">1</span>&lt;&lt;<span class="number">12</span>],prey[N][<span class="number">1</span>&lt;&lt;<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr[<span class="number">0</span>],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c=s[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(tr[x][c]==<span class="number">-1</span>)&#123;</span><br><span class="line">                tr[x][c]=++cnt;</span><br><span class="line">                pos[cnt]=c;</span><br><span class="line">                <span class="built_in">memset</span>(tr[cnt],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[cnt]));</span><br><span class="line">                tag[cnt]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x=tr[x][c];</span><br><span class="line">        &#125;</span><br><span class="line">        tag[x]|=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(~tr[<span class="number">0</span>][i])f[tr[<span class="number">0</span>][i]]=<span class="number">0</span>,q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">else</span>    tr[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            tag[x]|=tag[f[x]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">                <span class="keyword">else</span>    tr[x][i]=tr[f[x]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> q[N];</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            q[++q[<span class="number">0</span>]]=pos[x]+<span class="string">&#x27;A&#x27;</span>;    </span><br><span class="line">            <span class="keyword">int</span> x1=x,y1=y;    </span><br><span class="line">            x=prex[x1][y1];</span><br><span class="line">            y=prey[x1][y1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(q+<span class="number">1</span>,q+q[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q[<span class="number">0</span>];++i)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(<span class="keyword">char</span>)q[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">getf</span>();</span><br><span class="line">        <span class="keyword">int</span> S=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">        queue&lt;kd&gt;q;</span><br><span class="line">        X.x=<span class="number">0</span>;X.y=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(X);d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        prex[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;prey[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            X=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(tr[X.x][i])&#123;</span><br><span class="line">                <span class="keyword">int</span> to=tr[X.x][i];</span><br><span class="line">                Y.x=to;Y.y=X.y|tag[to];</span><br><span class="line">                <span class="keyword">if</span>(d[Y.x][Y.y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    prex[Y.x][Y.y]=X.x;prey[Y.x][Y.y]=X.y;</span><br><span class="line"></span><br><span class="line">                    d[Y.x][Y.y]=d[X.x][X.y]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Y.y==S)&#123;</span><br><span class="line"><span class="comment">//                        printf(&quot;%d\n&quot;,d[Y.x][Y.y]);</span></span><br><span class="line">                        <span class="built_in">output</span>(Y.x,Y.y);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.<span class="built_in">push</span>(Y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    T.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);</span><br><span class="line">        T.<span class="built_in">add</span>(s[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    T.<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BJOI2017-魔法咒语"><a href="#BJOI2017-魔法咒语" class="headerlink" title="BJOI2017 魔法咒语"></a>BJOI2017 魔法咒语</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P3715">Luogu 3715</a></p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>设$f[i][L]$为走到第$i$号节点，此时字符串长度（即路径长度）为$L$的方案数，那么由于字符集在此题中被限制为了一个个的字符串，所以需要预处理$go[i][j]$表示从$i$号节点出发后经过第$j$个基本词汇后所到达的节点，如果其中经过禁忌词语，则初始化为$-1$表示不可到达。那么DP方程如下：（$len[j]$表示基本词汇$j$的长度）</p><p>$$f[go[i][j]][L+len[j]] += f[i][L]  (go[i][j]!=-1)$$</p><p>观察数据范围，朴素的DP只能通过$60 \ percents$的数据，剩余$L&lt;=10^8$且$len[j]&lt;=2$的部分分，可以通过矩阵乘法优化，用$f[i][j]$表示从$i$号节点一步到达$j$号节点的方案数，可以处理$len[j]=1$的情况。对于$len[j]=2$的情况，对于每个节点$i$设一个虚拟节点$b[i]$，然后$f[i][b[j]]$表示从$i$一步到$b[j]$的方案数，再从$b[j]$向$j$连一条边即可（即f$[b[j]][j]=1$）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,L,cnt,len[<span class="number">51</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">51</span>][<span class="number">401</span>],b[<span class="number">51</span>][<span class="number">401</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    a+=b;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=mod)a-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t1k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    ll a[<span class="number">401</span>][<span class="number">401</span>];</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (Matrix a,Matrix b)&#123;</span><br><span class="line">        Matrix c;</span><br><span class="line">        <span class="built_in">memset</span>(c.a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c.a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=t1k;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=t1k;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=t1k;++k)</span><br><span class="line">            (c.a[i][j]+=a.a[i][k]*b.a[k][j])%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;res,c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N][<span class="number">26</span>],f[N],tag[N],val[N],to[N][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr[<span class="number">0</span>],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(tr[x][c]==<span class="number">-1</span>)&#123;</span><br><span class="line">                tr[x][c]=++cnt;</span><br><span class="line">                val[cnt]=i;</span><br><span class="line">                <span class="built_in">memset</span>(tr[cnt],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[cnt]));</span><br><span class="line">            &#125;</span><br><span class="line">            x=tr[x][c];</span><br><span class="line">        &#125;</span><br><span class="line">        tag[x]=h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(~tr[<span class="number">0</span>][i])f[tr[<span class="number">0</span>][i]]=<span class="number">0</span>,q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">else</span>    tr[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            tag[x]|=tag[f[x]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">            <span class="keyword">else</span>    tr[x][i]=tr[f[x]][i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">            <span class="keyword">int</span> x=i;</span><br><span class="line">            <span class="keyword">if</span>(tag[x])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                x=tr[x][s[j]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(tag[x])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> dp[N][<span class="number">101</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=L;++l)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">        <span class="keyword">if</span>(len[j]+l&lt;=L)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=to[i][j];</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mul</span>(dp[y][len[j]+l],dp[i][l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;++i)<span class="built_in">mul</span>(ans,dp[i][L]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t1k=<span class="number">2</span>*cnt+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tp=cnt+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;++i)res.a[i+tp][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>*cnt+<span class="number">1</span>;++i)c.a[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=to[i][j];</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(len[j]==<span class="number">1</span>)res.a[i][y]++;</span><br><span class="line">            <span class="keyword">else</span>    res.a[i][y+tp]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(L)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L&amp;<span class="number">1</span>)c=c*res;</span><br><span class="line">            L&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            res=res*res;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;++i)(ans+=c.a[<span class="number">0</span>][i])%=mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="built_in">add</span>(b[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">getf</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">        to[i][j]=<span class="built_in">go</span>(i,a[j]);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=<span class="number">100</span>)<span class="built_in">A</span>();</span><br><span class="line">        <span class="keyword">else</span>     <span class="built_in">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a[i]),len[i]=<span class="built_in">strlen</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b[i]);</span><br><span class="line">    T.<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2 98</span></span><br><span class="line"><span class="comment">bo</span></span><br><span class="line"><span class="comment">oo</span></span><br><span class="line"><span class="comment">hm</span></span><br><span class="line"><span class="comment">ba</span></span><br><span class="line"><span class="comment">ob</span></span><br><span class="line"><span class="comment">mho</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="BJWC2011-禁忌"><a href="#BJWC2011-禁忌" class="headerlink" title="BJWC2011 禁忌"></a>BJWC2011 禁忌</h1><h2 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P4569">Luogu 4569</a></p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>首先考虑对于一个给定的串，如何求其禁忌伤害，这是一个经典的贪心问题，即线段覆盖问题，正确的姿势是按右端点排序，能取的尽量取即可，如果去除存在覆盖的禁忌串（一定没有只取被覆盖的子串优越），那么姿势等价于按左端点排序，且尽可能的取。</p><p>考虑在AC自动机上的贪心，即为从根节点出发每次走到一个禁忌串后，直接返回根节点（因为禁忌串之间不能相互覆盖），重复过程直到路径长度为$L$并将答案加上返回次数除以$2^{len}$，考虑如何用DP优化此过程，仍然设$f[i][L]$表示走到$i$号节点，路径长度为$L$的概率，那么显然有（$0$表示根节点,$tag$表示是否为禁忌串。）</p><p>$$f[0][L+1]+=f[i][L]+1/alphabet \ (tag[tr[x][i]]=1)$$</p><p>$$f[tr[x][i]][L+1]+=f[i][L]+1/alphabet \ (tag[tr[x][i]]=0)$$</p><p>考虑如何将统计答案。在贪心的过程中，每次访问到禁忌串时不仅要返回根节点，还要将答案加上到当前节点的概率，即新建一个节点$g$表示答案节点，那么同样有</p><p>$$f[g][L+1]+=f[i][L]+1/alphabet \ (tag[tr[x][i]]=1)$$</p><p>即可以用矩阵乘法优化此过程，并且需要设定$matrix[g][g]=1$，矩阵$L$次方代表$1−L$前缀和的贡献，即为答案。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt,n,L,ml,len[<span class="number">6</span>],tr[N][<span class="number">26</span>],f[N],tag[N];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">6</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    db a[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> matrix <span class="keyword">operator</span> * (matrix a,matrix b)&#123;</span><br><span class="line">        matrix c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt+<span class="number">1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt+<span class="number">1</span>;++j)</span><br><span class="line">        c.a[i][j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt+<span class="number">1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt+<span class="number">1</span>;++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cnt+<span class="number">1</span>;++k)</span><br><span class="line">        c.a[i][j]+=a.a[i][k]*b.a[k][j];</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;res;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(ll b)</span></span>&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt+<span class="number">1</span>;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt+<span class="number">1</span>;++j)</span><br><span class="line">    c.a[i][j]=(i==j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)c=c*res;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        res=res*res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    db k=<span class="number">1.00</span>/(db)ml;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ml;++j)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=tr[i][j];</span><br><span class="line">        <span class="keyword">if</span>(tag[y])res.a[i][<span class="number">0</span>]+=k,res.a[i][cnt+<span class="number">1</span>]+=k;</span><br><span class="line">        <span class="keyword">else</span>    res.a[i][y]+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    res.a[cnt+<span class="number">1</span>][cnt+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>,(<span class="keyword">double</span>)<span class="built_in">qpow</span>(L).a[<span class="number">0</span>][cnt+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[x][c]==<span class="number">-1</span>)&#123;</span><br><span class="line">            tr[x][c]=++cnt;</span><br><span class="line">            <span class="built_in">memset</span>(tr[cnt],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[cnt]));</span><br><span class="line">        &#125;</span><br><span class="line">        x=tr[x][c];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml;++i)</span><br><span class="line">    <span class="keyword">if</span>(~tr[<span class="number">0</span>][i])f[tr[<span class="number">0</span>][i]]=<span class="number">0</span>,q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">else</span>    tr[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        tag[x]|=tag[f[x]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">            <span class="keyword">else</span>    tr[x][i]=tr[f[x]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">memset</span>(tr[<span class="number">0</span>],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;L,&amp;ml);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]),len[i]=<span class="built_in">add</span>(s[i]);</span><br><span class="line">    <span class="built_in">getf</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SCOI2012-喵星球上的点名"><a href="#SCOI2012-喵星球上的点名" class="headerlink" title="SCOI2012 喵星球上的点名"></a>SCOI2012 喵星球上的点名</h1><h2 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P2336">Luogu 2336</a></p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>由于本题中字符集过大，肯定不能将数组开满，需要用$map$来存储儿子，且不能在每次新建节点时将儿子都表示成$−1$，那么就要默认为$0$。同理需要将根节点设为$1$，并赋值$tr[0][i]=1$，在$getfail$的时候，也应该直接暴力跳$fail$。由于数据较水，这样即可通过此题。（正解为后缀数组+主席树）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;tr[N];</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">int</span> n,m,L,cnt,f[N],g[N],ans[N],res[N],id[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],vis1[N],T;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;a[N],b[N],tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *s,<span class="keyword">int</span> n,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(!tr[x][c])tr[x][c]=++cnt;</span><br><span class="line">        x=tr[x][c];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[x].<span class="built_in">pb</span>(fa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(it=tr[x].<span class="built_in">begin</span>();it!=tr[x].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=it-&gt;first,k=f[x];</span><br><span class="line">            <span class="keyword">while</span>(!tr[k][t])k=f[k];</span><br><span class="line">            f[it-&gt;second]=tr[k][t];</span><br><span class="line">            q.<span class="built_in">push</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;L;++i)&#123;</span></span><br><span class="line"><span class="comment">//            if(tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);</span></span><br><span class="line"><span class="comment">//            else    tr[x][i]=tr[f[x]][i];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cala</span><span class="params">(<span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[g].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=a[g][i];</span><br><span class="line">        <span class="keyword">while</span>(!tr[x][to])x=f[x];x=tr[x][to];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j;j=f[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis1[j]==T)<span class="keyword">break</span>;vis1[j]=T;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tag[j].<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">                <span class="keyword">int</span> y=tag[j][k];</span><br><span class="line">                <span class="keyword">if</span>(vis[y]!=T)vis[y]=T,++ret,ans[y]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calb</span><span class="params">(<span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b[g].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=b[g][i];</span><br><span class="line">        <span class="keyword">while</span>(!tr[x][to])x=f[x];x=tr[x][to];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j;j=f[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis1[j]==T)<span class="keyword">break</span>;vis1[j]=T;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tag[j].<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">                <span class="keyword">int</span> y=tag[j][k];</span><br><span class="line">                <span class="keyword">if</span>(vis[y]!=T)vis[y]=T,++ret,ans[y]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    L=<span class="number">10001</span>;cnt=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L;++i)tr[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k;i&lt;=n;++i)&#123;</span><br><span class="line">        k=<span class="built_in">read</span>();<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)a[i].<span class="built_in">pb</span>(<span class="built_in">read</span>());</span><br><span class="line">        k=<span class="built_in">read</span>();<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)b[i].<span class="built_in">pb</span>(<span class="built_in">read</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k;i&lt;=m;++i)&#123;</span><br><span class="line">        k=<span class="built_in">read</span>();<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)g[j]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(g,k,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getf</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ++T;</span><br><span class="line">        res[i]=</span><br><span class="line">        <span class="built_in">cala</span>(i)+</span><br><span class="line">        <span class="built_in">calb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">        <span class="keyword">if</span>(i!=n)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HAOI2017-字符串"><a href="#HAOI2017-字符串" class="headerlink" title="HAOI2017 字符串"></a>HAOI2017 字符串</h1><h2 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P3735">Luogu 3735</a></p><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>对于每个询问串和初始串，将问题转化为其前后缀的匹配（初始串的表示为$x,y$询问串的表示为为$a,b$）。先将所有询问串建到AC自动机上，然后建出$fail$树。</p><p>同$NOI2011$阿狸的打字机一样，对于一个初始串的子串能匹配到询问串当且仅当在$fail$树中，$x[j]$在$a[j]$的子树中，且$y[j+k+1]$在$b[j+k+1]$的子树中，该算法可以通过子树差分来实现。但是如果直接统计所有前后缀的话，明显会存在重复的情况：</p><p>初始串：$aaab$</p><p>询问串：$abab$</p><p>$k=2$</p><p>此时显然询问串与初始串匹配了两回（即$x[0]−&gt;y[3]$与$a[0]−&gt;b[3]$和$x[1]−&gt;y[4]$与$a[1]−&gt;b[4]$）。</p><p>一般性的，以上算法实际上求的是$k1 \in [1,k]$中所有可以匹配的$k1$的个数，那么$k$匹配个数即为$[1,k]$匹配个数与$[1,k−1]$匹配个数的差。（需要注意在求解$[1,k−1]$的时候，$a,b,x,y$的边界条件需要与求解$[1,k]$时对齐） </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">char</span> s[N],p[N];</span><br><span class="line"><span class="keyword">int</span> n,ans[N];</span><br><span class="line">vector&lt;pii&gt;sum1[N],sum2[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N],ch1[N],ch2[N];</span><br><span class="line"><span class="keyword">int</span> st[N],ed[N],totw;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lb</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="built_in">lb</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=totw;x+=x&amp;-x)a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=x&amp;-x)ret+=a[x];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(ed[x])-<span class="built_in">sum</span>(st[x]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _debug(<span class="keyword">int</span> *a)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AC</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N][<span class="number">95</span>],f[N],cnt,x[N],y[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> n,<span class="keyword">int</span> *q,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        q[<span class="number">0</span>]=q[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=flag?n:<span class="number">1</span>;flag?i&gt;=<span class="number">1</span>:i&lt;=n;flag?--i:++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c=s[i]<span class="number">-33</span>;</span><br><span class="line">            <span class="keyword">if</span>(tr[x][c]==<span class="number">-1</span>)&#123;</span><br><span class="line">                tr[x][c]=++cnt;</span><br><span class="line">                <span class="built_in">memset</span>(tr[cnt],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[cnt]));</span><br><span class="line">            &#125;</span><br><span class="line">            q[i]=x=tr[x][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">95</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(~tr[<span class="number">0</span>][i])q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">else</span>    tr[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            g[f[x]].<span class="built_in">pb</span>(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">95</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.<span class="built_in">push</span>(tr[x][i]);</span><br><span class="line">            <span class="keyword">else</span>    tr[x][i]=tr[f[x]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        st[x]=++totw;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();++i)<span class="built_in">dfs</span>(g[x][i]);</span><br><span class="line">        ed[x]=totw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum1[x].<span class="built_in">size</span>();++i)&#123;pii t=sum1[x][i];ans[t.sd]-=T[<span class="number">0</span>].<span class="built_in">get</span>(t.fr);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum2[x].<span class="built_in">size</span>();++i)&#123;pii t=sum2[x][i];ans[t.sd]+=T[<span class="number">1</span>].<span class="built_in">get</span>(t.fr);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ch1[x].<span class="built_in">size</span>();++i)&#123;<span class="keyword">int</span> t=ch1[x][i];T[<span class="number">0</span>].<span class="built_in">add</span>(st[t]);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ch2[x].<span class="built_in">size</span>();++i)&#123;<span class="keyword">int</span> t=ch2[x][i];T[<span class="number">1</span>].<span class="built_in">add</span>(st[t]);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();++i)<span class="built_in">getans</span>(g[x][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum1[x].<span class="built_in">size</span>();++i)&#123;pii t=sum1[x][i];ans[t.sd]+=T[<span class="number">0</span>].<span class="built_in">get</span>(t.fr);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum2[x].<span class="built_in">size</span>();++i)&#123;pii t=sum2[x][i];ans[t.sd]-=T[<span class="number">1</span>].<span class="built_in">get</span>(t.fr);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr[<span class="number">0</span>],<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> m=<span class="built_in">strlen</span>(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(m&lt;=k)ans[i]=len-m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">add</span>(p,m,x,<span class="number">0</span>);<span class="built_in">add</span>(p,m,y,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//                _debug(x);_debug(y);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;=m+<span class="number">1</span>;++j)sum1[x[j-k<span class="number">-1</span>]].<span class="built_in">pb</span>(<span class="built_in">mp</span>(y[j],i));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;=m;++j)sum2[x[j-k]].<span class="built_in">pb</span>(<span class="built_in">mp</span>(y[j],i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getf</span>();</span><br><span class="line">        <span class="keyword">int</span> pt;</span><br><span class="line">        x[<span class="number">0</span>]=x[len+<span class="number">1</span>]=y[<span class="number">0</span>]=y[len+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        pt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)x[i]=pt=tr[pt][s[i]<span class="number">-33</span>];</span><br><span class="line">        pt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;=<span class="number">1</span>;--i)y[i]=pt=tr[pt][s[i]<span class="number">-33</span>];</span><br><span class="line"><span class="comment">//        _debug(x);_debug(y);</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;=len+<span class="number">1</span>;++j)ch1[x[j-k<span class="number">-1</span>]].<span class="built_in">pb</span>(y[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;=len;++j)ch2[x[j-k]].<span class="built_in">pb</span>(y[j]);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//        _debug(st);</span></span><br><span class="line">        <span class="built_in">getans</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;AC;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;problemb.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;problemb.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>,&amp;k,s+<span class="number">1</span>,&amp;n);</span><br><span class="line">    AC.<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line"><span class="comment">//    cout&lt;&lt;AC.cnt&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TJOI2013-单词"><a href="#TJOI2013-单词" class="headerlink" title="TJOI2013 单词"></a>TJOI2013 单词</h1><h1 id="COCI2015-Divljak"><a href="#COCI2015-Divljak" class="headerlink" title="COCI2015 Divljak"></a>COCI2015 Divljak</h1>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> BFS and DFS </tag>
            
            <tag> AC Automaton </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文树总结</title>
      <link href="/2017/11/28/Palindrome-Tree/"/>
      <url>/2017/11/28/Palindrome-Tree/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/11/28/%E5%9B%9E%E6%96%87%E6%A0%91%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>回文树能够以$O(n)$的时间求出字符串中本质不同的回文串个数（最多为$n$个，证明考虑每次插入一个新的后缀，如果形成的新的最长回文串不是整个串，则一定在前面插入时出现过）和其长度与出现次数。</p><p>回文树中每个节点表示的是一个回文串，第一种边以$son[x][ch]$存储，指向的是$x$所代表的回文串前后各插入一个$ch$所形成的字符串，第二种边为后缀链接边(suffix link)，指向的是$x$所代表的回文串其最长的回文子串（与$x$不相等），以$f[x]$表示。初始化为一个长度为$0$的节点（标号应为$0$）和长度为$−1$的节点，其中前者的$f$指向后者，具体原因见下文代码注释。</p><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>从左到右一个字符一个字符地处理，始终维护着当前已处理前缀的最长后缀回文串（初始时为空串）。每次扫描一个新的字符$x$时，我们就沿着最长后缀回文串的$f$找到一个回文串$A$，它的两边可以同时添加字符$x$，得到一个合法的后缀回文串。$xAx$是新节点的唯一候选，为了得到它的$f$，我们需要继续沿着链接走，直到找到另一个回文串$B$，它的两边添加字符$x$可以得到$xAx$的合法后缀回文串，于是添加一条从$xAx$到$xBx$的$f$边（当然，如果这条边已经存在就不用了）。</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PalindromesTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot,last,l[N],son[N][<span class="number">26</span>],c[N],f[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        l[++tot]=x;<span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tot=<span class="number">-1</span>;last=<span class="number">0</span>;</span><br><span class="line">        f[<span class="built_in">newnode</span>(<span class="number">0</span>)]=<span class="number">1</span>;f[<span class="built_in">newnode</span>(<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[n]!=s[n-l[x]<span class="number">-1</span>])x=f[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">//沿着最长后缀回文串的$f$找到一个回文串A，它的两边可以同时添加字符x</span></span><br><span class="line">        <span class="comment">//如果找不到的话，那么会先遍历到长度为$0$的节点，判断能否形成s[n-1],s[n]这样一个回文串，否则来到长度为$-1$的节点，一定能形成一个s[n]单个字符的回文串。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="built_in">get</span>(last,i);<span class="comment">//last即为维护的最长后缀回文串</span></span><br><span class="line">        <span class="keyword">if</span>(!son[y][x])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">newnode</span>(l[y]+<span class="number">2</span>);<span class="comment">//now代表的回文串为y代表的回文串在两边加入xx形成。</span></span><br><span class="line">            f[now]=son[<span class="built_in">get</span>(f[y],i)][x];<span class="comment">//更新f，理由get函数注释</span></span><br><span class="line">            son[y][x]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        c[last=son[y][x]]++;<span class="comment">//表示出现次数，最后要更新c[f[x]]+=c[x]，因为如果产生了一个新的回文串的话，那么其所有子串是没有计算c的变化的。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;=<span class="number">1</span>;--i)c[f[i]]+=c[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br></pre></td></tr></table></figure><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="APIO2014-Palindromes"><a href="#APIO2014-Palindromes" class="headerlink" title="APIO2014 Palindromes"></a>APIO2014 Palindromes</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://uoj.ac/problem/103">UOJ 103</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>虚树模板题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PalindromesTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot,last,l[N],son[N][<span class="number">26</span>],c[N],f[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        l[++tot]=x;<span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tot=<span class="number">-1</span>;last=<span class="number">0</span>;</span><br><span class="line">        f[<span class="built_in">newnode</span>(<span class="number">0</span>)]=<span class="number">1</span>;f[<span class="built_in">newnode</span>(<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[n]!=s[n-l[x]<span class="number">-1</span>])x=f[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="built_in">get</span>(last,i);</span><br><span class="line">        <span class="keyword">if</span>(!son[y][x])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">newnode</span>(l[y]+<span class="number">2</span>),ne=<span class="built_in">get</span>(f[y],i);</span><br><span class="line">            f[now]=son[ne][x];</span><br><span class="line">            son[y][x]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        c[last=son[y][x]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;=<span class="number">1</span>;--i)c[f[i]]+=c[i];</span><br><span class="line">        ll ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)ret=<span class="built_in">max</span>(ret,(ll)l[i]*c[i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    T.<span class="built_in">init</span>();</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,T.<span class="built_in">solve</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Codechef-Palindromeness"><a href="#Codechef-Palindromeness" class="headerlink" title="Codechef Palindromeness"></a>Codechef Palindromeness</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/13/Ni8Vmjbv9ksDU7H.png" alt="题目描述"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>判断第一个满足条件的后缀回文是否正好为其一半长度，每次递归$f$数组查询显然会TLE，用$hf_x$表示满足小于等于其一半长度的$f_x$记忆化处理即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PalindromicTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot,last,l[N],son[N][<span class="number">26</span>],hf[N],f[N];</span><br><span class="line">    ll c[N],g[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        l[++tot]=x;</span><br><span class="line">        f[tot]=hf[tot]=c[tot]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(son[tot],<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(son[tot]));</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last=<span class="number">0</span>;tot=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(g[<span class="number">0</span>]!=<span class="number">0</span>||g[<span class="number">1</span>]!=<span class="number">0</span>)<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">0</span>);f[<span class="number">0</span>]=hf[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">-1</span>);f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[i]!=s[i-l[x]<span class="number">-1</span>])x=f[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="built_in">get</span>(last,i);</span><br><span class="line">        <span class="keyword">if</span>(!son[y][x])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">newnode</span>(l[y]+<span class="number">2</span>);</span><br><span class="line">            f[now]=son[<span class="built_in">get</span>(f[y],i)][x];</span><br><span class="line">            hf[now]=son[<span class="built_in">get</span>(hf[y],i)][x];</span><br><span class="line">            <span class="keyword">while</span>(l[hf[now]]&gt;l[now]/<span class="number">2</span>)hf[now]=f[hf[now]];</span><br><span class="line">            <span class="keyword">int</span> fr=hf[now];</span><br><span class="line">            g[now]=<span class="number">1</span>+(l[fr]==l[now]/<span class="number">2</span>)*g[fr];</span><br><span class="line">            son[y][x]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        c[last=son[y][x]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ll ret=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            ret+=c[i]*g[i];</span><br><span class="line">            c[f[i]]+=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Case);</span><br><span class="line">    <span class="keyword">while</span>(Case--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,T.<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Palindrome Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚树总结</title>
      <link href="/2017/11/27/Virtual-Tree/"/>
      <url>/2017/11/27/Virtual-Tree/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/11/27/%E8%99%9A%E6%A0%91%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>虚树可以用来解决在树上的多次询问，约束总询问点数的动态规划问题，相较直接BFS的高复杂度，虚树可以将开销降到与单次询问点数相关的时间复杂度之内。</p><h1 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h1><p>考虑动态规划合并多个询问节点，只有在遍历到关键的$LCA$时才会计算贡献，且可以直接以$LCA$代替以下节点，所以可以设计出以下算法流程：</p><ol><li><p>维护一个以$dfn$序为关键字的单调栈，栈顶元素$p$为所有已经处理过的节点中$dfn$最大的节点，一般以根为初始节点，将所有询问节点按$dfn$排序进行插入。</p></li><li><p>根据以上算法，一定有$dfn_x&gt;dfn_p$。设栈顶第二个元素为$q$，根据$LCA$与$q$的关系进行分类讨论：</p><ul><li><p>当$LCA=p$时，将$x$入栈。</p></li><li><p>否则$p$与$q$分别在$lca$的两个子树中，则需要重复以下操作，直到$p$到$lca$中所有节点处理完毕，然后再将$x$入栈。</p><ul><li>当$dfn_q &gt; dfn_{lca}$时，连边$(q,p)$,并将$p$退栈。</li><li>当$dfn_q = dfn_{lca}$时，连边$(lca,p)$。此时$p$到$lca$已经处理完毕，即可跳出循环。</li><li>当$dfn_q &lt; dfn_{lca}$时，此时$lca$在$q−&gt;p$上，建边$(lca,p)$，以$lca$代替$p$在栈中的位置。此时$p$到$lca$已经处理完毕，即可跳出循环。</li></ul></li></ul></li></ol><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="SDOI2011-消耗战"><a href="#SDOI2011-消耗战" class="headerlink" title="SDOI2011 消耗战"></a>SDOI2011 消耗战</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.luogu.com.cn/problem/P2495">Luogu 2495</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/13/OWXPF1lKyNYGEsa.png" alt="题目描述"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设$f_x$为覆盖以$x$为跟子树的最小代价，则有$f_x=min(\sum f_{sonx},g_x)$，其中$g_x$代表根到$x$路径上的最小权值边，用虚树优化即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,head[N],d[N],cnt,f[N][<span class="number">19</span>],q[N],dfn[N],totw,st[N],vis[N];</span><br><span class="line">ll dp[N],g[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to;ll w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    dfn[x]=++totw;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        g[y]=<span class="built_in">min</span>(g[x],e[i].w);</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[a]&lt;dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T=<span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ll k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)k+=<span class="built_in">get</span>(e[i].to);</span><br><span class="line">    head[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[x]=(vis[x]!=T?<span class="built_in">min</span>(g[x],k):g[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;++T;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+k+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)vis[q[i]]=T;</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">    st[++L]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[i],l=<span class="built_in">lca</span>(x,st[L]);</span><br><span class="line">        <span class="keyword">if</span>(l==st[L])st[++L]=x;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfn[l]&gt;=dfn[st[L<span class="number">-1</span>]])&#123;</span><br><span class="line">                    <span class="built_in">in</span>(l,st[L--],<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(st[L]!=l)st[++L]=l;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">in</span>(st[L<span class="number">-1</span>],st[L],<span class="number">0</span>),L--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x!=st[L])st[++L]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(--L)<span class="built_in">in</span>(st[L],st[L+<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,w;i&lt;n;++i)&#123;</span><br><span class="line">        x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),w=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">in</span>(x,y,w);<span class="built_in">in</span>(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;g[<span class="number">1</span>]=inf;<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">19</span>;++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        k=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)q[j]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HNOI2014-世界树"><a href="#HNOI2014-世界树" class="headerlink" title="HNOI2014 世界树"></a>HNOI2014 世界树</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.luogu.com.cn/problem/P3233">Luogu 3233</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/13/xIdJXToC89ywrPl.png" alt="题目描述"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>先建立虚树，两遍DP找出每个点的控制点，然后在考虑虚树上每一条边的贡献，如果两个顶点属于同一个控制点，直接计算即可，否则二分出控制点不同的位置在计算贡献，注意这一步不应计算端点，否则会导致重复计算，对于没有考虑到的点，其控制点一定在第一个在虚树上的父亲节点上，也要计算在内，最后应注意清空数组。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,q[N],bel[N],a[N],c[N],d[N],dfn[N],f[N][<span class="number">19</span>],ans[N],g1[N],head[N],cnt,st[N],sz[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==y||!x||!y)<span class="keyword">return</span>;</span><br><span class="line">    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> totw=<span class="number">0</span>;</span><br><span class="line">    dfn[x]=++totw;sz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;f[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sz[x]+=sz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];</span><br><span class="line"><span class="comment">//    cout&lt;&lt;f[x][0]&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d[x]+d[y]<span class="number">-2</span>*d[<span class="built_in">lca</span>(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[a]&lt;dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    c[++c[<span class="number">0</span>]]=x;g1[x]=sz[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(!bel[y])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!bel[x])bel[x]=bel[y];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> d1=<span class="built_in">dis</span>(bel[x],x);</span><br><span class="line">            <span class="keyword">int</span> d2=<span class="built_in">dis</span>(bel[y],x);</span><br><span class="line">            <span class="keyword">if</span>(d2&lt;d1||(d2==d1&amp;&amp;bel[y]&lt;bel[x]))bel[x]=bel[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!bel[y])bel[y]=bel[x];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> d1=<span class="built_in">dis</span>(bel[x],y);</span><br><span class="line">            <span class="keyword">int</span> d2=<span class="built_in">dis</span>(bel[y],y);</span><br><span class="line">            <span class="keyword">if</span>(d1&lt;d2||(d1==d2&amp;&amp;bel[x]&lt;bel[y]))bel[y]=bel[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> son=y,mid=y,now,d1,d2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(d[f[son][i]]&gt;d[x])son=f[son][i];</span><br><span class="line">    g1[x]-=sz[son];</span><br><span class="line">    <span class="keyword">if</span>(bel[x]==bel[y])<span class="keyword">return</span> <span class="built_in"><span class="keyword">void</span></span>(ans[bel[x]]+=sz[son]-sz[y]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        now=f[mid][i];</span><br><span class="line">        <span class="keyword">if</span>(d[now]&lt;=d[x])<span class="keyword">continue</span>;</span><br><span class="line">        d1=<span class="built_in">dis</span>(bel[x],now);d2=<span class="built_in">dis</span>(bel[y],now);</span><br><span class="line">        <span class="keyword">if</span>(d2&lt;d1||(d2==d1&amp;&amp;bel[y]&lt;bel[x]))mid=now;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[bel[x]]+=sz[son]-sz[mid];</span><br><span class="line">    ans[bel[y]]+=sz[mid]-sz[y];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+k+<span class="number">1</span>,cmp);cnt=<span class="number">0</span>;c[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)bel[q[i]]=q[i];</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">    st[++L]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[i],l=<span class="built_in">lca</span>(x,st[L]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfn[l]&gt;=dfn[st[L<span class="number">-1</span>]])&#123;</span><br><span class="line">                <span class="built_in">in</span>(l,st[L--]);</span><br><span class="line">                <span class="keyword">if</span>(st[L]!=l)st[++L]=l;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">in</span>(st[L<span class="number">-1</span>],st[L]);L--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x!=st[L])st[++L]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(--L)<span class="built_in">in</span>(st[L],st[L+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=c[0];++i)cout&lt;&lt;bel[c[i]]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c[<span class="number">0</span>];++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=c[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[x];j;j=e[j].ne)</span><br><span class="line">        <span class="built_in">solve</span>(x,e[j].to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c[<span class="number">0</span>];++i)ans[bel[c[i]]]+=g1[c[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[a[i]]);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c[<span class="number">0</span>];++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=c[i];</span><br><span class="line">        head[x]=ans[x]=g1[x]=bel[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">    x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    <span class="keyword">int</span> Q=<span class="built_in">read</span>();</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">19</span>;++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        k=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)a[i]=q[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HEOI2014-大工程"><a href="#HEOI2014-大工程" class="headerlink" title="HEOI2014 大工程"></a>HEOI2014 大工程</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.luogu.com.cn/problem/P4103">Luogu 4103</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/13/x6SE47WdlGiYkrZ.png" alt="题目描述1"></p><p><img src="https://s2.loli.net/2022/01/13/C75pixjwFJe9863.png" alt="题目描述2"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>虚树裸题。但代码量不小，需要处理的东西不少。</p><p>逻辑清晰的实现会让代码难度降低一个等级。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,f[N][<span class="number">21</span>],st[N],dfn[N],q[N],head[N],d[N],cnt,k,vis[N],T,sz[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==y||!x||!y)<span class="keyword">return</span>;</span><br><span class="line">    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> totw=<span class="number">0</span>;</span><br><span class="line">    dfn[x]=++totw;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=fa)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[a]&lt;dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll s[N];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mx=<span class="number">0</span>,mn=inf,mnn[N],mxx[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    s[x]=<span class="number">0</span>;</span><br><span class="line">    sz[x]=(vis[x]==T);</span><br><span class="line">    mnn[x]=(vis[x]==T?<span class="number">0</span>:inf);</span><br><span class="line">    mxx[x]=(vis[x]==T?<span class="number">0</span>:-inf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="built_in">get</span>(y);</span><br><span class="line">        ans+=(s[x]+sz[x]*(d[y]-d[x]))*sz[y]+s[y]*sz[x];</span><br><span class="line">        sz[x]+=sz[y];</span><br><span class="line">        s[x]+=s[y]+(d[y]-d[x])*sz[y];</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,mxx[x]+mxx[y]+d[y]-d[x]);</span><br><span class="line">        mn=<span class="built_in">min</span>(mn,mnn[x]+mnn[y]+d[y]-d[x]);</span><br><span class="line">        mxx[x]=<span class="built_in">max</span>(mxx[x],mxx[y]+d[y]-d[x]);</span><br><span class="line">        mnn[x]=<span class="built_in">min</span>(mnn[x],mnn[y]+d[y]-d[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    head[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+k+<span class="number">1</span>,cmp);cnt=<span class="number">0</span>;++T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)vis[q[i]]=T;</span><br><span class="line">    ans=<span class="number">0</span>;mx=<span class="number">0</span>;mn=inf;</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">    st[++L]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[i],l=<span class="built_in">lca</span>(x,st[L]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[l]&gt;=d[st[L<span class="number">-1</span>]])&#123;</span><br><span class="line">                <span class="built_in">in</span>(l,st[L--]);</span><br><span class="line">                <span class="keyword">if</span>(l!=st[L])st[++L]=l;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">in</span>(st[L<span class="number">-1</span>],st[L]);L--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x!=st[L])st[++L]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(--L)<span class="built_in">in</span>(st[L],st[L+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">get</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %d %d\n&quot;</span>,ans,mn,mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">    x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;dfn[<span class="number">0</span>]=inf;<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">21</span>;++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    <span class="keyword">int</span> Q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        k=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)q[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Virtual Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topcoder SRM553 Div1 YamanoteLine</title>
      <link href="/2017/11/26/Topcoder-SRM553-Div1-YamanoteLine/"/>
      <url>/2017/11/26/Topcoder-SRM553-Div1-YamanoteLine/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/11/26/Topcoder%20SRM553%20div1%201000pts/">原文</a>）</p></div><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>$n$个城市首尾依次通过$n$条非负权边相连。存在两种约束，分别表示从$S$到$T$的顺时针路径小于等于$L$或大于等于$L$，求出$n$条边可能的总权值个数。</p><p>$n&lt;=50$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>根据题目条件易知应按权值前缀和建立差分约束系统，并且二分答案。对于一个节点顺时针走到标号更小节点的情况，应该将当前二分的答案代入式子中进行化简，如果图最短路中存在负环（亦或最长路存在正环），则当前答案不合法，难点主要在此时答案应该增大还是减小上，应将当前二分答案的系数代入环中，判断系数的正负性，如果系数为$0$，则负环与二分值无关，即为无穷多解，如果系数大于$0$，则答案增大时负环权值增大，如果系数小于$0$，则答案减小时负环权值增大。两次二分出可行区间的左右端点，即为所求。（需要注意的是，由于要得到答案在环上的系数，所以当找到负环时，应只返回负环的系数，而不应返回整条路径的系数）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e14</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to,f,fr;ll w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll w,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=y;e[cnt].fr=x;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;e[cnt].f=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YamanoteLine</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ll <span class="title">howMany</span><span class="params">(<span class="keyword">int</span> n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2)</span></span>&#123;</span><br><span class="line">        ll l=n,r=inf,L=<span class="number">-1</span>,R=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();++i)s1[i]++,t1[i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();++i)s2[i]++,t2[i]++;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            ll mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            pair&lt;<span class="keyword">bool</span>,ll&gt;ck=<span class="built_in">can</span>(mid,n,s1,t1,l1,s2,t2,l2);</span><br><span class="line">            <span class="keyword">if</span>(ck.fr||ck.sd&gt;<span class="number">0</span>)l=mid;</span><br><span class="line">            <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        R=l;</span><br><span class="line">        l=n,r=inf;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            pair&lt;<span class="keyword">bool</span>,ll&gt;ck=<span class="built_in">can</span>(mid,n,s1,t1,l1,s2,t2,l2);</span><br><span class="line">            <span class="keyword">if</span>(ck.fr||ck.sd&lt;<span class="number">0</span>)r=mid;</span><br><span class="line">            <span class="keyword">else</span>    l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L=l;</span><br><span class="line">        <span class="keyword">if</span>(L&gt;=n&amp;&amp;R==inf)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> R-L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> q[N],cntx;</span><br><span class="line">    pair&lt;ll,ll&gt; d[N];</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">bool</span>,ll&gt; <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">            pair&lt;ll,ll&gt; t=<span class="built_in">mp</span>(d[x].fr+e[i].w,d[x].sd+e[i].f);</span><br><span class="line">            <span class="keyword">if</span>(d[y].fr&gt;t.fr)&#123;</span><br><span class="line">                q[++cntx]=i;</span><br><span class="line">                d[y]=t;</span><br><span class="line">                <span class="keyword">if</span>(vis[y])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span>(e[q[cntx]].fr!=y)tot+=e[q[cntx]].f,cntx--;</span><br><span class="line">                    tot+=e[q[cntx]].f;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,tot);</span><br><span class="line">                &#125;</span><br><span class="line">                pair&lt;<span class="keyword">bool</span>,ll&gt;res=<span class="built_in">spfa</span>(n,y);</span><br><span class="line">                cntx--;</span><br><span class="line">                <span class="keyword">if</span>(!res.fr)<span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">1</span>,<span class="number">0ll</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">bool</span>,ll&gt; <span class="title">can</span><span class="params">(ll ans,<span class="keyword">int</span> n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=s1[i],y=t1[i];ll w=l1[i];</span><br><span class="line">            <span class="keyword">if</span>(y&gt;x)<span class="built_in">in</span>(y,x,-w,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">in</span>(y,x,ans-w,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=s2[i],y=t2[i];ll w=l2[i];</span><br><span class="line">            <span class="keyword">if</span>(y&gt;x)<span class="built_in">in</span>(x,y,w,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">in</span>(x,y,w-ans,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">in</span>(<span class="number">0</span>,n,ans,<span class="number">1</span>);<span class="built_in">in</span>(n,<span class="number">0</span>,-ans,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">in</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>),<span class="built_in">in</span>(<span class="number">0</span>,i,ans,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)d[i]=<span class="built_in">mp</span>(inf,<span class="number">0</span>);</span><br><span class="line">        d[<span class="number">0</span>]=<span class="built_in">mp</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        cntx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">spfa</span>(n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Difference Constraints </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI2014 购票</title>
      <link href="/2017/09/28/NOIP2014-Ticket/"/>
      <url>/2017/09/28/NOIP2014-Ticket/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/28/NOI2014%E8%B4%AD%E7%A5%A8/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://uoj.ac/problem/7">UOJ 7</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/gzDwUI1qQcJuNTd.png" alt="题目描述1"></p><p><img src="https://s2.loli.net/2022/01/13/ys4FGiYptadAhw9.png" alt="题目描述2"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设$f_x$表示从$x$到根节点的最小花费，易得动态规划方程为:</p><p>$$f_x=min(f_y+(d_x-d_y) * p_x+q_x)$$</p><p>容易观察到该方程具有决策单调性，当x从k转移优于从j转移时推得斜率方程为：</p><p>$$(f_k-f_j)/(d_k-d_j) &lt; p_x$$</p><p>此处便可以通过树分治来计算答案，由于在更新$f_x$时其所有父亲节点都已经处理，所以得到重心后，应先递归深度小的部分，然后处理当前分治结构，再递归深度大的部分。</p><p>对于当前分治结构，应计算重心的所有父亲节点对于子树的贡献（即父亲节点要加入单调栈），考虑到$l_x$的限制，我们可以将需要更新的节点按其所能达到的最浅深度从大到小排序，这样处理不会对单调栈要求删除操作，在得到更新的单调栈后，在凸包上根据斜率方程二分即可得到答案。需要注意由于此处并没有计算重心的贡献，需要特别处理一下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">2e15</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N],n,tp,head[N],cnt;</span><br><span class="line"><span class="keyword">int</span> sz[N],mx[N],tot,rt,q[N],qq[N];</span><br><span class="line">ll p1[N],q1[N],w[N],l[N],d[N],f[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to,w;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l[x]&gt;l[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;mx[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=f&amp;&amp;!vis[e[i].to])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="built_in">getrt</span>(y,x);</span><br><span class="line">        sz[x]+=sz[y];</span><br><span class="line">        mx[x]=<span class="built_in">max</span>(mx[x],sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[x]=<span class="built_in">max</span>(mx[x],tot-sz[x]);</span><br><span class="line">    <span class="keyword">if</span>(mx[x]&lt;mx[rt])rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=f&amp;&amp;!vis[e[i].to])&#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(e[i].to,x);</span><br><span class="line">        sz[x]+=sz[e[i].to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    q[++q[<span class="number">0</span>]]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=f&amp;&amp;!vis[e[i].to])&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(e[i].to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">k</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (db)(f[x]-f[y])/(d[x]-d[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(x,<span class="number">-1</span>);</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">1</span>&amp;&amp;!vis[fa[x]])&#123;</span><br><span class="line">        tot=sz[fa[x]];</span><br><span class="line">        rt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getrt</span>(fa[x],<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">CDQ</span>(y,rt);</span><br><span class="line">    &#125;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;<span class="built_in">dfs2</span>(x,fa[x]);</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+q[<span class="number">0</span>]+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,now=fa[x];i&lt;=q[<span class="number">0</span>];++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=fa[y]&amp;&amp;l[q[i]]&lt;=d[now])&#123;</span><br><span class="line"><span class="comment">//            if(!now)break;</span></span><br><span class="line">            <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">k</span>(qq[top<span class="number">-1</span>],qq[top])&lt;=<span class="built_in">k</span>(qq[top],now))top--;</span><br><span class="line">            qq[++top]=now;now=fa[now];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!top)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=top;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">k</span>(qq[mid],qq[mid+<span class="number">1</span>])&lt;p1[q[i]])r=mid;</span><br><span class="line">            <span class="keyword">else</span>    l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=q[i];</span><br><span class="line">        f[j]=<span class="built_in">min</span>(f[j],f[qq[l]]+(d[j]-d[qq[l]])*p1[j]+q1[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q[<span class="number">0</span>];++i)</span><br><span class="line">    <span class="keyword">if</span>(q[i]!=x&amp;&amp;l[q[i]]&lt;=d[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=q[i];</span><br><span class="line">        f[j]=<span class="built_in">min</span>(f[j],f[x]+(d[j]-d[x])*p1[j]+q1[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(!vis[e[i].to]&amp;&amp;e[i].to!=fa[x])&#123;</span><br><span class="line">        tot=sz[e[i].to];</span><br><span class="line">        rt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getrt</span>(e[i].to,x);</span><br><span class="line">        <span class="built_in">CDQ</span>(e[i].to,rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;ex_ticket2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;ex_ticket2.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    mx[<span class="number">0</span>]=<span class="number">1e9</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld%lld%lld&quot;</span>,&amp;fa[i],&amp;w[i],&amp;p1[i],&amp;q1[i],&amp;l[i]);</span><br><span class="line">        <span class="built_in">in</span>(fa[i],i,w[i]);<span class="built_in">in</span>(i,fa[i],w[i]);</span><br><span class="line">        d[i]=d[fa[i]]+w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)l[i]=d[i]-l[i];</span><br><span class="line">    tot=n;</span><br><span class="line">    <span class="built_in">getrt</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">CDQ</span>(<span class="number">1</span>,rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2013 华容道</title>
      <link href="/2017/09/21/NOIP2013-Sliding-Block/"/>
      <url>/2017/09/21/NOIP2013-Sliding-Block/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/21/NOIP2013%E5%8D%8E%E5%AE%B9%E9%81%93/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P1979">Luogu 1979</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/BVuhOYeHxGfsUQg.png" alt="题目描述1"></p><p><img src="https://s2.loli.net/2022/01/13/qmsiETGcQKhtaou.png" alt="题目描述2"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在本题中，真正可以自由移动的只有空格子，考虑对于指定格子的移动，必然是将空格格子移动到当前节点与目标节点的路径上，并将其于当前节点互换，重复以上过程直到当前节点与目标节点重合，以上过程用普通的BFS即可模拟。</p><p>但是本题中询问次数过多，实际上存在很多重复计算，可以考虑进行预处理优化。</p><p>由于每次都要将空格子移动到当前节点旁边，所以空格子的路径不能经过当前节点，否则将会导致答案不为最少时间，如果空格子的路径必须经过当前节点，则显然无解。（见样例2）那么可以设$f[x][y][k][h]$表示从$(x,y)$的$k$方向节点在不经过$(x,y)$的情况下移动到$h$方向节点的最小时间，对其进行预处理，然后每次询问通过SPFA求解即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">31</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Q,e1,e2,s1,s2,t1,t2;</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">4</span>][<span class="number">4</span>],d[N][N],dis[N][N][<span class="number">5</span>],a[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N][N],in[N][N][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> fx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,k;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;nd&gt;q,q1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">3</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[x1][y1]||!a[x2][y2])<span class="keyword">return</span> inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    nd p;</span><br><span class="line">    d[x1][y1]=<span class="number">0</span>;</span><br><span class="line">    vis[x1][y1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>())q1.<span class="built_in">pop</span>();</span><br><span class="line">    q1.<span class="built_in">push</span>((nd)&#123;x1,y1,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;!vis[x2][y2])&#123;</span><br><span class="line">        p=q1.<span class="built_in">front</span>();q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=p.x+fx[i],y=p.y+fy[i];</span><br><span class="line">            <span class="keyword">if</span>(!vis[x][y]&amp;&amp;a[x][y])&#123;</span><br><span class="line">                vis[x][y]=<span class="number">1</span>;</span><br><span class="line">                d[x][y]=d[p.x][p.y]+<span class="number">1</span>;</span><br><span class="line">                q1.<span class="built_in">push</span>((nd)&#123;x,y,<span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[x2][y2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=m;++t)</span><br><span class="line">    <span class="keyword">if</span>(a[i][t])&#123;</span><br><span class="line">        a[i][t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;<span class="number">4</span>;++h)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h&lt;k)&#123;f[i][t][k][h]=f[i][t][h][k];<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">int</span> x=i+fx[k],y=t+fy[k];</span><br><span class="line">            <span class="keyword">int</span> x11=i+fx[h],y11=t+fy[h];</span><br><span class="line">            <span class="keyword">if</span>(!a[x][y]||!a[x11][y11])<span class="keyword">continue</span>;</span><br><span class="line">            f[i][t][k][h]=<span class="built_in">bfs</span>(x,y,x11,y11)+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;f[i][t][k][h]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[i][t]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> e1,<span class="keyword">int</span> e2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x1==x2&amp;&amp;y1==y2)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a[x1][y1]||!a[x2][y2])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">    a[x1][y1]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>((nd)&#123;x1,y1,k&#125;);</span><br><span class="line">        in[x1][y1][k]=<span class="number">1</span>;</span><br><span class="line">        dis[x1][y1][k]=<span class="built_in">bfs</span>(e1,e2,x1+fx[k],y1+fy[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[x1][y1]=<span class="number">1</span>;</span><br><span class="line">    nd x,y;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        in[x.x][x.y][x.k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;<span class="number">4</span>;++h)&#123;</span><br><span class="line">            y.x=x.x+fx[h],y.y=x.y+fy[h];</span><br><span class="line">            y.k=<span class="built_in">rev</span>(h);</span><br><span class="line">            <span class="keyword">if</span>(dis[y.x][y.y][y.k]&gt;dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h])&#123;</span><br><span class="line">                dis[y.x][y.y][y.k]=dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h];</span><br><span class="line">                <span class="keyword">if</span>(!in[y.x][y.y][y.k])in[y.x][y.y][y.k]=<span class="number">1</span>,q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)ret=<span class="built_in">min</span>(ret,dis[x2][y2][i]);</span><br><span class="line">    <span class="keyword">return</span> ret&lt;inf?ret:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;PuzzleNOIP2013.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;PuzzleNOIP2013.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=m;++t)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][t]);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>,&amp;e1,&amp;e2,&amp;s1,&amp;s2,&amp;t1,&amp;t2);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">spfa</span>(s1,s2,t1,t2,e1,e2));</span><br><span class="line">        dddd:;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4 2</span></span><br><span class="line"><span class="comment">0 1 1 1</span></span><br><span class="line"><span class="comment">0 1 1 0</span></span><br><span class="line"><span class="comment">0 1 0 0</span></span><br><span class="line"><span class="comment">3 2 1 2 2 2</span></span><br><span class="line"><span class="comment">1 2 2 2 3 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 3 1</span></span><br><span class="line"><span class="comment">1 1 0</span></span><br><span class="line"><span class="comment">1 1 0</span></span><br><span class="line"><span class="comment">1 1 0</span></span><br><span class="line"><span class="comment">3 1 1 1 3 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> BFS and DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces852I Dating</title>
      <link href="/2017/09/13/Codeforces-852-I/"/>
      <url>/2017/09/13/Codeforces-852-I/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/13/Codeforces852I/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/contest/852/problem/I">Dating</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/dsz7cRiXGVn3gxm.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>树上莫队裸题，题目大意为给$q$次询问，询问两点之间的链中权值相同的男生个数与女生个数的乘积，并对所有权值求和。</p><p>对于序列中的莫队算法来说，需要对于先对于左区间所在的块为第一关键字，右区间为第二关键字进行查询，树上莫队也不例外。</p><p>首先应该用DFS序表示该树。对于子树的查询，在DFS序中为连续的一段，其求解与序列中的莫队相同，而对于链的查询，其在序列中不为连续的一段，所以需要特殊的处理：</p><ul><li><p>$LCA$为两端点中的任意一个，则应插入$[st[a],st[b]]$区间，容易发现除了链上的点被计算了一遍，其他点都被计算了$0$遍或$2$遍，可以将偶数次的插入视为删除即可。</p></li><li><p>$LCA$不为两节点中的任意一个，此处应插入$[ed[a],st[b]]$区间，计算方法与上文相同，但需要注意此时利用的是DFS序而不是欧拉序，$LCA$实际上没有参与运算，加上即可，单个不在区间中节点的插入对时间复杂度没有影响。</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXB =<span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,n,Q,id[N],f1[N],f2[N],d[N],f[N][MXB],st[N],ed[N],dfx[N*<span class="number">2</span>],totw,block;</span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">2</span>][N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="comment">//int th[N];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ne,to;&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">questions</span>&#123;</span><span class="keyword">int</span> id,m,l,r,b;&#125;q[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(questions a,questions b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.b!=b.b)<span class="keyword">return</span> a.b&lt;b.b;</span><br><span class="line">    <span class="keyword">return</span> a.r&gt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[x]=++totw;dfx[totw]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[x]=++totw;dfx[totw]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MXB<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MXB<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(f[x][i]!=f[y][i])</span><br><span class="line">    x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MXB;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">    f[t][i]=f[f[t][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ll ret=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inq[x]^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(inq[x])</span><br><span class="line">    &#123;</span><br><span class="line">        tong[id[x]][f1[x]]++;</span><br><span class="line">        ret+=tong[id[x]^<span class="number">1</span>][f1[x]];</span><br><span class="line"><span class="comment">//        th[x]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tong[id[x]][f1[x]]--;</span><br><span class="line">        ret-=tong[id[x]^<span class="number">1</span>][f1[x]];</span><br><span class="line"><span class="comment">//        th[x]--;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,id+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,f1+i),f2[i]=f1[i];</span><br><span class="line">    <span class="built_in">sort</span>(f2+<span class="number">1</span>,f2+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> nn=<span class="built_in">unique</span>(f2+<span class="number">1</span>,f2+n+<span class="number">1</span>)-f2<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f1[i]=<span class="built_in">lower_bound</span>(f2+<span class="number">1</span>,f2+nn+<span class="number">1</span>,f1[i])-f2;</span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;++i)cout&lt;&lt;id[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;++i)cout&lt;&lt;f1[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    <span class="built_in">Pre</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=Q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        q[i].id=i;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="built_in">lca</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(st[a]&gt;st[b])<span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(p==a)q[i].l=st[a],q[i].r=st[b],q[i].m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>    q[i].l=ed[a],q[i].r=st[b],q[i].m=p;</span><br><span class="line">        q[i].b=q[i].l/block+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+Q+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=q[i].l,r=q[i].r;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;l)<span class="built_in">insert</span>(dfx[L]),L++;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;l)L--,<span class="built_in">insert</span>(dfx[L]);</span><br><span class="line">        <span class="keyword">while</span>(R&gt;r)<span class="built_in">insert</span>(dfx[R]),R--;</span><br><span class="line">        <span class="keyword">while</span>(R&lt;r)R++,<span class="built_in">insert</span>(dfx[R]);</span><br><span class="line">        <span class="keyword">if</span>(q[i].m)<span class="built_in">insert</span>(q[i].m);</span><br><span class="line"><span class="comment">//        for(int t=1;t&lt;=n;++t)cout&lt;&lt;th[t]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;</span></span><br><span class="line">        ans[q[i].id]=ret;</span><br><span class="line">        <span class="keyword">if</span>(q[i].m)<span class="built_in">insert</span>(q[i].m);</span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;++i)<span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Mo&#39;s Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces856D Masha and Cactus</title>
      <link href="/2017/09/13/Codeforces-856-D/"/>
      <url>/2017/09/13/Codeforces-856-D/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/13/Codeforces856D/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/problemset/problem/856/D">Masha and Cactus</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/MDTaKJcdPbjU6Wz.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目大意为有$n$个点，$m$条带权链，每个点只能被链覆盖一次，问可行覆盖方案的最大权值和。</p><p>该题动态规划方程较容易设计，可以设$f_x$为以$x$为根的子树所能达到的最大权值和，如果没有链以该点为$LCA$，那么$f_x=\sum f_{son}$，否则$f_x= \sum f_{不在链中且父亲节点在链中的子节点}+w$,但是对于第二种情况如果直接暴力找子节点，显然时间复杂度为$O(nq)$，不在可接受范围之内。</p><p>我们可以利用该种子节点的性质来为每个节点赋值，使得$\sum f_{不在链中且父亲节点在链中的子节点}$=$w_{x−&gt;y}$和，从而通过树链剖分来实现$O(logn)$查询。考虑对于每一个已经求出的$f_x$，不妨将$w_{fa_x}+=f_x$，$w_x−=f_x$即可满足条件，理由如下：</p><ul><li><p>对于父亲和自己均在链中的节点，则其贡献被计算了两次，一次为正，一次为负，即为没有贡献。</p></li><li><p>对于父亲和自己均不在链中的节点，则其没有贡献。</p></li><li><p>对于父亲在链中而自己不在链中的节点，其贡献只被计算了一次正值。</p></li><li><p>对于自己的链中而父亲不在链中的节点，显然只有当前节点（即询问节点的LCA），其$w$尚没有赋值。</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,fa[N],st[N],ed[N],top[N],d[N],sz[N],son[N],totw;</span><br><span class="line"><span class="keyword">int</span> a[N],f[N],g[N],X[N],Y[N],W[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne[N*<span class="number">2</span>],to[N*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N],cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;to[++cnt]=y;ne[cnt]=head[x];head[x]=cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));cnt=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;e,e1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=e.head[x];i;i=e.ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e.to[i];</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line"></span><br><span class="line">        sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]]&lt;sz[y])son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[x]=++totw;</span><br><span class="line">    <span class="keyword">int</span> y=son[x];<span class="keyword">if</span>(!y)<span class="keyword">return</span>;</span><br><span class="line">    top[y]=top[x];<span class="built_in">dfs2</span>(y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=e.head[x];i;i=e.ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y=e.to[i];</span><br><span class="line">        <span class="keyword">if</span>(y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        top[y]=y;</span><br><span class="line">        <span class="built_in">dfs2</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[x]=totw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lb</span>(i))a[i]+=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=y;i;i-=<span class="built_in">lb</span>(i))ret+=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x<span class="number">-1</span>;i;i-=<span class="built_in">lb</span>(i))ret-=a[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[top[x]]&lt;d[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        x=fa[top[x]];    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[top[x]]&lt;d[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        ret+=<span class="built_in">sum</span>(st[top[x]],st[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st[x]&gt;st[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    ret+=<span class="built_in">sum</span>(st[x],st[y]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=e.head[x];i;i=e.ne[i])</span><br><span class="line">    <span class="built_in">dp</span>(e.to[i]),g[x]+=f[e.to[i]];</span><br><span class="line">    f[x]=g[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=e1.head[x];i;i=e1.ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to=e1.to[i];</span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],<span class="built_in">query</span>(X[to],Y[to])+W[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(st[x],-f[x]);</span><br><span class="line">    <span class="keyword">if</span>(fa[x])<span class="built_in">insert</span>(st[fa[x]],f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//     freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;c.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]),e.<span class="built_in">in</span>(fa[i],i);</span><br><span class="line">    top[<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">dfs1</span>(<span class="number">1</span>);<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;X[i],&amp;Y[i],&amp;W[i]);</span><br><span class="line">        e1.<span class="built_in">in</span>(<span class="built_in">lca</span>(X[i],Y[i]),i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Chain Subdivision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces787D Legacy</title>
      <link href="/2017/09/13/Codeforces-787-D/"/>
      <url>/2017/09/13/Codeforces-787-D/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/13/Codeforces787D/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/problemset/problem/787/D">Legacy</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Rick and his co-workers have made a new radioactive formula and a lot of bad guys are after them. So Rick wants to give his legacy to Morty before bad guys catch them.</p><p>There are $n$ planets in their universe numbered from $1$ to $n$. Rick is in planet number $s$ (the earth) and he doesn’t know where Morty is. As we all know, Rick owns a portal gun. With this gun he can open one-way portal from a planet he is in to any other planet (including that planet). But there are limits on this gun because he’s still using its free trial.</p><p><img src="https://espresso.codeforces.com/3e33a87e8ba090af9cf4c5a8e27cb131ebefa1c7.png"></p><p>By default he can not open any portal by this gun. There are $q$ plans in the website that sells these guns. Every time you purchase a plan you can only use it once but you can purchase it again if you want to use it more.</p><p>Plans on the website have three types:</p><ul><li><p>With a plan of this type you can open a portal from planet $v$ to planet $u$.</p></li><li><p>With a plan of this type you can open a portal from planet $v$ to any planet with index in range $[l,r]$.</p></li><li><p>With a plan of this type you can open a portal from any planet with index in range $[l,r]$ to planet $v$. </p></li></ul><p>Rick doesn’t known where Morty is, but Unity is going to inform him and he wants to be prepared for when he finds and start his journey immediately. So for each planet (including earth itself) he wants to know the minimum amount of money he needs to get from earth to that planet.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>线段树优化建图，对于向区间连边，可以将区间用线段树的节点表示出来，并从原节点向线段树中的节点建边，再对于线段树中长度为$1$的节点向原节点建边，跑最短路即可，注意对于区间向点建边的操作，需要另建一棵线段树，将上述操作反向进行，否则即默认任意节点之间存在一条长度为$0$的最短路。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">2e18</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,head[N*<span class="number">2</span>],cnt,tot;</span><br><span class="line"></span><br><span class="line">ll d[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ne,to;ll w;&#125;e[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll w)</span></span>&#123;e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls[N],rs[N],id[N],rt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">bool</span> tp,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=++tot;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tp)    <span class="built_in">in</span>(x,l,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">in</span>(l,x,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ls[x]=<span class="built_in">build</span>(tp,l,mid);</span><br><span class="line">        rs[x]=<span class="built_in">build</span>(tp,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="comment">//        cout&lt;&lt;ls[x]&lt;&lt;&quot; &quot;&lt;&lt;rs[x]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(!tp)<span class="built_in">in</span>(x,ls[x],<span class="number">0</span>),<span class="built_in">in</span>(x,rs[x],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">in</span>(ls[x],x,<span class="number">0</span>),<span class="built_in">in</span>(rs[x],x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> fr,<span class="keyword">int</span> L,<span class="keyword">int</span> R,ll d,<span class="keyword">bool</span> tag,<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(!tag)<span class="built_in">in</span>(fr,x,d);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">in</span>(x,fr,d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)<span class="built_in">change</span>(fr,L,R,d,tag,ls[x],l,mid);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)<span class="built_in">change</span>(fr,L,R,d,tag,rs[x],mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">bool</span> tp)</span></span>&#123;rt=<span class="built_in">build</span>(tp,<span class="number">1</span>,n);&#125;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="keyword">bool</span> inq[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)d[i]=inf;</span><br><span class="line">    d[s]=<span class="number">0</span>;inq[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inq[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;d[x]+e[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                d[y]=d[x]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[y])q.<span class="built_in">push</span>(y),inq[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S);</span><br><span class="line">    tot=n;</span><br><span class="line">    t1.<span class="built_in">init</span>(<span class="number">1</span>);</span><br><span class="line">    t2.<span class="built_in">init</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,tp,x,y,l,r,w;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tp);</span><br><span class="line">        <span class="keyword">if</span>(tp==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            <span class="built_in">in</span>(x,y,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tp==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;l,&amp;r,&amp;w);</span><br><span class="line">            t2.<span class="built_in">change</span>(x,l,r,w,<span class="number">0</span>,t2.rt,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tp==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;y,&amp;l,&amp;r,&amp;w);</span><br><span class="line">            t1.<span class="built_in">change</span>(y,l,r,w,<span class="number">1</span>,t1.rt,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%I64d &quot;</span>,(d[i]==inf?<span class="number">-1</span>:d[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 1 1</span></span><br><span class="line"><span class="comment">2 1 2 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces856C Eleventh Birthday</title>
      <link href="/2017/09/11/Codeforces-856-C/"/>
      <url>/2017/09/11/Codeforces-856-C/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/11/Codeforces856C/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/contest/856/problem/C">Eleventh Birthday</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/Yh5vmGfkPeH4RMg.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>根据小学数论知识可知如果该数可被$11$整除，要求其奇数位和与偶数位和在模$11$下同余，那么我们只需要记录通过背包DP出奇数位的和与偶数位的和为$0$时的方案数即可，但是该题中拼到一起的条件对于该数首位是奇数还是偶数是约束的，那么不妨设有$X$个数长度为奇数，$N−X$个数长度为偶数，考虑以下两种情况：</p><ol><li><p>在当前数后拼入奇数长度的数时，下一个拼入的数的首位奇偶性将与该数相异。</p></li><li><p>在当前数后拼入偶数长度的数时，下一个拼入的数的首位奇偶性将与该数相同。</p></li></ol><p>为了简便运算，可以设奇数长度的数每一个数奇数位与偶数位的差为$f_i$，偶数长度的数每一个数奇数位与偶数位的差为$g_i$，那么根据以上两种情况，可知最后拼出的数字的奇偶位差值，一定由$(X+1)/2$个$+f$和$X/2$个$−f$组成，而对于$N−X$个$g$值，其对最后数字的贡献首位奇偶性性任意（即正负号任意）。（需要注意的是，当$X=0$时，此时所有$N$个数的贡献均为正数，又因此这$N$个数的顺序任意，所以答案为$N!$或$0$，该情况特判掉即可）</p><p>对于以上约束，可以在背包时多开一维表示当前加入了几个正的贡献，并且对于$f$与$g$分别进行DP：</p><ol><li><p>$dp[i][j][k]$表示在$f$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。</p></li><li><p>$w[i][j][k]$表示在$g$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。</p></li></ol><p>则dp的最终状态应为$dp[X][(X+1)/2][k]$，对应的$w$的合法状态为$w[N−X][j][11−k]$，累加计算即可，需要注意的是，对于方程的第二维，其加入的顺序可以是任意的，所以要乘以相应的排列。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,t[<span class="number">2</span>],k[N],f[N],q[N];</span><br><span class="line">ll fac[N],dp[<span class="number">2</span>][<span class="number">3001</span>][<span class="number">11</span>],w[<span class="number">2</span>][<span class="number">3001</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)fac[i]=(fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            t[<span class="number">0</span>]=t[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x)</span><br><span class="line">            &#123;</span><br><span class="line">                ++tmp;</span><br><span class="line">                t[tmp&amp;<span class="number">1</span>]+=x%<span class="number">10</span>;</span><br><span class="line">                x/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i]=(t[<span class="number">1</span>]-t[<span class="number">0</span>]+<span class="number">1100</span>)%<span class="number">11</span>;</span><br><span class="line">            k[i]=tmp&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(k[i])q[++q[<span class="number">0</span>]]=i;</span><br><span class="line">        <span class="keyword">if</span>(q[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            tot=(tot+f[i])%<span class="number">11</span>;</span><br><span class="line">            <span class="keyword">if</span>(tot==<span class="number">0</span>)cout&lt;&lt;fac[n]&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span>    cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q[<span class="number">0</span>];++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp[i&amp;<span class="number">1</span>],<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp[i&amp;<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">int</span> x=q[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t1=<span class="number">0</span>;t1&lt;=i;++t1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">11</span>;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(t1!=<span class="number">0</span>)(dp[i&amp;<span class="number">1</span>][t1][k]+=dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][t1<span class="number">-1</span>][(k-f[x]+<span class="number">11</span>)%<span class="number">11</span>]*t1)%=mod;</span><br><span class="line">                <span class="keyword">if</span>(t1!=i)(dp[i&amp;<span class="number">1</span>][t1][k]+=dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][t1][(k+f[x]+<span class="number">11</span>)%<span class="number">11</span>]*(i-t1))%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">1</span>;</span><br><span class="line">        w[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> K=(q[<span class="number">0</span>]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> kk=q[<span class="number">0</span>]-K+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!k[i])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp++;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="built_in">memset</span>(w[x],<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(w[x]));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t1=<span class="number">0</span>;t1&lt;=tmp;++t1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">11</span>;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(t1!=<span class="number">0</span>)(w[x][t1][k]+=w[y][t1<span class="number">-1</span>][(k-f[i]+<span class="number">11</span>)%<span class="number">11</span>]*(kk+(t1<span class="number">-1</span>)))%=mod;</span><br><span class="line">                <span class="keyword">if</span>(t1!=tmp)(w[x][t1][k]+=w[y][t1][(k+f[i]+<span class="number">11</span>)%<span class="number">11</span>]*(K+(tmp-t1<span class="number">-1</span>)))%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n-q[<span class="number">0</span>];++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            (ans+=dp[q[<span class="number">0</span>]&amp;<span class="number">1</span>][K][(<span class="number">11</span>-j)%<span class="number">11</span>]*w[x][i][j])%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces852F Product Transformation</title>
      <link href="/2017/09/06/Codeforces-852-F/"/>
      <url>/2017/09/06/Codeforces-852-F/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/06/Codeforces852F/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/contest/852/problem/F">Product Transformation</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/CD1kuUdSXazHpQM.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>已知数列中的底数全部相等，所以可以将操作看为指数相加，即</p><p>$$S_i=S_i+S_{i+1}$$</p><p>那么以$S_{i,j}$表示处理了几次，递推式如下：</p><p>$$S_{i,j}=S_{i−1,j}+S_{i,j+1}$$</p><p>初始化为$S_{0,j}=1$（即$a$的$1$次方）</p><p>将序列翻转，容易发现其递推式与组合数完全相同，只是初始化有些差异，组合数的初始化为$S_{0,0}=1$。考虑将两者进行转化。</p><p>容易发现，当$S_{0,j}=1(j&lt;1)$时，两者完全相同，而当$S_{0,j}=1(j&lt;2)$时，原式实际变为了杨辉三角形中代表的组合数与其右移一个单位后代表的组合数之和。一般性的，有<br>$S_{i,j}=\sum_{t=0}^{n-1}C_{i,j-t}$,即$S$为$C$的前缀和，那么只要计算出$C(m+1,i−1)$即可。</p><p>但是该题中$n,m$的范围均较大，所以必须用递推阶乘与阶乘逆元的方法求解，考虑题目中实际要对指数进行取模，且有满足$a^P=1(mod  Q)$的最小$P$为质数，那么我们可以暴力求出这个$P$然后将指数对其取模。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,a,mod,rev[N],fac[N],ans[N],P;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,<span class="keyword">int</span> b,ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=ret*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)fac[i]=fac[i<span class="number">-1</span>]*i%P;</span><br><span class="line">    rev[m]=<span class="built_in">qpow</span>(fac[m],P<span class="number">-2</span>,P);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)rev[i]=rev[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;m?<span class="number">0</span>:fac[n]*rev[m]%P*rev[n-m]%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//       2  2  2  7</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">if</span>(mod==<span class="number">1</span>)&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    ll now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        now=now*a%mod;</span><br><span class="line">        <span class="keyword">if</span>(now==<span class="number">1</span>)&#123;P=i;<span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    ans[i]=<span class="built_in">C</span>(m,i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)(ans[i]+=ans[i<span class="number">-1</span>])%=P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans[i]=<span class="built_in">qpow</span>(a,ans[i],mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)<span class="built_in">printf</span>(<span class="string">&quot;%I64d &quot;</span>,ans[i]);</span><br><span class="line"><span class="comment">//static int c[101][101],f[101][101];</span></span><br><span class="line"><span class="comment">//    for(int i=0;i&lt;=10;++i)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        c[i][i]=1;</span></span><br><span class="line"><span class="comment">//        for(int t=1;t&lt;i;++t)</span></span><br><span class="line"><span class="comment">//        c[i][t]=c[i-1][t]+c[i-1][t-1];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=10;++i)f[1][i]=f[i][1]=1;</span></span><br><span class="line"><span class="comment">//    for(int i=2;i&lt;=10;++i)</span></span><br><span class="line"><span class="comment">//    for(int t=2;t&lt;=10;++t)</span></span><br><span class="line"><span class="comment">//    f[i][t]=f[i-1][t]+f[i-1][t-1];</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=10;++i)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        for(int t=1;t&lt;=i;++t)</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;c[i][t]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=10;++i)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        for(int t=1;t&lt;=i;++t)</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;f[i][t]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=10;++i)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        for(int t=1;t&lt;=i;++t)</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;f[i][t]-c[i][t]-c[i][t-1]-c[i][t-2]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces837G Functions on the Segments</title>
      <link href="/2017/09/01/Codeforces-837-G/"/>
      <url>/2017/09/01/Codeforces-837-G/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/09/01/Codeforces837G/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/contest/837/problem/G">Functions On The Segments</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/6qo59BwNpfkSslG.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目大意为给定$n$个函数，求将$x$代入连续的一段函数中所得的值的和，强制在线。</p><p>考虑将求和信息更改为代入$(1,r)$中所得答案与代入$(1,l−1)$所得答案相减，那么问题变可以通过主席树进行实现，每一个函数以下具有两种形式。</p><p>1.</p><p>$y_1, \ if \ x \leq x_1$<br>$b, \ if \ x_1 &lt; x \leq x_2$<br>$y_2, \ if \ x_2 &lt; x$</p><p>2.</p><p>$a * x, \ if \ x_1 &lt; x \leq x_2$</p><p>对于这两种形式各建一颗主席树，分别求和。需要注意该题可以直接将标记永久化，则不需要过于主席树中繁琐的pushdown。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N*<span class="number">81</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> lim = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chairman_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rt[N],lc[M],rc[M];</span><br><span class="line">    ll w[M];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;tot=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=++tot;</span><br><span class="line">        w[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        lc[x]=<span class="built_in">build</span>(l,mid);</span><br><span class="line">        rc[x]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> y1,<span class="keyword">int</span> y2,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=++tot;</span><br><span class="line">        w[y]=w[x];lc[y]=lc[x];rc[y]=rc[x];</span><br><span class="line">        <span class="keyword">if</span>(y1&lt;=l&amp;&amp;y2&gt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            w[y]+=val;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y1&lt;=mid) lc[y]=<span class="built_in">update</span>(lc[x],l,mid,y1,y2,val);</span><br><span class="line">        <span class="keyword">if</span>(y2&gt;mid) rc[y]=<span class="built_in">update</span>(rc[x],mid+<span class="number">1</span>,r,y1,y2,val);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> w[x];</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(lc[x],l,mid,pos)+w[x];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rc[x],mid+<span class="number">1</span>,r,pos)+w[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i) </span><br><span class="line">    &#123;</span><br><span class="line">        T[i].<span class="built_in">init</span>();</span><br><span class="line">        T[i].rt[<span class="number">0</span>]=T[i].<span class="built_in">build</span>(<span class="number">0</span>,lim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx1,xx2,yy1,a,b,yy2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>,&amp;xx1,&amp;xx2,&amp;yy1,&amp;a,&amp;b,&amp;yy2);</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        tmp=T[<span class="number">0</span>].<span class="built_in">update</span>(T[<span class="number">0</span>].rt[i<span class="number">-1</span>],<span class="number">0</span>,lim,<span class="number">0</span>,xx1,yy1);</span><br><span class="line">        tmp=T[<span class="number">0</span>].<span class="built_in">update</span>(tmp,<span class="number">0</span>,lim,xx1+<span class="number">1</span>,xx2,b);</span><br><span class="line">        T[<span class="number">0</span>].rt[i]=T[<span class="number">0</span>].<span class="built_in">update</span>(tmp,<span class="number">0</span>,lim,xx2+<span class="number">1</span>,lim,yy2);</span><br><span class="line">        T[<span class="number">1</span>].rt[i]=T[<span class="number">1</span>].<span class="built_in">update</span>(T[<span class="number">1</span>].rt[i<span class="number">-1</span>],<span class="number">0</span>,lim,xx1+<span class="number">1</span>,xx2,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">        x=(x+ans)%mod;</span><br><span class="line">        <span class="keyword">int</span> lx=<span class="built_in">min</span>(x,lim);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        ans+=T[<span class="number">0</span>].<span class="built_in">query</span>(T[<span class="number">0</span>].rt[r],<span class="number">0</span>,lim,lx)-T[<span class="number">0</span>].<span class="built_in">query</span>(T[<span class="number">0</span>].rt[l<span class="number">-1</span>],<span class="number">0</span>,lim,lx);</span><br><span class="line">        ans+=x*(T[<span class="number">1</span>].<span class="built_in">query</span>(T[<span class="number">1</span>].rt[r],<span class="number">0</span>,lim,lx)-T[<span class="number">1</span>].<span class="built_in">query</span>(T[<span class="number">1</span>].rt[l<span class="number">-1</span>],<span class="number">0</span>,lim,lx));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> w[N],a[N],add[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;w[x]=w[x&lt;&lt;<span class="number">1</span>]+w[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        w[x]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;add[x]+=d;<span class="keyword">return</span>;&#125;</span><br><span class="line">    w[x]+=d*(R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)<span class="built_in">upd</span>(x&lt;&lt;<span class="number">1</span>,l,mid,L,R,d);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)<span class="built_in">upd</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,d);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=add[x]*(R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;<span class="keyword">return</span> ret+w[x];&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)ret+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)ret+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,q,x,y,k;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">            <span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Segment Tree </tag>
            
            <tag> Persistent Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces798E Mike and Code of a Permutation</title>
      <link href="/2017/08/31/Codeforces-798-E/"/>
      <url>/2017/08/31/Codeforces-798-E/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/08/31/Codeforces798E/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/contest/798/problem/E">Mike and code of a permutation</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/IPC9LkbwyGuWHeo.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设$to$数组为给出数组的逆，$ans$为答案数组，那么对于一个$i$有两种约束条件：</p><ol><li><p>$ans[i]&gt;ans[b[i]]$</p></li><li><p>$ans[j] &lt; i \ and \ j &lt; a[i] and \ j!=i)$</p></li></ol><p>此处可以利用查分约束，将关系用边表示然后进行拓扑排序，但遍历所有关系的时间复杂度为$O(n^2)$,无法通过极限数据。可以考虑用线段树进行优化，将第二种关系用线段树进行查询，并模拟原题中的$mark$操作，在遍历后从线段树中删除该点，期望时间复杂度$O(nlogn)$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],head[N],cnt,d[N],to[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ne,to;&#125;e[N*<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;t[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;t[x]=<span class="built_in">max</span>(t[x&lt;&lt;<span class="number">1</span>],t[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;t[x]=<span class="built_in">make_pair</span>(to[l],l);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)<span class="keyword">return</span> t[x];</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ret=<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)    ret=<span class="built_in">max</span>(ret,<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,mid,L,R));</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)    ret=<span class="built_in">max</span>(ret,<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;t[x]=<span class="built_in">make_pair</span>(<span class="number">0</span>,l);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(d&lt;=mid)    <span class="built_in">delet</span>(x&lt;&lt;<span class="number">1</span>,l,mid,d);</span><br><span class="line">        <span class="keyword">else</span>        <span class="built_in">delet</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,d);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    T.<span class="built_in">delet</span>(<span class="number">1</span>,<span class="number">1</span>,n,x);</span><br><span class="line">    <span class="keyword">if</span>(to[x]!=n+<span class="number">1</span>&amp;&amp;!vis[to[x]])<span class="built_in">dfs</span>(to[x]);</span><br><span class="line">    <span class="keyword">if</span>(a[x]&gt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; v=T.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,a[x]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(v.first&gt;x)<span class="built_in">dfs</span>(v.second);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[x]=++tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(a[i]!=<span class="number">-1</span>)    to[a[i]]=i;</span><br><span class="line">    <span class="keyword">else</span>    a[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(!to[i])to[i]=n+<span class="number">1</span>;</span><br><span class="line">    T.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(!vis[i])<span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,d[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Segment Tree </tag>
            
            <tag> Topsort </tag>
            
            <tag> Difference Constraints </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Grand Contest 019 E Shuffle and Swap</title>
      <link href="/2017/08/28/AtCoder-Grand-Contest-019-E/"/>
      <url>/2017/08/28/AtCoder-Grand-Contest-019-E/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/08/28/AtCoder%20Grand%20Contest%20019%20E%20%20Shuffle%20and%20Swap/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://atcoder.jp/contests/agc019/tasks/agc019_e">Shuffle and Swap</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/PEWvxcjXrniHMK1.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目大意为将$A$与$B$中所有为一处的下标分别加入$a$，$b$集合，求有多少种$a$，$b$的排列满足在依次交换$A_{a_i}$，$A{b_i}$后满足$A=B$。</p><p>交换操作实际为将$A$中的$1$调整匹配到$B$中$1$的位置，所以当不存在$A_i=B_i=1$时，不论如何打乱$a$，$b$的排列，在操作后总有$A=B$。当存在$A_i=B_i=1$时，$Ai$的交换有两种情况：</p><p>$A_i$所对应的$B_i$为$1$。</p><p>$A_i$所对应的$B_i$为$0$。</p><p>在进行第一种交换后，如果与$0$进行交换后，需要在操作结束后重新交换回来。那么我们不妨从$A_i$到$B_i$连一条边，易知每一个点出度入度均不超过$1$，且根据以上结论，设$x$为$A_i=B_i=1$的个数，$y$为$A_i!=B_i \ and \ A_i=1$的个数，可知该生成图共有$y$条链，且$x$个点可以作为变换的中转节点加入$y$条链中，那么我们可设$f(i,j)$表示在前$i$条链加入$j$个节点点的方案数，转移方程如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=x;++j)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;++k)</span><br><span class="line">(f[i][j]+=f[i<span class="number">-1</span>][j-k]*rev[k+<span class="number">1</span>])%=mod;(rev[k+<span class="number">1</span>]为k+<span class="number">1</span>阶乘的逆元)</span><br></pre></td></tr></table></figure><p>该DP时间复杂度为$O(n^3)$，期望得分为$1200$。<br>考虑进行优化，观察可知$f[i−1][j−k]×rev[k+1]$为卷积形式，可以用$NTT$进行优化，代码如下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=x*<span class="number">3</span>;++j)a[j]=b[j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=x;++j)a[j]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j],b[j]=rev[j+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NTT</span>(a,b,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=x;++j)f[i&amp;<span class="number">1</span>][j]=a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处观察易知，该方程实质上就是将$f$数组乘了$y$遍$rev$数组，加上快速幂优化即可通过极限数据，期望得分$1700$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;++i)b[i]=rev[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=y;t;t&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t&amp;<span class="number">1</span>)<span class="built_in">NTT</span>(a,b,x,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(b,b,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inv(x) qpow(x,mod-2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> ll G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a1[N],b1[N];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">ll rev[N],fac[N],r[N];</span><br><span class="line">ll a[N],b[N],c[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=(ret*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>,fac[<span class="number">0</span>]=<span class="number">1</span>;i&lt;N;++i)fac[i]=(fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(rev[N<span class="number">-1</span>]=<span class="built_in">inv</span>(fac[N<span class="number">-1</span>]),i=N<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)rev[i]=(rev[i+<span class="number">1</span>]*(i+<span class="number">1</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="keyword">int</span> f,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])<span class="built_in">swap</span>(a[i],a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,t=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,++t)</span><br><span class="line">    &#123;</span><br><span class="line">        ll wn=<span class="built_in">qpow</span>(G,(mod<span class="number">-1</span>)/(<span class="number">1</span>&lt;&lt;t));</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">-1</span>) wn=<span class="built_in">inv</span>(wn);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span>(ll k=<span class="number">0</span>,w=<span class="number">1</span>;k&lt;i;k++,w=w*wn%mod)</span><br><span class="line">        &#123;</span><br><span class="line">            ll x=a[j+k],y=a[j+k+i]*w%mod;</span><br><span class="line">            a[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a,ll *b,ll len,<span class="keyword">bool</span> tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n=<span class="number">1</span>,m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&lt;=<span class="number">2</span>*len)n&lt;&lt;=<span class="number">1</span>,m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)r[i]=r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(<span class="number">1</span>&amp;i)&lt;&lt;(m<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">copy</span>(a,a+x+<span class="number">1</span>,c);<span class="built_in">copy</span>(b,b+x+<span class="number">1</span>,d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ntt</span>(c,<span class="number">1</span>,n);<span class="built_in">ntt</span>(d,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)(c[i]*=d[i])%=mod;</span><br><span class="line">    <span class="built_in">ntt</span>(c,<span class="number">-1</span>,n);ll t=<span class="built_in">inv</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;++i)a[i]=c[i]*t%mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1101011011110</span></span><br><span class="line"><span class="comment">0111101011101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a1+<span class="number">1</span>,b1+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a1+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">    <span class="keyword">if</span>(b1[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;a1[i]==<span class="string">&#x27;1&#x27;</span>)x++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a1[i]==<span class="string">&#x27;1&#x27;</span>)y++;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;++i)b[i]=rev[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=y;t;t&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>)<span class="built_in">NTT</span>(a,b,x,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(b,b,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=x;++i)(ans+=a[i]*fac[x]%mod*fac[y]%mod*fac[x+y])%=mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Fast Fourier Transform </tag>
            
            <tag> Fast Number Theory Transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TYVJ1730 二逼平衡树</title>
      <link href="/2017/06/21/TYVJ1730-Balanced-Tree/"/>
      <url>/2017/06/21/TYVJ1730-Balanced-Tree/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/06/21/%E4%BA%8C%E9%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vNmJNkgPq">COGS 1594</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/13/f4PWwClBMUkbpS1.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题正解有很多种，较常见的为树状数组套主席树，SPLAY套线段树，TREAP套线段树，其中实际时间复杂度最低的是树状数组套主席树和用归并进行可持久化的SPLAY套线段树，而较容易实现的是SPLAY套线段树。</p><p>此处只介绍树状数组套主席树和SPLAY套线段树的方法。</p><h2 id="树状数组套主席树"><a href="#树状数组套主席树" class="headerlink" title="树状数组套主席树"></a>树状数组套主席树</h2><p>区间$K$大，修改数值都是树状数组套主席树所支持的基本操作，而对于操作二，同样可以通过二分答案实现，对于需要前驱后继的操作，可以通过操作一，二结合实现，即先找到该数值的排名$K$，在寻找排名$K−1$或$K+1$的数值，对于数值重复的问题需要根据题目进行特殊判断。</p><h2 id="SPLAY套线段树"><a href="#SPLAY套线段树" class="headerlink" title="SPLAY套线段树"></a>SPLAY套线段树</h2><p>对于每个线段树中代表区间的节点建一颗SPLAY树，存储原数列中下标在该节点包含的区间内的信息，对于每一个下标，需要在$logn$个节点中存储，则实际的SPLAY空间只需要$2nlogn$的大小。对于大多数操作，均可以利用归并的的思想求解，而对于操作二，可以二分答案，找到最小的满足数列中$A[mid]$的排名为$k$的值。</p><p>对于SPLAY来说，其中寻找前驱后继和排名的操作如果每次插入新点的话，将会导致时间复杂度大大提高。所以此处采用的是递归寻找的方法。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pd(i) (i&gt;=<span class="meta-string">&#x27;0&#x27;</span>&amp;&amp;i&lt;=<span class="meta-string">&#x27;9&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N*<span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[M][<span class="number">2</span>],n,m,fa[M],w[M],s[M],L[M],R[M],num[M],root[M],tot,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">pd</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">pd</span>(ch)) t=(t&lt;&lt;<span class="number">3</span>)+(t&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> f*t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;s[x]=s[son[x][<span class="number">0</span>]]+s[son[x][<span class="number">1</span>]]+num[x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],t=son[y][<span class="number">0</span>]==x;</span><br><span class="line">    fa[y]=x;fa[x]=z;</span><br><span class="line">    <span class="keyword">if</span>(z)son[z][son[z][<span class="number">1</span>]==y]=x;</span><br><span class="line">    son[y][!t]=son[x][t];fa[son[x][t]]=y;</span><br><span class="line">    son[x][t]=y;</span><br><span class="line">    <span class="built_in">up</span>(y);<span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(z!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[y][<span class="number">0</span>]==x^son[z][<span class="number">0</span>]==y)<span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span>                        <span class="built_in">rotate</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)root[i]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> f,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++tot;fa[x]=f;</span><br><span class="line">        son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        w[x]=val;s[x]=num[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">splay</span>(i,x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w[x]==val)&#123;s[x]++;num[x]++;<span class="built_in">splay</span>(i,x,<span class="number">0</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">insert</span>(i,son[x][val&gt;w[x]],x,val);</span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root[i];</span><br><span class="line">    <span class="keyword">while</span>(x&amp;&amp;w[x]!=val)x=son[x][val&gt;w[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">get</span>(i,x);<span class="built_in">splay</span>(i,x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(num[x]&gt;<span class="number">1</span>)&#123;num[x]--;s[x]--;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>]*son[x][<span class="number">1</span>]==<span class="number">0</span>)root[i]=son[x][<span class="number">0</span>]+son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=son[x][<span class="number">1</span>];<span class="keyword">while</span>(son[y][<span class="number">0</span>])y=son[y][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">splay</span>(i,y,x);</span><br><span class="line">        fa[son[x][<span class="number">0</span>]]=y;</span><br><span class="line">        son[y][<span class="number">0</span>]=son[x][<span class="number">0</span>];</span><br><span class="line">        root[i]=y;</span><br><span class="line">        son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[root[i]]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">up</span>(root[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L[now]=l;R[now]=r;</span><br><span class="line">    <span class="built_in">insert</span>(now,root[now],<span class="number">0</span>,val);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)     <span class="built_in">build</span>(now*<span class="number">2</span>,l,mid,x,val);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">build</span>(now*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root[i],ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[x]&lt;val)ret+=s[son[x][<span class="number">0</span>]]+num[x],x=son[x][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>    x=son[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrk</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=L[now],r=R[now];</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> <span class="built_in">rk</span>(now,k);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)    ret+=<span class="built_in">getrk</span>(now*<span class="number">2</span>,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)    ret+=<span class="built_in">getrk</span>(now*<span class="number">2</span>+<span class="number">1</span>,x,y,k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=inf;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getrk</span>(<span class="number">1</span>,x,y,mid)+<span class="number">1</span>&lt;=k)</span><br><span class="line">                l=mid;</span><br><span class="line">        <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x,<span class="keyword">int</span> val,<span class="keyword">int</span> __val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=L[now],r=R[now];</span><br><span class="line">    <span class="built_in">delet</span>(now,__val);<span class="built_in">insert</span>(now,root[now],<span class="number">0</span>,val);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)    <span class="built_in">change</span>(now*<span class="number">2</span>,x,val,__val);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">change</span>(now*<span class="number">2</span>+<span class="number">1</span>,x,val,__val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root[i],ret=-inf;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[x]&gt;=val)x=son[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>    ret=<span class="built_in">max</span>(ret,w[x]),x=son[x][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ne</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root[i],ret=inf;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[x]&gt;val)ret=<span class="built_in">min</span>(ret,w[x]),x=son[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>    x=son[x][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpre</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=L[now],r=R[now];</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> <span class="built_in">pre</span>(now,val);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ret=-inf;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)     ret=<span class="built_in">max</span>(ret,<span class="built_in">getpre</span>(now*<span class="number">2</span>,x,y,val));</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)    ret=<span class="built_in">max</span>(ret,<span class="built_in">getpre</span>(now*<span class="number">2</span>+<span class="number">1</span>,x,y,val));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getne</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=L[now],r=R[now];</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> <span class="built_in">ne</span>(now,val);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ret=inf;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)    ret=<span class="built_in">min</span>(ret,<span class="built_in">getne</span>(now*<span class="number">2</span>,x,y,val));</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)    ret=<span class="built_in">min</span>(ret,<span class="built_in">getne</span>(now*<span class="number">2</span>+<span class="number">1</span>,x,y,val));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;psh.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;psh.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    n=<span class="built_in">in</span>();m=<span class="built_in">in</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=<span class="built_in">in</span>();</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,op,x,y,k,pos;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        op=<span class="built_in">in</span>();</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:x=<span class="built_in">in</span>();y=<span class="built_in">in</span>();k=<span class="built_in">in</span>();<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getrk</span>(<span class="number">1</span>,x,y,k)+<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:x=<span class="built_in">in</span>();y=<span class="built_in">in</span>();k=<span class="built_in">in</span>();<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">kth</span>(x,y,k));<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:pos=<span class="built_in">in</span>();k=<span class="built_in">in</span>();<span class="built_in">change</span>(<span class="number">1</span>,pos,k,a[pos]);a[pos]=k;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:x=<span class="built_in">in</span>();y=<span class="built_in">in</span>();k=<span class="built_in">in</span>();<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getpre</span>(<span class="number">1</span>,x,y,k));<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:x=<span class="built_in">in</span>();y=<span class="built_in">in</span>();k=<span class="built_in">in</span>();<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getne</span>(<span class="number">1</span>,x,y,k));<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Balance Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态树总结</title>
      <link href="/2017/06/19/LCT/"/>
      <url>/2017/06/19/LCT/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/06/19/%E5%8A%A8%E6%80%81%E6%A0%91%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>动态树可以维护动态的森林，支持树的合并（LINK），拆分（CUT），动态LCA，换根，和所有树链剖分能支持的操作。动态树与树链剖分的区别在于树链剖分以线段树为基础，而动态树以SPLAY（按深度维护）为基础，这使得动态树相较前者可以支持动态的操作。</p><p>动态树中也有轻重链的概念，但其实现并不基于子树大小，而是在操作的过程中进行修改，使得每次需要操作的链处于同一SPLAY树中。需要特别说明的是，动态树对于子树的操作并不支持，但仍可以通过维护轻链的信息来完成简单点的操作。</p><h1 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h1><p>动态树的核心操作有：</p><p>ACCESS：将x到root的路径变为重链。（将x一步一步向上跳，每次将其变为父亲的重儿子）</p><p>MAKEROOT：将x变为root。（ACCESS(x)并将x旋转到该重链的根，然后对该平衡树进行翻转操作，使得x到root的深度顺序反转。）</p><p>SPLIT：将x与y加入同一颗SPLAY树中。（将x变为根节点，再ACCESS(y)）</p><p>LINK：树的合并。（将x变为所在树的根节点，并将其接到y上。注意son数组记录的是SPLAY中关系，而fa数组记录的是整棵树和SPLAY树的关系。所以此处不需要更新son数组）</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vxmyyVWak">COGS 2701</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/13/E2gwvSuqRpYT1cf.png" alt="题目描述"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题难点在于对于子树大小的查询，在常规的LCT中，只有重儿子的信息。此题可以通过维护轻儿子的信息来实现，本题中SIZE数组维护的是子树大小而不是SPLAY中的信息，VIR数组维护的是轻儿子的信息。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>],mx[N],sum[N],w[N],size[N],rev[N],tag[N],fa[N],vir[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isnotrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> son[fa[x]][<span class="number">0</span>]==x||son[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void add(int x,int val)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    w[x]+=val;mx[x]+=val;</span></span><br><span class="line"><span class="comment">//    sum[x]+=size[x]*val;</span></span><br><span class="line"><span class="comment">//    tag[x]+=val;</span></span><br><span class="line"><span class="comment">//    return;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=son[x][<span class="number">0</span>],r=son[x][<span class="number">1</span>];</span><br><span class="line">    size[x]=size[l]+size[r]+vir[x]+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//    sum[x]=sum[l]+sum[r]+w[x];</span></span><br><span class="line"><span class="comment">//    mx[x]=max(max(mx[l],mx[r]),w[x]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;l=son[x][<span class="number">0</span>],&amp;r=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">        rev[l]^=<span class="number">1</span>;rev[r]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(l,r);</span><br><span class="line">        rev[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if(tag[x])</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        add(son[x][0],tag[x]);</span></span><br><span class="line"><span class="comment">//        add(son[x][1],tag[x]);</span></span><br><span class="line"><span class="comment">//        tag[x]=0; </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(fa[x]);<span class="built_in">down</span>(x);</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],t=(son[y][<span class="number">0</span>]==x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isnotrt</span>(y)) son[z][son[z][<span class="number">1</span>]==y]=x;fa[x]=z;</span><br><span class="line">    son[y][!t]=son[x][t];fa[son[y][!t]]=y;</span><br><span class="line">    son[x][t]=y;fa[y]=x;</span><br><span class="line">    <span class="built_in">up</span>(y);<span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isnotrt</span>(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isnotrt</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[y][<span class="number">0</span>]==x^son[z][<span class="number">0</span>]==y)<span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">rotate</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">        vir[x]-=size[y];</span><br><span class="line">        vir[x]+=size[son[x][<span class="number">1</span>]];</span><br><span class="line">        son[x][<span class="number">1</span>]=y;</span><br><span class="line">        <span class="built_in">up</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="built_in">access</span>(x);<span class="built_in">splay</span>(x);rev[x]^=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="built_in">makert</span>(x);<span class="built_in">access</span>(y);<span class="built_in">splay</span>(x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="built_in">makert</span>(y);fa[y]=x;vir[x]+=size[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="built_in">split</span>(x,y);son[x][<span class="number">1</span>]=fa[y]=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="built_in">access</span>(x);<span class="built_in">splay</span>(x);<span class="keyword">while</span>(son[x][<span class="number">0</span>])x=son[x][<span class="number">0</span>];<span class="keyword">return</span> x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dynamic_tree.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dynamic_tree.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)size[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,opt,x,y,z;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;opt,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="built_in">makert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">access</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,vir[x]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);<span class="keyword">int</span> z=<span class="built_in">find</span>(x);<span class="built_in">link</span>(x,y);<span class="built_in">makert</span>(z);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 11</span></span><br><span class="line"><span class="comment">3 2 3</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">3 2 4</span></span><br><span class="line"><span class="comment">3 6 2</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 1 2</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="HNOI2010-弹飞绵羊"><a href="#HNOI2010-弹飞绵羊" class="headerlink" title="HNOI2010 弹飞绵羊"></a>HNOI2010 弹飞绵羊</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vQxQSkeUP">COGS 1689</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/13/NZn4faJjieURSAK.png" alt="题目描述"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>由于每个点的目标节点唯一，所以可以将其看为倒置的一棵树。设立一个哨兵节点$n+1$，每个会弹出去的位置都指向哨兵节点。</p><p>那么每次查询实际上就是求$x$到根节点的链的长度，可以将链加入同一颗SPLAY中，然后查询SPLAY大小即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k[N],n,m,son[N][<span class="number">2</span>],fa[N],size[N],sum[N],rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;size[x]=size[son[x][<span class="number">0</span>]]+size[son[x][<span class="number">1</span>]]+<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">        rev[x]^=<span class="number">1</span>;</span><br><span class="line">        rev[son[x][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">        rev[son[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> son[fa[x]][<span class="number">0</span>]!=x&amp;&amp;son[fa[x]][<span class="number">1</span>]!=x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(fa[x]);<span class="built_in">down</span>(x);</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],t=son[y][<span class="number">0</span>]==x;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isrt</span>(y))son[z][son[z][<span class="number">1</span>]==y]=x;fa[x]=z;</span><br><span class="line">    son[y][!t]=son[x][t];fa[son[x][t]]=y;</span><br><span class="line">    son[x][t]=y;fa[y]=x;</span><br><span class="line">    <span class="built_in">up</span>(y);<span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isrt</span>(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isrt</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[y][<span class="number">0</span>]==x^son[z][<span class="number">0</span>]==y)<span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">rotate</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])</span><br><span class="line">    &#123;<span class="built_in">splay</span>(x);son[x][<span class="number">1</span>]=y;<span class="built_in">up</span>(x);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="built_in">access</span>(x);<span class="built_in">splay</span>(x);rev[x]^=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="built_in">makert</span>(x);<span class="built_in">access</span>(y);<span class="built_in">splay</span>(x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="built_in">makert</span>(x);fa[x]=y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="built_in">split</span>(x,y);son[x][<span class="number">1</span>]=fa[y]=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;bzoj_2002.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;bzoj_2002.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k[i]);</span><br><span class="line">        <span class="keyword">if</span>(k[i]+i&gt;=n+<span class="number">1</span>)k[i]=n+<span class="number">1</span>-i;</span><br><span class="line">        <span class="built_in">link</span>(i,i+k[i]);</span><br><span class="line">        size[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,val;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">makert</span>(n+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">makert</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,size[x]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">            <span class="built_in">cut</span>(x,x+k[x]);</span><br><span class="line">            k[x]=val;</span><br><span class="line">            <span class="keyword">if</span>(k[x]+x&gt;=n+<span class="number">1</span>)k[x]=n+<span class="number">1</span>-x;</span><br><span class="line">            <span class="built_in">link</span>(x,x+k[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Link Cut Tree </tag>
            
            <tag> Balance Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性基总结</title>
      <link href="/2017/06/17/Linear-Basis/"/>
      <url>/2017/06/17/Linear-Basis/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/06/17/%E7%BA%BF%E6%80%A7%E5%9F%BA%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><p>线性基能够接受$n$个数，并判定这些数是否能通过按位亦或和的方式表示出某个数，更能进一步表示出按位亦或和的第$K$小。线性基是一种另类的向量。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="张成"><a href="#张成" class="headerlink" title="张成"></a>张成</h2><p>对于一个集合$S$，其张成定义为其中所有子集的异或和，记为$span(S)$。</p><p>根据异或的性质，易知其张成满足或存在：</p><p>封闭性：对于任何两个元素，其异或和唯一。</p><p>结合律：$(a \ xor \ b) \ xor \ c=a \ xor \ (b \ xor \ c)$。</p><p>单位元：$e=0$且$e \ xor \ a=a$。</p><p>逆元:$a \ xor \ a=e$。</p><p>则$span(S)$构成一个群。</p><h2 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h2><p>对于一个集合$S$，如果存在一个元素$S_j$，使得$S$在去除这个元素后得到的集合$S′$的张成不变，则称集合$S$线性相关，相应的，如果不存在这样的元素，则集合$S$线性无关。</p><p>线性基对于一个集合$S$，其线性基定义为满足线性无关的情况下的$span(S)$最小的子集，可以记为$span(S)′$，则有$span(span(S)′)$与$span(S)$等价。</p><h1 id="线性基的构造"><a href="#线性基的构造" class="headerlink" title="线性基的构造"></a>线性基的构造</h1><p>线性基的构造可以通过高斯消元或者一种类似贪心的算法完成，后者支持动态操作，所以在此处着重介绍。</p><p>已知集合$S$中最大的数在二进制意义下有$L$ 位，我们使用一个 $a[0…L]$来储存线性基，则该线性基的元素个数为$L$。</p><p>对于$a$数组，需要保证以下性质：</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>$$a_i=0$$</p><p>则只有满足$j&gt;i$的$a_j$的第$i$个二进制位可能为$1$；（性质一）</p><p>$$a_i≠0$$</p><p>整个$a$数组中只有$a_i$的第$i$个二进制位为$1$；（性质二）</p><p>$a_i$更高的二进制位一定为$0$；（性质三）</p><p>$a_i$更低的二进制位可能为$1$；</p><p>对于异或最大和的问题，我们可以通过贪心求解，即从高位到低位枚举是否有元素的二进制当前位为$1$，如果有，则亦或上该元素，而该构造方法则可以类比于上述操作中将该元素记录下来，而下文中构造的操作，同样保证了每一个元素均可以由线性基构造出来。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>对于每个新加入的元素$t$，从$L$枚举其二进制每一位$i$</p><p>$$ai≠0$$</p><p>那么将$t$异或上$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得$t$为$1$的位数尽可能少，并满足以上性质一以及性质二，且如果新插入一个元素已经在当前线性基的张成中，则在该操作后元素变为$0$）</p><p>$$ai=0$$</p><p>那么将$a$数组中每一个下标大于$i$且第$i$位为$1$的元素异或上$t$。将$t$异或上$a$数组中每一个下标小于$i$且第$i$位为$1$的元素。并将$t$插入$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得数组中二进制$1$的个数尽可能少）</p><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="最大异或和"><a href="#最大异或和" class="headerlink" title="最大异或和"></a>最大异或和</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>直接套用线性基即可，如上所述，线性基实际上将贪心求解异或最大值的过程记录了下来，那么直接异或上所有线性基数组的值即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">55</span>;</span><br><span class="line">ll B[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; V;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MAXN<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((x&amp;(<span class="number">1LL</span>&lt;&lt;i))==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(B[i]) x^=B[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x&amp;(<span class="number">1LL</span>&lt;&lt;j))</span><br><span class="line">                    x^=B[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;MAXN;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(B[j]&amp;(<span class="number">1LL</span>&lt;&lt;i))</span><br><span class="line">                    B[j]^=x;</span><br><span class="line">            &#125;</span><br><span class="line">            B[i]^=x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qry</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1LL</span>&lt;&lt;i))</span><br><span class="line">            s^=V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x),<span class="built_in">insert</span>(x);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;++i)</span><br><span class="line">    <span class="keyword">if</span>(B[i])V.<span class="built_in">push_back</span>(B[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V.<span class="built_in">size</span>();++i)cnt^=V[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K小异或和"><a href="#K小异或和" class="headerlink" title="K小异或和"></a>K小异或和</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>以下分别表示所有的异或和的可能性，按从小到大顺序排序（$L=3$,以下第一列数字表示$a$数组的下标）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                     二进制表示</span><br><span class="line"></span><br><span class="line">1                    第1小            1</span><br><span class="line"></span><br><span class="line">2                    第2小            10</span><br><span class="line"></span><br><span class="line">1  xor  2            第3小            11</span><br><span class="line"></span><br><span class="line">3                    第4小            100</span><br><span class="line"></span><br><span class="line">1  xor  3            第5小            101</span><br><span class="line"></span><br><span class="line">2  xor  3            第6小            110</span><br><span class="line"></span><br><span class="line">1  xor  2  xor  3    第7小            111</span><br></pre></td></tr></table></figure><p> 观察可知，$K$小异或和即为$K$的二进制分解中为$1$的位置在$a$中作为下标的线性基的异或和。</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">55</span>;</span><br><span class="line">ll B[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; V;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MAXN<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((x&amp;(<span class="number">1LL</span>&lt;&lt;i))==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(B[i]) x^=B[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x&amp;(<span class="number">1LL</span>&lt;&lt;j))</span><br><span class="line">                    x^=B[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;MAXN;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(B[j]&amp;(<span class="number">1LL</span>&lt;&lt;i))</span><br><span class="line">                    B[j]^=x;</span><br><span class="line">            &#125;</span><br><span class="line">            B[i]^=x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qry</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1LL</span>&lt;&lt;i))</span><br><span class="line">            s^=V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x),<span class="built_in">insert</span>(x);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;++i)</span><br><span class="line">    <span class="keyword">if</span>(B[i])V.<span class="built_in">push_back</span>(B[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(V.<span class="built_in">size</span>()!=n) --x;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=(<span class="number">1LL</span>&lt;&lt;V.<span class="built_in">size</span>())) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>     <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qry</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HAOI2017-八纵八横"><a href="#HAOI2017-八纵八横" class="headerlink" title="HAOI2017 八纵八横"></a>HAOI2017 八纵八横</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>非常非常具有代表性的一个题目。</p><p>在$dfs$树上，一条非树边代表一个简单环，所以一个新增的边最多带来一个新环，而这个新环，肯定是经过这条新边，从$x$走到$y$，再走回$x$的路径所构成的一个环。因为$xor$的特性，所以我们可以用$x$到$root$的路径 + $y$到$root$的路径 + 新边来异或出这个环的异或值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">1</span>;</span><br><span class="line">bitset&lt;1024&gt;a,e2[N],v[N],M[N],mat[N],dis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,Q,head[N],cnt,cnt1,fa[N],e1[N][<span class="number">2</span>],now,huan[N];</span><br><span class="line"><span class="keyword">char</span> opt[N],ch[N];</span><br><span class="line"><span class="function">bitset&lt;1024&gt; <span class="title">readb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;1024&gt;t;t.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">    t[len-i<span class="number">-1</span>]=ch[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ne,to;bitset&lt;1024&gt;w;&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,bitset&lt;<span class="number">1024</span>&gt;w)</span></span></span><br><span class="line"><span class="function"></span>&#123;e[++cnt].to=y;e[cnt].w=w;e[cnt].ne=head[x];head[x]=cnt;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">gf</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    <span class="keyword">if</span>(e[i].to!=f)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[e[i].to]=dis[x]^e[i].w;  </span><br><span class="line">        <span class="built_in">dfs</span>(e[i].to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,bitset&lt;<span class="number">1024</span>&gt;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    <span class="keyword">if</span>(M[i][x]&amp;&amp;mat[i].<span class="built_in">none</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        now=i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!now)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    <span class="keyword">if</span>(M[huan[i]][x]&amp;&amp;huan[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        now=huan[i];</span><br><span class="line">        huan[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    <span class="keyword">if</span>(now!=i&amp;&amp;M[i][x])</span><br><span class="line">    &#123;</span><br><span class="line">        mat[i]=mat[i]^mat[now];</span><br><span class="line">        M[i]=M[i]^M[now];</span><br><span class="line">    &#125;</span><br><span class="line">    mat[now]^=y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(mat[now][i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!huan[i])&#123;huan[i]=now;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> mat[now]=mat[now]^mat[huan[i]],M[now]=M[now]^M[huan[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;1024&gt;ans;</span><br><span class="line">    ans.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(ans[i]==<span class="number">0</span>&amp;&amp;huan[i])</span><br><span class="line">    ans^=mat[huan[i]];</span><br><span class="line">    <span class="keyword">char</span> *tmp,tong[N];</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">none</span>()) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp=tong;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(ans[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            *(tmp++)=ans[j]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(tmp++)=<span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">        <span class="built_in">puts</span>(tong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;eights.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;eights.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)M[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a=<span class="built_in">readb</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">gf</span>(x)==<span class="built_in">gf</span>(y))</span><br><span class="line">        &#123;</span><br><span class="line">            e1[++cnt1][<span class="number">0</span>]=x;</span><br><span class="line">            e1[cnt1][<span class="number">1</span>]=y;</span><br><span class="line">            v[cnt1]=a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        fa[<span class="built_in">gf</span>(x)]=<span class="built_in">gf</span>(y),<span class="built_in">in</span>(x,y,a),<span class="built_in">in</span>(y,x,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> cntn=cnt1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)</span><br><span class="line">    <span class="built_in">update</span>(i,dis[e1[i][<span class="number">0</span>]]^dis[e1[i][<span class="number">1</span>]]^v[i]);</span><br><span class="line">    <span class="built_in">put</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=Q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,opt);</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">1</span>]==<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            a=<span class="built_in">readb</span>();</span><br><span class="line">            e1[++cnt1][<span class="number">0</span>]=x;e1[cnt1][<span class="number">1</span>]=y,e2[cnt]=a;</span><br><span class="line">            v[cnt1]=a;</span><br><span class="line">            <span class="built_in">update</span>(cnt1,dis[e1[cnt1][<span class="number">0</span>]]^dis[e1[cnt1][<span class="number">1</span>]]^v[cnt1]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">1</span>]==<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            a=<span class="built_in">readb</span>();</span><br><span class="line">            <span class="built_in">update</span>(x+cntn,v[x+cntn]^a);</span><br><span class="line">            v[x+cntn]=a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">1</span>]==<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">update</span>(x+cntn,dis[e1[x+cntn][<span class="number">0</span>]]^dis[e1[x+cntn][<span class="number">1</span>]]^v[x+cntn]);</span><br><span class="line">            v[x+cntn]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Linear Basis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces811E Vladik and Entertaining Flags</title>
      <link href="/2017/06/08/Codeforces811E-Vladik/"/>
      <url>/2017/06/08/Codeforces811E-Vladik/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/06/08/Codeforces811E/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://codeforces.com/contest/811/problem/E">Vladik and Entertaining Flags</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/FNgP8xJrMHlCSYm.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑到$n$的范围较小，可以直接通过并查集暴力每一列的联通性，每次询问通过归并查询，可以先用线段树预处理以降低时间复杂度。</p><p>$ls，rs$数组表示当前需要合并的$[l,r]$的左右两边的连通性，归并时向上更新，$l,r$数组表示线段树当前节点的$[l,r]$的连通性，需要提前预处理。对于合并操作，考虑需要合并的两个区间，连通性改变的部分只有两个区间相邻的部分，同样可以通过并查集暴力求解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>][N],l[N*<span class="number">2</span>][<span class="number">13</span>],sum[N*<span class="number">2</span>],r[N*<span class="number">2</span>][<span class="number">13</span>],rs[<span class="number">11</span>],ls[<span class="number">11</span>],n,m,cnt,q;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">13</span>*N*<span class="number">2</span>],flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> f[x]==x?x:f[x]=<span class="built_in">gf</span>(f[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls=x*<span class="number">2</span>,rs=x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    sum[x]=sum[ls]+sum[rs];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[l[ls][i]]=l[ls][i];</span><br><span class="line">        f[r[rs][i]]=r[rs][i];</span><br><span class="line">        f[l[rs][i]]=l[rs][i];</span><br><span class="line">        f[r[ls][i]]=r[ls][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(a[i][mid]==a[i][mid+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1=<span class="built_in">gf</span>(l[rs][i]),t2=<span class="built_in">gf</span>(r[ls][i]);</span><br><span class="line">        <span class="keyword">if</span>(t1!=t2)</span><br><span class="line">        &#123;</span><br><span class="line">            f[t1]=t2;</span><br><span class="line">            sum[x]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    l[x][i]=<span class="built_in">gf</span>(l[ls][i]),r[x][i]=<span class="built_in">gf</span>(r[rs][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll==rr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i][ll]==a[i<span class="number">-1</span>][ll])l[x][i]=r[x][i]=l[x][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span>    l[x][i]=r[x][i]=++cnt,sum[x]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ll,mid,x*<span class="number">2</span>);<span class="built_in">build</span>(mid+<span class="number">1</span>,rr,x*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(ll,rr,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lss=now*<span class="number">2</span>,rss=now*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=ll&amp;&amp;rr&lt;=y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ls[i]=l[now][i],rs[i]=r[now][i];</span><br><span class="line">            <span class="keyword">return</span> sum[now];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret=sum[now];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[ls[i]]=ls[i];</span><br><span class="line">            f[rs[i]]=rs[i];</span><br><span class="line">            f[l[now][i]]=l[now][i];</span><br><span class="line">            f[r[now][i]]=r[now][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][ll]==a[i][ll<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t1=<span class="built_in">gf</span>(rs[i]),t2=<span class="built_in">gf</span>(l[now][i]);</span><br><span class="line">                <span class="keyword">if</span>(t1!=t2)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[t2]=t1;</span><br><span class="line">                    ret--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ls[i]=<span class="built_in">gf</span>(ls[i]),rs[i]=<span class="built_in">gf</span>(r[now][i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) ret+=<span class="built_in">mergesort</span>(ll,mid,x,y,now*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;y)    ret+=<span class="built_in">mergesort</span>(mid+<span class="number">1</span>,rr,x,y,now*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=m;++t)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][t]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,ll,rr;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ll,&amp;rr);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">mergesort</span>(<span class="number">1</span>,m,ll,rr,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化线段树总结</title>
      <link href="/2017/06/07/Persistent-Segment-Tree/"/>
      <url>/2017/06/07/Persistent-Segment-Tree/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/06/07/%E4%B8%BB%E5%B8%AD%E6%A0%91%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>主席树又称可持久化线段树，相对与普通的线段树，其解决的是各种不适用于结合律的区间问题，诸如区间第$K$大，区间种类个数等。</p><p>线段树的每个结点，保存的是这个区间含有的数字的性质的结合。</p><p>主席树的每个结点，保存的元素以元素大小为第一维位置，同时保证以区间为第二维位置，直接实现是$O(nlog^2n)$的时间空间复杂度，即每一个区间都要建一棵树，考虑每颗线段树的大小和形态是一样的，那么我们便可以利用主席树之间相互进行加减运算的性质，进行可持久化建树。</p><p>具体过程是按区间位置进行建树，每次插入新的数，只需要重新插入一条链，因为对于那些性质没有改变的前缀（如插入元素的位置是$3$，那么节点：$[1,2]$就没有必要改变），只需要重新调用皆可，否则利用原节点建一个新的节点（如插入元素的位置是$3$，那么节点：$[3,4]$的性质一定发生了改变，但又要保证原区间的该节点性质不变，那么便可以先将该节点粘过来，再在此基础上建一个新的节点，插入在当前根节点下），这样时间空间复杂度均降到了$O(nlogn)$（可持久化线段树按权值建树，其时间复杂度实际与权值范围有关（所以要离散化），本文全部以$n$代替）。</p><p>当然，这样实现也会导致整个数据结构实际上完全不是一棵树了，但是却仍满足每个节点最多有两个后继的限制，因此查询时只要调用$l−1,r$两个根节点即可。</p><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="NEERC-2004-K小数"><a href="#NEERC-2004-K小数" class="headerlink" title="NEERC 2004 K小数"></a>NEERC 2004 K小数</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vNyzJkgjq">COGS 1534</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/uPagd2bSBC1wA79.png" alt="题目描述"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>实现与按权值维护的平衡树类似，直接递归查询即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,totn,a[N],b[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ls,rs,sum;&#125;t[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> tot,root[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y=++tot;</span><br><span class="line">    t[y]=t[x];t[y].sum+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;=mid)     <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,v);</span><br><span class="line">    <span class="keyword">else</span>         <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v=t[t[y].ls].sum-t[t[x].ls].sum;</span><br><span class="line">    <span class="keyword">if</span>(v&gt;=k)     <span class="keyword">return</span> <span class="built_in">get</span>(l,mid,t[x].ls,t[y].ls,k);</span><br><span class="line">    <span class="keyword">else</span>         <span class="keyword">return</span> <span class="built_in">get</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k-v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;kthnumber.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;kthnumber.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    totn=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="built_in">insert</span>(<span class="number">1</span>,totn,root[i<span class="number">-1</span>],root[i],<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>,a[i])-b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z),</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[<span class="built_in">get</span>(<span class="number">1</span>,totn,root[x<span class="number">-1</span>],root[y],z)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDOI2009-HH的项链"><a href="#SDOI2009-HH的项链" class="headerlink" title="SDOI2009 HH的项链"></a>SDOI2009 HH的项链</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=pJSmJNqVk">COGS 421</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/LGKbWFM2973pHgl.png" alt="题目描述"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>对于每一个元素，记录其在数列内下一个种类相同的元素的位置（以 $to$ 数组表示），那么问题就转化为了求区间内有多少个元素的 $to$ 值大于查询的右区间位置，将 $to$ 数组插入到主席树中，直接建树求解即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> rs,ls,sum;&#125;t[N*<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],tot,b[N],totn,n,m,root[N],vis[N],to[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y=++tot;</span><br><span class="line">    t[y]=t[x];</span><br><span class="line">    t[y].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)    <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,k);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;v)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=v)<span class="keyword">return</span> t[y].sum-t[x].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(l,mid,t[x].ls,t[y].ls,v)+<span class="built_in">get</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;diff.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;diff.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(vis[x])to[vis[x]]=i;</span><br><span class="line">        vis[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(!to[i])to[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>,n+<span class="number">1</span>,root[i<span class="number">-1</span>],root[i],to[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(<span class="number">1</span>,n+<span class="number">1</span>,root[l<span class="number">-1</span>],root[r],r+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态排名系统"><a href="#动态排名系统" class="headerlink" title="动态排名系统"></a>动态排名系统</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=pxQyzzVgW">COGS 257</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/TzIO5qZslLu9WKX.png" alt="题目描述"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>本题为裸的带修改区间第$K$大，如果直接在例$1$的基础上修改，则会导致超时，因为每次修改都要修改$nlogn$个节点，即最坏情况下每一个根都要修改$log$个没有指向前面节点的节点。那么可以考虑，主席树维护的实际上是数列的前缀的性质，可以利用树状数组优化，即将原先的对于每一个新元素的前缀建树，改为对于树状数组中的前缀建树，那么修改时只要修改$log^2n$个节点即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ls,rs,sum;&#125;t[N];</span><br><span class="line"><span class="keyword">int</span> T,n,m,A[N],B[N],C[N],b[N],a[N],X[N],Y[N],root[N],totx,toty,totn,tot;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y=++tot;</span><br><span class="line">    t[y]=t[x];</span><br><span class="line">    t[y].sum+=v;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)    <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,k,v);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k,v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>,a[x])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>,totn,root[i],root[i],k,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totx;++i)sum-=t[t[X[i]].ls].sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=toty;++i)sum+=t[t[Y[i]].ls].sum;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X[i]].ls;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y[i]].ls;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l,mid,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X[i]].rs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y[i]].rs;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dynrank.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dynrank.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(C));</span><br><span class="line">        totn=tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i),b[++totn]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s,A+i,B+i);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,C+i);</span><br><span class="line">            <span class="keyword">else</span>            b[++totn]=B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>);</span><br><span class="line">        totn=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+totn+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span>(C[i])</span><br><span class="line">        &#123;</span><br><span class="line">            totx=toty=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i]<span class="number">-1</span>;j;j-=<span class="built_in">lowbit</span>(j))X[++totx]=root[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=B[i];j;j-=<span class="built_in">lowbit</span>(j))    Y[++toty]=root[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[<span class="built_in">query</span>(<span class="number">1</span>,totn,C[i])]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">-1</span>);</span><br><span class="line">            a[A[i]]=B[i];</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="国家集训队2011-数颜色"><a href="#国家集训队2011-数颜色" class="headerlink" title="国家集训队2011 数颜色"></a>国家集训队2011 数颜色</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vNNmNkPak">COGS 1901</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://s2.loli.net/2022/01/12/OGpCSVIrtsglvd5.png" alt="题目描述"></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>同样是记录 $to$ 数组，对于修改操作，可以暴力求出修改后该位置 $to$ 的变化，考虑一下可能造成的在该元素前的元素的 $to$ 指针的变化即可（注意同样要修改主席树），详见代码。（对于$to$数组的查询和修改可以用平衡树优化）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span>ll ls,rs,sum;&#125;t[N*<span class="number">600</span>];</span><br><span class="line">ll n,m,a[N],b[N],X[<span class="number">55</span>],Y[<span class="number">55</span>],A[N],B[N],C[N],to[N],vis[<span class="number">1000001</span>];</span><br><span class="line">ll root[N],totn,tot,totx,toty;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll l,ll r,ll x,ll &amp;y,ll k,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!y)&#123;y=++tot;t[y]=t[x];&#125;</span><br><span class="line">    t[y].sum+=v;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)    <span class="built_in">insert</span>(l,mid,t[x].ls,t[y].ls,k,v);</span><br><span class="line">    <span class="keyword">else</span>        <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,t[x].rs,t[y].rs,k,v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=x;i&lt;=n+<span class="number">1</span>;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">1</span>,n+<span class="number">1</span>,root[i],root[i],to[x],v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll l,ll r,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;v)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=v)</span><br><span class="line">    &#123;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)sum-=t[X[i]].sum;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)sum+=t[Y[i]].sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ll X1[<span class="number">55</span>],Y1[<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)X1[i]=X[i];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)Y1[i]=Y[i];</span><br><span class="line"></span><br><span class="line">    ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X1[i]].ls;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y1[i]].ls;</span><br><span class="line">    sum+=<span class="built_in">get</span>(l,mid,v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=totx;++i)X[i]=t[X1[i]].rs;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=toty;++i)Y[i]=t[Y1[i]].rs;</span><br><span class="line">    sum+=<span class="built_in">get</span>(mid+<span class="number">1</span>,r,v);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;nt2011_color.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;nt2011_color.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,x;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[i]=x;</span><br><span class="line">        <span class="keyword">if</span>(vis[x])to[vis[x]]=i;</span><br><span class="line">        vis[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(!to[i])to[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s,A+i,B+i);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> C[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    sort(b+1,b+totn+1);</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        totx=toty=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(C[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(X,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(X));</span><br><span class="line">            <span class="built_in">memset</span>(Y,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Y));</span><br><span class="line">            <span class="keyword">for</span>(ll j=A[i]<span class="number">-1</span>;j;j-=<span class="built_in">lowbit</span>(j))    X[++totx]=root[j];</span><br><span class="line">            <span class="keyword">for</span>(ll j=B[i];j;j-=<span class="built_in">lowbit</span>(j))    Y[++toty]=root[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(<span class="number">1</span>,n+<span class="number">1</span>,B[i]+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">-1</span>);</span><br><span class="line">            a[A[i]]=B[i];</span><br><span class="line">            to[A[i]]=n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll t=A[i]+<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">            <span class="keyword">if</span>(a[t]==B[i])&#123;to[A[i]]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="built_in">add</span>(A[i],<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i]<span class="number">-1</span>;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(to[j]==A[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">-1</span>);</span><br><span class="line">                    to[j]=n+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t=j+<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==a[j])&#123;to[j]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a[j]==B[i]&amp;&amp;to[j]&gt;A[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">-1</span>);</span><br><span class="line">                    to[j]=A[i];</span><br><span class="line">                    <span class="built_in">add</span>(j,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 6</span></span><br><span class="line"><span class="comment">1 1 1 2 2 2</span></span><br><span class="line"><span class="comment">Q 1 3</span></span><br><span class="line"><span class="comment">R 2 2</span></span><br><span class="line"><span class="comment">Q 1 3</span></span><br><span class="line"><span class="comment">R 3 2</span></span><br><span class="line"><span class="comment">Q 1 3</span></span><br><span class="line"><span class="comment">Q 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Segment Tree </tag>
            
            <tag> Persistent Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年5月 题目总结</title>
      <link href="/2017/05/02/Problems-2017-05/"/>
      <url>/2017/05/02/Problems-2017-05/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/05/02/2017%E5%B9%B45%E6%9C%88%20%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="BZOJ1023-SHOI2008-cactus仙人掌图"><a href="#BZOJ1023-SHOI2008-cactus仙人掌图" class="headerlink" title="BZOJ1023 SHOI2008 cactus仙人掌图"></a>BZOJ1023 SHOI2008 cactus仙人掌图</h1><p>题意为求仙人掌图的直径。这题看起来完全没思路，最后看的题解。get了一种Tarjan的用法，先用其求出DFS树，用dp更新树边的直径最大值，考虑将其他非树边以环形dp更新，由于边的权值均为$1$，所以可以进行单调队列优化。其中利用到了仙人掌的一些性质。</p><h1 id="BZOJ1024-SCOI2009-生日快乐"><a href="#BZOJ1024-SCOI2009-生日快乐" class="headerlink" title="BZOJ1024 SCOI2009 生日快乐"></a>BZOJ1024 SCOI2009 生日快乐</h1><p>搜索，考虑切成$n$块后面积是一样的，那么实际上对于每一个切割后的蛋糕，需要继续处理的操作数的一定的，深搜即可。核心代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">work</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">int</span> k)</span><span class="comment">//x，y为长与宽，k为对于该块蛋糕剩余操作个数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">max</span>(x,y)/<span class="built_in">min</span>(x,y);</span><br><span class="line">    <span class="keyword">double</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(<span class="built_in">work</span>(x,y/k*i,i),<span class="built_in">work</span>(x,y/k*(k-i),k-i)));</span><br><span class="line">    <span class="comment">//取min是因为答案要求最小值，取max是因为属于同一块蛋糕。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(<span class="built_in">work</span>(x/k*i,y,i),<span class="built_in">work</span>(x/k*(k-i),y,k-i)));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BZOJ1025-SCOI2009-游戏"><a href="#BZOJ1025-SCOI2009-游戏" class="headerlink" title="BZOJ1025 SCOI2009 游戏"></a>BZOJ1025 SCOI2009 游戏</h1><p>题意为给定$n$个元素，求在$n$的全排列的置换中的周期（即为各个循环节的公倍数），等价于$n$的整数拆分中的最小公倍数数量，直接枚举显然会超时，不妨用dp处理，枚举质因子以及幂即可。</p><h1 id="BZOJ1026-SCOI2009-windy数"><a href="#BZOJ1026-SCOI2009-windy数" class="headerlink" title="BZOJ1026 SCOI2009 windy数"></a>BZOJ1026 SCOI2009 windy数</h1><p>数位DP（一般是求在$[L,R]$之间有多少满足条件的数，然而并没有学过，膜的题解），先预处理有$k$位时，最高位为$i$时的答案，通过交集，并集的关系求一下即可。</p><h1 id="BZOJ1027-JSOI2007-合金"><a href="#BZOJ1027-JSOI2007-合金" class="headerlink" title="BZOJ1027 JSOI2007 合金"></a>BZOJ1027 JSOI2007 合金</h1><p>构造题，已知$a+b+c=1$，可将第三维浓度去掉，那么目标浓度可由条件浓度转化而来，当且仅当</p><p>$$min(a_{condition}) &lt; a_{target} &lt; max(a_{condition})$$</p><p>$$min(b_{condition}) &lt; b_{target} &lt; max(b_{condition})$$</p><p>那么可以将其转化为二维平面的凸包问题，给定可选点，要求用最少的点使其凸包包含所有目标点。</p><h1 id="BZOJ1028-JSOI2007-麻将"><a href="#BZOJ1028-JSOI2007-麻将" class="headerlink" title="BZOJ1028 JSOI2007 麻将"></a>BZOJ1028 JSOI2007 麻将</h1><p>观察$n,m$的范围，可知贪心就能过。</p><h1 id="BZOJ1029-JSOI2007-建筑抢修"><a href="#BZOJ1029-JSOI2007-建筑抢修" class="headerlink" title="BZOJ1029 JSOI2007 建筑抢修"></a>BZOJ1029 JSOI2007 建筑抢修</h1><p>还是贪心，涨自信题。</p><h1 id="BZOJ1030-JSOI2007-文本生成器"><a href="#BZOJ1030-JSOI2007-文本生成器" class="headerlink" title="BZOJ1030 JSOI2007 文本生成器"></a>BZOJ1030 JSOI2007 文本生成器</h1><p>AC自动机模板题，见博客DNA Sequence，不过这题$m$范围很小，而子串的长度更大，所以不需要矩阵快速幂（会TLE），直接DP即可。</p><h1 id="BZOJ1031-JSOI2007-字符加密"><a href="#BZOJ1031-JSOI2007-字符加密" class="headerlink" title="BZOJ1031 JSOI2007 字符加密"></a>BZOJ1031 JSOI2007 字符加密</h1><p>后缀数组模板题，利用后缀的性质将条件串接到自己后面，这样就包换了所有情况，求sa即可。</p><h1 id="BZOJ1032-JSOI2007-祖码"><a href="#BZOJ1032-JSOI2007-祖码" class="headerlink" title="BZOJ1032 JSOI2007 祖码"></a>BZOJ1032 JSOI2007 祖码</h1><p>区间DP，标程没有考虑到连续消除的问题，导致数据都错了。</p><h1 id="BZOJ1034-ZJOI2008-泡泡堂"><a href="#BZOJ1034-ZJOI2008-泡泡堂" class="headerlink" title="BZOJ1034 ZJOI2008 泡泡堂"></a>BZOJ1034 ZJOI2008 泡泡堂</h1><p>贪心，对于最好情况，先将对手实力值与ZJ实力值排序，如果ZJ最低的实力值比对手最低的实力值大，那么为了战胜对手，将两者比试的代价最小，如果ZJ最高的实力值比对手最高的实力值大时，那么为了战胜对手，此时只要ZJ取一个比对手该实力值高的元素即可，为了方便，可以取最后一个。当两者均不满足时，则与对手实力值最高的元素比试总不能获胜，为了代价最小，将ZJ实力值最小的元素与其进行比试。</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Graph Theory </tag>
            
            <tag> Computation Geometry </tag>
            
            <tag> Tarjan&#39;s Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDOI2017 数字表格</title>
      <link href="/2017/04/27/SDOI2017-Numbers/"/>
      <url>/2017/04/27/SDOI2017-Numbers/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/27/SDOI2017%20%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/">原文</a>）</p></div><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/ha3dQq1exT2tu9A.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><img src="i4.buimg.com/567571/46577fa98c6b973a.png" alt="题解"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line">ull fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][<span class="number">3</span>],ff[N],fs[N],rev[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> ca1[<span class="number">33</span>],ca2[<span class="number">33</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">qpow</span><span class="params">(ull a,ull b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)b+=mod<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=(ret*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    miu[<span class="number">1</span>]=phi[<span class="number">1</span>]=fs[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%mod;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])miu[i]=<span class="number">-1</span>,p[++tot]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;p[j]*i&lt;N;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*p[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)&#123;miu[i*p[j]]=<span class="number">0</span>;phi[i*p[j]]=phi[i]*p[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">            miu[i*p[j]]=-miu[i];</span><br><span class="line">            phi[i*p[j]]=phi[i]*(p[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">    fp[i][<span class="number">0</span>]=<span class="built_in">qpow</span>(f[i],<span class="number">-1</span>),fp[i][<span class="number">1</span>]=<span class="number">1</span>,fp[i][<span class="number">2</span>]=f[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)ff[i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)</span><br><span class="line">    ff[j]=(ull)ff[j]*fp[i][miu[j/i]+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)fs[i]=(ull)fs[i<span class="number">-1</span>]*ff[i]%mod;</span><br><span class="line"></span><br><span class="line">    rev[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(fs[N<span class="number">-1</span>],<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)rev[i]=(ull)rev[i+<span class="number">1</span>]*ff[i+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ull solve(int n,int m)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    ull ret=0;</span></span><br><span class="line"><span class="comment">//    int top=min(n,m);</span></span><br><span class="line"><span class="comment">//    ull i=1,j;</span></span><br><span class="line"><span class="comment">//    while(i&lt;=top)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        j=min(n/(n/i),m/(m/i));</span></span><br><span class="line"><span class="comment">//        (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; </span></span><br><span class="line"><span class="comment">//        i=j+1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return ret;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//ull mobi(ull n,ull m)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    if(n&gt;m)swap(n,m);</span></span><br><span class="line"><span class="comment">//    ull ans=0;</span></span><br><span class="line"><span class="comment">//    for (int i=1,r;i&lt;=n;i=r+1)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        r=min(n/(n/i),m/(m/i));</span></span><br><span class="line"><span class="comment">//        ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return ans;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//ull cheng(ull a,ull b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    ull ret=0;</span></span><br><span class="line"><span class="comment">//    int tmp1=0,tmp2=0;</span></span><br><span class="line"><span class="comment">//    memset(ca1,0,sizeof(ca1));</span></span><br><span class="line"><span class="comment">//    memset(ca2,0,sizeof(ca2));</span></span><br><span class="line"><span class="comment">//    while(a)ca1[++tmp1]=a%10,a/=10;</span></span><br><span class="line"><span class="comment">//    while(b)ca2[++tmp2]=b%10,b/=10;</span></span><br><span class="line"><span class="comment">//    int *x=ca1,*y=ca2;</span></span><br><span class="line"><span class="comment">//    if(tmp2&gt;tmp1)swap(x,y),swap(tmp1,tmp2);</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp2;++i)x[i]*=y[i];</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp2;++i)</span></span><br><span class="line"><span class="comment">//    if(x[i]&gt;10)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        x[i+1]+=x[i]/10;</span></span><br><span class="line"><span class="comment">//        x[i]%=10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp1;++i)y[tmp1+1-i]=x[i];</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=tmp1;++i)ret=(ret*10+(y[i]))%mod;</span></span><br><span class="line"><span class="comment">//    return ret;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m,k;</span><br><span class="line"><span class="comment">//    freopen(&quot;c.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        ull ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mn=<span class="built_in">min</span>(n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,r;i&lt;=mn;i=r+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">            ans=ans*<span class="built_in">qpow</span>(fs[r]*rev[i<span class="number">-1</span>]%mod,(ull)(n/i)*(m/i)%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Mobius Inversion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年4月 题目总结</title>
      <link href="/2017/04/25/Problems-2017-04/"/>
      <url>/2017/04/25/Problems-2017-04/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/25/2017%E5%B9%B44%E6%9C%88%20%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="BZOJ1001-BeiJing2006-狼抓兔子"><a href="#BZOJ1001-BeiJing2006-狼抓兔子" class="headerlink" title="BZOJ1001 BeiJing2006 狼抓兔子"></a>BZOJ1001 BeiJing2006 狼抓兔子</h1><p>网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可）</p><h1 id="BZOJ1002-FJOI2007-轮状病毒"><a href="#BZOJ1002-FJOI2007-轮状病毒" class="headerlink" title="BZOJ1002 FJOI2007 轮状病毒"></a>BZOJ1002 FJOI2007 轮状病毒</h1><p>最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度）</p><h1 id="BZOJ1003-ZJOI2006-物流运输"><a href="#BZOJ1003-ZJOI2006-物流运输" class="headerlink" title="BZOJ1003 ZJOI2006 物流运输"></a>BZOJ1003 ZJOI2006 物流运输</h1><p>一道DP题，转移方程为</p><p>$$f[i]=min(f[i],f[j]+k+t[j+1][i] * (i−j))$$</p><h1 id="BZOJ1004-HNOI2008-Cards"><a href="#BZOJ1004-HNOI2008-Cards" class="headerlink" title="BZOJ1004 HNOI2008 Cards"></a>BZOJ1004 HNOI2008 Cards</h1><p>Burnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。</p><h1 id="BZOJ1005-HNOI2008-明明的烦恼"><a href="#BZOJ1005-HNOI2008-明明的烦恼" class="headerlink" title="BZOJ1005 HNOI2008 明明的烦恼"></a>BZOJ1005 HNOI2008 明明的烦恼</h1><p>purfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。</p><h1 id="BZOJ1006-HNOI2008-神奇的国度"><a href="#BZOJ1006-HNOI2008-神奇的国度" class="headerlink" title="BZOJ1006 HNOI2008 神奇的国度"></a>BZOJ1006 HNOI2008 神奇的国度</h1><p>弦图裸题,见上篇博客。</p><h1 id="BZOJ1007-HNOI2008-水平可见直线"><a href="#BZOJ1007-HNOI2008-水平可见直线" class="headerlink" title="BZOJ1007 HNOI2008 水平可见直线"></a>BZOJ1007 HNOI2008 水平可见直线</h1><p>以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。</p><h1 id="BZOJ1008-HNOI2008-越狱"><a href="#BZOJ1008-HNOI2008-越狱" class="headerlink" title="BZOJ1008 HNOI2008 越狱"></a>BZOJ1008 HNOI2008 越狱</h1><p>简单的快速幂，稍微推一下即可得到答案为</p><p>$$qpow(m,n)−(qpow(m−1,n−1)∗m)$$</p><h1 id="BZOJ1009-HNOI2008-GT考试"><a href="#BZOJ1009-HNOI2008-GT考试" class="headerlink" title="BZOJ1009 HNOI2008 GT考试"></a>BZOJ1009 HNOI2008 GT考试</h1><p>用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。</p><h1 id="BZOJ1011-HNOI2008-遥远的行星"><a href="#BZOJ1011-HNOI2008-遥远的行星" class="headerlink" title="BZOJ1011 HNOI2008 遥远的行星"></a>BZOJ1011 HNOI2008 遥远的行星</h1><p>简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2j$即可。</p><h1 id="BZOJ1012-JSOI2008-最大数"><a href="#BZOJ1012-JSOI2008-最大数" class="headerlink" title="BZOJ1012 JSOI2008 最大数"></a>BZOJ1012 JSOI2008 最大数</h1><p>各种数据结构的裸题。</p><h1 id="BZOJ1013-JSOI2008-球形空间产生器"><a href="#BZOJ1013-JSOI2008-球形空间产生器" class="headerlink" title="BZOJ1013 JSOI2008 球形空间产生器"></a>BZOJ1013 JSOI2008 球形空间产生器</h1><p>高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。</p><h1 id="BZOJ4801-BZOJ4月月赛-打牌"><a href="#BZOJ4801-BZOJ4月月赛-打牌" class="headerlink" title="BZOJ4801 BZOJ4月月赛 打牌"></a>BZOJ4801 BZOJ4月月赛 打牌</h1><p>考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。</p><h1 id="BZOJ4810-YNOI2017-由乃的玉米田"><a href="#BZOJ4810-YNOI2017-由乃的玉米田" class="headerlink" title="BZOJ4810 YNOI2017 由乃的玉米田"></a>BZOJ4810 YNOI2017 由乃的玉米田</h1><p>主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。</p><h1 id="Luogu3708-洛谷四月月赛-koishi的数学题"><a href="#Luogu3708-洛谷四月月赛-koishi的数学题" class="headerlink" title="Luogu3708 洛谷四月月赛 koishi的数学题"></a>Luogu3708 洛谷四月月赛 koishi的数学题</h1><p>设$g(x,i)=g(modi)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x−1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。</p><h1 id="BZOJ1015-JSOI2008-星球大战"><a href="#BZOJ1015-JSOI2008-星球大战" class="headerlink" title="BZOJ1015 JSOI2008 星球大战"></a>BZOJ1015 JSOI2008 星球大战</h1><p>考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。</p><h1 id="BZOJ1018-SHOI2008-堵塞的交通"><a href="#BZOJ1018-SHOI2008-堵塞的交通" class="headerlink" title="BZOJ1018 SHOI2008 堵塞的交通"></a>BZOJ1018 SHOI2008 堵塞的交通</h1><p>分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写）</p><h1 id="BZOJ1019-SHOI2008汉诺塔"><a href="#BZOJ1019-SHOI2008汉诺塔" class="headerlink" title="BZOJ1019 SHOI2008汉诺塔"></a>BZOJ1019 SHOI2008汉诺塔</h1><p>第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i−1]$线性相关，于是模拟出来前$20$项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i−1]∗k+b$的递推式））</p><h1 id="BZOJ1020-SHOI2008-安全的航线"><a href="#BZOJ1020-SHOI2008-安全的航线" class="headerlink" title="BZOJ1020 SHOI2008 安全的航线"></a>BZOJ1020 SHOI2008 安全的航线</h1><p>典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍）</p><h1 id="BZOJ1021-SHOI2008-循环的债务"><a href="#BZOJ1021-SHOI2008-循环的债务" class="headerlink" title="BZOJ1021 SHOI2008 循环的债务"></a>BZOJ1021 SHOI2008 循环的债务</h1><p>题目可以进一步简化，即已知每个人初始金钱和构成。</p><h1 id="Luogu3704-SDOI2017-数字表格"><a href="#Luogu3704-SDOI2017-数字表格" class="headerlink" title="Luogu3704 SDOI2017 数字表格"></a>Luogu3704 SDOI2017 数字表格</h1><p>莫比乌斯反演的常见应用，见下篇博客。</p><h1 id="BZOJ1049-HAOI2006-数字序列"><a href="#BZOJ1049-HAOI2006-数字序列" class="headerlink" title="BZOJ1049 HAOI2006 数字序列"></a>BZOJ1049 HAOI2006 数字序列</h1><p>很像暴力的动规，对于第一问，需要用到补集转化的思想，设 $f[i]$ 为前 $i$ 位的最多不变 元素，那么 $f[i]$ 能由 $f[j]$ 转化而来当且仅当 $a[i]-a[j]&gt;=i-j$, 即修改两者之间的 $i-j-1$ 个数使其严格递增，即两者之间只有$1$个元素不变，那么有</p><p>$$f[i]=\max (f[i], f[j]+1)(a[i]-a[j]&gt;=i-j)$$</p><p>时间复杂度为 $O\left(n^{2}\right)$, 无法通过全部数据点，考虑进行优化，观察状态转移方程，易知可以通过减标号的方法转化成LIS问题，即 可在 $O(n \log n)$ 的时间内求解。</p><p>对于第二问，为了简化问题，可以先设 $w(i, j)$ 为将从 $i$ 到 $j$ 的所有元素进行修改的最小代价，设 $g[i]$ 为前 $i$ 位的最小答案。那么根据第一问有</p><p>$$g[i]=\min (g[i], g[j]+w(j+1, i))(f[i]=f[j]+1)$$</p><p>对于 $w$ 的求解，可以记录每一个需要修改的元素的下一个和上一个不需要修改元素的位置，模拟即可。</p><h1 id="Codefores286E-Ladies’-Shop"><a href="#Codefores286E-Ladies’-Shop" class="headerlink" title="Codefores286E Ladies’ Shop"></a>Codefores286E Ladies’ Shop</h1><p>根据题目所给条件，可知要求的 $p$ 个数一定在给定的 $n$ 个数中。</p><p>那么可以根据多项式乘法系数相乘，指数相加的特点，构造生成函数，并求出这 $n$ 个数可以组成的所有情况。已知某个 $n$ 集合中数 $a$ 可以由 $b+c+d$ 生成，那么根据题目中所给条件，可知一定有 $e$ 由 $c+d$ 生成，那么可以将 $a$ 看作由 $b+e$ 生成。</p><p>根据数学归纳法，易证</p><p>$p$ 个数可以选出一些集合（相同的数可重复选），其和可以组成所有给定的 $n$ 个数。（一）</p><p>与以下结论等价:</p><p>$p$ 个数可以选出任何两个元素（相同的数可重复选），其和可以组成所有给定的 $n$ 个数。（二）</p><p>那么生成函数的构造就显而易见了。（将幂作为权值，系数作为出现的次数，并将该生成函数与自身相乘，可以通过FFT优化)</p><p>对于第三个条件 (满足 $|p|$ 的阶最小)，可以结合以贪心的策略。如果生成函数中某项系数大于$1$且在给定集合 $|n|$ 中，则该元素一定可以由另外两个元素组成，那么就不将其加入集合 $|p|$ 中，否则将其加入集合 $|p|$ 中。</p><p>至于无解的判断，易知其等价于:</p><p>生成函数中某项系数不为零且该元素不在给定集合中。</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AC Automaton </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> String Manipulation </tag>
            
            <tag> Graph Theory </tag>
            
            <tag> Mo&#39;s Algorithm </tag>
            
            <tag> Polya Theorem </tag>
            
            <tag> Balance Tree </tag>
            
            <tag> Computation Geometry </tag>
            
            <tag> Gaussian Elimination </tag>
            
            <tag> Network Flow </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弦图与区间图</title>
      <link href="/2017/04/21/Chordal-Graph/"/>
      <url>/2017/04/21/Chordal-Graph/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/21/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE/">原文</a>）</p></div><h1 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h1><p><a href="https://wenku.baidu.com/view/6f9f2223dd36a32d73758126.html">弦图与区间图-陈丹琦</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="团"><a href="#团" class="headerlink" title="团"></a>团</h2><p>图$G$的一个子图$G’=(V’,E’)$，$G’$为关于$V’$的完全图。</p><h2 id="极大团"><a href="#极大团" class="headerlink" title="极大团"></a>极大团</h2><p>一个团是极大团当它不是其它团的子集。</p><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><p>点数最多的团。</p><h2 id="弦"><a href="#弦" class="headerlink" title="弦"></a>弦</h2><p>连接环中不相邻的两个点的边。</p><h2 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h2><p>一个无向图称为弦图当且仅当图中任意长度大于$3$的环都至少有一个弦。</p><h2 id="单纯点"><a href="#单纯点" class="headerlink" title="单纯点"></a>单纯点</h2><p>设$N(v)$表示与点$v$相邻的点集。一个点称为单纯点当$\lbrace v \rbrace + N(v)$的诱导子图为一个团。</p><h2 id="完美消除序列"><a href="#完美消除序列" class="headerlink" title="完美消除序列"></a>完美消除序列</h2><p>这是一个序列$v_i$，它满足$v_i$在$v_i,…,v_n$的诱导子图中为单纯点。</p><h2 id="弦图的判定"><a href="#弦图的判定" class="headerlink" title="弦图的判定"></a>弦图的判定</h2><p>存在完美消除序列的图为弦图。</p><h2 id="最小色数"><a href="#最小色数" class="headerlink" title="最小色数"></a>最小色数</h2><p>用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。</p><h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><p>最大的一个点集使任意两个点不相邻，$α(G)$为其点数。</p><h2 id="最小团覆盖"><a href="#最小团覆盖" class="headerlink" title="最小团覆盖"></a>最小团覆盖</h2><p>用最少个数的团覆盖所有的点，$κ(G)$为其团数。</p><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><h2 id="完美消除序列-1"><a href="#完美消除序列-1" class="headerlink" title="完美消除序列"></a>完美消除序列</h2><p>可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）（但是可以用堆优化）。</p><h2 id="最小色数的求解"><a href="#最小色数的求解" class="headerlink" title="最小色数的求解"></a>最小色数的求解</h2><p>简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。</p><h2 id="最大独立集的求解"><a href="#最大独立集的求解" class="headerlink" title="最大独立集的求解"></a>最大独立集的求解</h2><p>仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。</p><h2 id="最小团覆盖的求解"><a href="#最小团覆盖的求解" class="headerlink" title="最小团覆盖的求解"></a>最小团覆盖的求解</h2><p><strong>最小团覆盖数=最大独立集数</strong></p><p>（以上一切都不会证）</p><h1 id="HNOI2008-神奇的国度"><a href="#HNOI2008-神奇的国度" class="headerlink" title="HNOI2008 神奇的国度"></a>HNOI2008 神奇的国度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>K国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人A1A2…An之间仅存在N对认识关系:(A1A2)(A2A3)…(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 </p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数$N，M$。表示有$N$个人，$M$对认识关系. 接下来$M$行每行输入一对认识关系。</p><p>$1&lt;=N&lt;=10000,1&lt;=M&lt;=1000000$</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，最少可以分多少队 。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">(1,3)(2)(4)为一种可行方案</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span><span class="keyword">int</span> ne,to;&#125;e[<span class="number">20</span>*N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N];</span><br><span class="line"><span class="keyword">bool</span> use[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].ne=head[x];</span><br><span class="line">    e[cnt].to=y;</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1006.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1006.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tot!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="keyword">if</span>(p[i]&gt;p[x]&amp;&amp;!vis[i])x=i;</span><br><span class="line">        vis[x]=<span class="number">1</span>;q[++tot]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)p[e[i].to]++;</span><br><span class="line">        x=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=n;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)use[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)use[c[e[i].to]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(use[now])now++;</span><br><span class="line">        c[x]=now;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;ans)ans=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Graph Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学总结</title>
      <link href="/2017/04/10/Combinatorics/"/>
      <url>/2017/04/10/Combinatorics/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/10/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h2><p>做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，…，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M_1+M_2+…+M_N$种方法。</p><h2 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h2><p>做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，…，做第$n$步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。</p><h1 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h1><p>从$n$个不同元素中任取$r(r≦n)$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出$r$个元素的排列数，记为$A(n,r)$。</p><p>对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n−1$种取法，…，第$r$个元素有$n−r+1$种取法，则根据乘法原理可得通项公式。</p><p>$$A(n,r)=\frac {n!} {(n−r)!}$$</p><h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><p>从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为 $C(n, m)$ 。</p><p>根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说 $1,2,3$ 与 $1,3,2$ 是一种组合，但 对排列数则不是。那么在组合数中重复计算的次数即为 $r$ 的全排列</p><p>则有</p><p>$$C(n, r)=\frac{A(n, r)}{r !}$$</p><p>即</p><p>$$C(n, r)=\frac{n !}{r !(n-r) !}$$</p><h1 id="常见定理与组合论证"><a href="#常见定理与组合论证" class="headerlink" title="常见定理与组合论证"></a>常见定理与组合论证</h1><p>$$\text { 1. } C(n, r)=C(n, n-r)$$</p><p>将其表示为一个长度为 $n$ 的二进制串，则组合数为有 $r$ 位为 1 的串的个数，易知其与有 $n-r$ 位为 0 的串的个数等价。</p><p>$$\text { 2. } C(n, r)=C(n-1, r-1)+C(n-1, r)$$</p><p>将其表示为一个长度为 $n$ 的二进制串，利用动态规划的思想，可设 $C(n-1, r-1)$ 表示长度为 $n-1$ 的串且在末尾新加入一个$1$的方案数， $C(n-1, r)$ 表示长度为 $n-1$ 的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为 $C(i, i)=0$）</p><p>$$\text { 3. }2^{n}=\sum_{k} C(n, k)$$</p><p>$2^{n}$ 为长度为 $n$ 的二进制串的总方案数，根据加法原理，易知其等价于长度为 $n$ 的二进制串且有 $0,1,…,n$ 个 $1$ 的方案数和。</p><p>$$\text { 4. }(a+b)^{n}=\sum_{k} C(n, k) a^{k} b^{b-k}$$</p><p>这个定理同样可以直接通过二项式定理求证。</p><p>$$\text { 5. } C(n+m, r)=\sum_{k} C(n, k) * C(m, r-k)$$</p><p>左项可以表示为一个长度为 $a+b$ 的二进制串，右项则可以表示为一个长度为 $a$ 的二进制串拼上一个长度为 $b$ 的二进制串，此处可以转化为定理 $3$，再结合乘法原理即可得证。</p><p>$$\text { 6. }C(n, r)=\frac{n}{r}(n-1, r-1)$$</p><p>结合定理一，可以通过简单的推导得到该定理。</p><p>$$\text { 7. } C(n, m) C(m, r)=C(n, r) C(n-r, m-r)$$</p><p>可以将左式表示为在 $n$ 个学生中选出 $m$ 个组长，再在 $m$ 个组长中选出 $r$ 班干部，则右式可以表示为在 $n$ 个学生中选 $r$ 个班干部，再 在剩余的学生 $n-r$ 中选出 $m-r$ 个不是班干部的组长，易知两者等价。</p><h1 id="可重复组合数"><a href="#可重复组合数" class="headerlink" title="可重复组合数"></a>可重复组合数</h1><p>从 $n$ 个不同元素中，任取 $m(m \leq n)$ 个元素并成一组 (可以重复选择)，叫做从 $n$ 个不同元素中取出 $m$ 个元素的一个可重复组合；从 $n$ 个不同元素中取出 $m(m \leq n)$ 个元素的所有组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的可重复组合数。</p><p>可重复组合即为</p><p>$$C(n+m-1, m)$$</p><p>对于此结论的证明可以逆向来看， $n$ 中选 $m$ 个元素即为将 $m$ 个球放在 $n$ 个盒子内的方案数，每个盒子中允许放 0 到 $m$ 个球。对于 这 $m$ 个球来说，即为 $n-1$ 个断点将其分为了 $n$ 部分。</p><p>不妨将断点用二进制串表示为 0 ，球表示为 1 ，那么在 3 个元素中选 5 个元素的一种方案即可表示为</p><p>$$1-1-1-0-1-0-1$$</p><p>易观察到可重复组合数等于在 $n+m-1$ 个元素中选取 $m$ 个 $1$ 的方案数</p><p>即为</p><p>$$C(n+m-1, m)$$</p><p>可重复组合数同样可以解决如下的问题:</p><p>已知</p><p>$$x_{1}+x_{2}+x_{3}+\ldots \ldots+x_{n}=m\left(x_{i}&gt;=0\right)$$</p><p>求方程的解数。</p><p>此处可以看出答案即为 $C(n+m-1, m)$ ，论证方法同上，该问题同样有很多变式，如改变 $x_{i}$ 的取值范围等，同样可以通过如 上方式得解，此处不再赘述。</p><h1 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h1><p>斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。</p><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><p>$s(n, m)$ 的递推公式:</p><p>$$s(n, m)=(n-1) * s(n-1, m)+s(n-1, m-1)(1&lt;=m&lt;=n-1)$$</p><p>边界条件:</p><p>$$s(n, n)=1(n&gt;=0)$$</p><p>$$s(n, 0)=0(n&gt;=1)$$</p><p>递推关系的说明:</p><p>考虑第 $n$ 个物品， $n$ 可以单独构成一个非空循环排列，这样前 $n-1$ 种物品构成 $m-1$ 个非空循环排列，方法数 为 $s(n-1, m-1)$ 。</p><p>也可以前 $n-1$ 种物品构成 $m$ 个非空循环排列，而第 $n$ 个物品揷入第 $i$ 个物品的左边，这有 $(n-1) \times s(n-1, m)$ 种方法。</p><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>$S(n, m)$ 的递推公式是:</p><p>$$S(n, m)=m \times S(n-1, m)+S(n-1, m-1)(1&lt;=m&lt;=n-1)$$</p><p>边界条件:</p><p>$$s(n, n)=1(n&gt;=0)$$</p><p>$$s(n, 0)=0(n&gt;=1)$$</p><p>递推关系的说明:</p><p>考虑第 $n$ 个物品， $n$ 可以单独构成一个非空集合，此时前 $n-1$ 个物品构成 $m-1$ 个非空的不可辨别的集合，方法数 为 $S(n-1, m-1)$ ；</p><p>也可以前 $n-1$ 种物品构成 $m$ 个非空的不可辨别的集合，第 $n$ 个物品放入任意一个中，这样有 $m \times S(n-1, m)$ 种方法。</p><p>第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。</p><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>一个栈(无穷大)的进栈序列为 $1 , 2 , 3 , \ldots, n$ ，有多少个不同的出栈序列?</p><p>该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有 $n$ 个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数，凸多边形的三角划分数等等，在组合数学中有着广泛的应用。</p><p>令$h(0)=1, h(1)=1$, 则卡特兰数数满足递推式:</p><p>$$h(n)=h(0) \times h(n-1)+h(1) \times h(n-2)+\ldots+h(n-1) \times h(0)(n&gt;=2)$$</p><p>亦或</p><p>$$h(n)=h(n-1) \times(4 \times n-2) /(n+1)$$</p><p>同样可以用组合数表示</p><p>$$h(n)=\frac{C(2 n, n)}{n+1}$$</p><p>或者</p><p>$$h(n)=C(2 n, n)-C(2 n, n-1)$$</p><p>证明可以将出栈入栈的操作集合，看作一个长度为 $2 n$ 的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：$0$和$1$的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，$0$的个数要大于等于$1$的个数（对应栈为空时不能继续出栈)。</p><p>先求出只满足第一个限制的方案数，易知其为 $C(2 n, n)$ 。</p><p>再考虑第二个限制需要排除的方案，易知其前缀必有一处 $1$ 的个数大于 $0$ 的个数，可设此处有 $k$ 个 $0$，$k+1$ 个 $1$ ，剩下的串中 有 $n-k$ 个 $0$，$n-k-1$ 个 $1$ ，将剩下的串按位取反，则得到的新串中共有 $n-1$ 个 $0$，$n+1$ 个 $1$ ，这样的串共有 $C(2 n, n-1)$ 。</p><p>则有</p><p>$$h(n)=C(2 n, n)-C(2 n, n-1)$$</p><p>以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与 原问题等价等条件，才能优美地求解。</p><h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p>在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</p><p>易知</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/05f67b2ce4414f2a1f96e4210a86d71028aa53b6" alt="容斥原理1"></p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0b8e7c1631ec013eed94feb5aa406a573caa3559" alt="容斥原理2"></p><p>则通项公式表示为</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7589a99f7137c74fd85940231971082679f12c3" alt="容斥原理3"></p><p>（在个人讲课ppt中有着详细的证明，后续会整理到博客中）</p><h1 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h1><p>错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。<br>递推式为：</p><p>$$D(n)=(n−1)*(D(n−2)+D(n−1))$$</p><p>初始条件为：</p><p>$$D(1)=0$$</p><p>$$D(2)=1$$</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transposing is Even More Fun</title>
      <link href="/2017/04/09/Transposing-Is-Even-More-Fun/"/>
      <url>/2017/04/09/Transposing-Is-Even-More-Fun/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/09/Transposing%20is%20Even%20More%20Fun/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vixmxkeaU">COGS 1608</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个$2^a∗2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的…每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ </p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第$1$行数数据组数$c(1&lt;=c&lt;=400000)$</p><p>接下来有$c$行，每行一组测试数据：两个整数$a,b(0&lt;=a+b&lt;=1000000)$ </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 </p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">5 7</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">3744</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。</p><p>以$2^1∗2^2$为例，则置换为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1  </span><br><span class="line">2 3 </span><br><span class="line">4 5</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><p>到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2 4 6</span><br><span class="line">1 3 5 7</span><br></pre></td></tr></table></figure><p>表示为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ 0 1 2 3 4 5 6 7 \</span><br><span class="line">\ 0 2 4 6 1 3 5 7 /</span><br></pre></td></tr></table></figure><p>亦或</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0)(1 2 4)(3 6 5)(7)</span><br></pre></td></tr></table></figure><p>考虑在任意一个循环节中，需要交换的次数即为（ 循环节的长度 - 1 ）次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有</p><p>$$Ans=2^{a+b}−循环节个数$$</p><p>现在的问题就转换成了求解循环节的个数，已知$(1&lt;=c&lt;=400000)$且$(0&lt;=a+b&lt;=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。</p><p>则置换为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000 - 000</span><br><span class="line">001 - 010</span><br><span class="line">010 - 100</span><br><span class="line">011 - 110</span><br><span class="line">100 - 001</span><br><span class="line">101 - 011</span><br><span class="line">110 - 101</span><br><span class="line">111 - 111</span><br></pre></td></tr></table></figure><p>不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了$b$位），我们也可以稍微推算一下，对于矩阵元素$(i,j)$来说，转置使其变为了$(j,i)$，将其表示为队列，则从第 $(i-1) * 2^a+j$位转置为第$(j-1) * 2^b+i$位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为$a+b$，颜色为$0,1$ 两种，循环右移左移即对应项链的旋转。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以a=2，b=4为例。</span><br><span class="line"></span><br><span class="line">则项链为</span><br><span class="line"></span><br><span class="line">      a1</span><br><span class="line">     /  \</span><br><span class="line">    a6   a2</span><br><span class="line">    |    |</span><br><span class="line">    a5   a3</span><br><span class="line">     \  /</span><br><span class="line">      a4   </span><br></pre></td></tr></table></figure><p>但该题的置换群$G= \lbrace 不动，循环右移a位 \rbrace $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a,b)$个点压为一个点。则例图转化为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     a1,2</span><br><span class="line">     /  \</span><br><span class="line"> a5,6 -- a3,4</span><br><span class="line">此时对于任意一个点有2^gcd(a,b)中染色方案。</span><br></pre></td></tr></table></figure><p>则</p><p>$$Ans=2^{a+b}−(\sum_{d|n}k^d \varphi(n/d))/n$$</p><p>原式中</p><p>$$n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$$</p><p>由于原式需要取模，则需要求$n$的逆元，已知$a+b&lt;=1e6$，模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。</p><p>（当时没系统地接触过群论，还不太理解Polya定理的含义）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000003</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N],phi[N],tot,pow2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> c[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">while</span>(x) c[++num] = (x%<span class="number">10</span>)+<span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) <span class="built_in">putchar</span>(c[num--]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=((ll)ans*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=((ll)a*a)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])p[++tot]=i,phi[i]=(i<span class="number">-1</span>)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tot&amp;&amp;i*p[t]&lt;=N<span class="number">-1</span>;++t)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*p[t]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[t]==<span class="number">0</span>)&#123;phi[i*p[t]]=((ll)phi[i]*p[t])%mod;<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*p[t]]=((ll)phi[i]*(p[t]<span class="number">-1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pow2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;++i)pow2[i]=(pow2[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;transp2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;transp2.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">getprime</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span>(a);<span class="built_in">get</span>(b);</span><br><span class="line">        <span class="keyword">int</span> lin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> gcdab=<span class="built_in">gcd</span>(a,b);</span><br><span class="line">        <span class="keyword">int</span> n=(a+b)/gcdab;</span><br><span class="line">        <span class="keyword">int</span> inv;</span><br><span class="line">        inv=<span class="built_in">qpow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=n;++d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%d==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(((ll)pow2[a+b]-lin*inv%mod+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Polya Theorem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSOI2006 同构</title>
      <link href="/2017/04/08/JSOI2006-Omorphism/"/>
      <url>/2017/04/08/JSOI2006-Omorphism/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/04/08/%E5%90%8C%E6%9E%84/#more">原文</a>）</p></div><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。</p><p>给你$N,M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 </p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P是素数且P&lt;=10^6)$。 </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个正整数，即互不同构的染色图数量模$P$的值。 </p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sample 1:</span><br><span class="line">1 1 2</span><br><span class="line">sample 2:</span><br><span class="line">3 2 97</span><br><span class="line">sample 3:</span><br><span class="line">3 4 97 </span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sample 1:</span><br><span class="line">1</span><br><span class="line">sample 2:</span><br><span class="line">4</span><br><span class="line">sample 3:</span><br><span class="line">20 </span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于本题来说，存在的置换共有$n!$种（即$n$个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对$n$进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$以内。</p><p>关于取模的问题，已知$p$是质数（这个题应该保证了$P&gt;53$），易证两者互质，则可通过费马小定理求逆。</p><p>（当时没系统地接触过群论，还不太理解Polya定理的含义）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line">ll num[N],cnt[N],res,fac[N],n,m,p,ans;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125; </span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;a=(a*a)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(ll now,ll maxl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxl==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a=<span class="number">1</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a=a*<span class="built_in">qpow</span>(num[i],cnt[i])%p*fac[cnt[i]]%p;</span><br><span class="line">            b+=cnt[i]*(cnt[i]<span class="number">-1</span>)/<span class="number">2</span>*num[i]+num[i]/<span class="number">2</span>*cnt[i];</span><br><span class="line">            <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;res;j++)b+=cnt[i]*cnt[j]*<span class="built_in">gcd</span>(num[i],num[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        a=<span class="built_in">qpow</span>(a,p<span class="number">-2</span>)*fac[n]%p;</span><br><span class="line">        ans=(ans+a*<span class="built_in">qpow</span>(m,b)%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;maxl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(now+<span class="number">1</span>,maxl);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*now&lt;=maxl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[res]=now,cnt[res++]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(now+<span class="number">1</span>,maxl-i*now);</span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="comment">//    freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)fac[i]=fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    ans=ans*<span class="built_in">qpow</span>(fac[n],p<span class="number">-2</span>)%p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Combinatorics </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Polya Theorem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>裴蜀定理总结</title>
      <link href="/2017/03/28/Bezouts-identity/"/>
      <url>/2017/03/28/Bezouts-identity/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/28/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h1><p>已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b)|d$。特别的，一定存在整数$x,y$使得$ax+by=gcd(a,b)$成立。</p><p>裴蜀定理是扩展欧几里得算法的核心。</p><p>（该定理在个人课件中有着详细证明，后续会整理到博客中）</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>（待补充）</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数总结</title>
      <link href="/2017/03/28/Euler-Function/"/>
      <url>/2017/03/28/Euler-Function/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/28/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/#more">原文</a>）</p></div><h1 id="欧拉函数的定义"><a href="#欧拉函数的定义" class="headerlink" title="欧拉函数的定义"></a>欧拉函数的定义</h1><p>$\varphi(n)$定义为$1$到$n$中与$n$互质的数的个数。</p><h1 id="欧拉函数的求解"><a href="#欧拉函数的求解" class="headerlink" title="欧拉函数的求解"></a>欧拉函数的求解</h1><h2 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h2><p>$\varphi(n)=n(1−1/p_1)(1−1/p_2)…(1−1/p_{tot})$ (其中$p$为$n$的质因子，$tot$为质因子个数)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">int</span> ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;<span class="comment">//与分解质因数相结合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans=ans/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><p>逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前$n$项欧拉函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">2</span>*<span class="built_in">sqrt</span>(N)+<span class="number">1</span>],phi[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++tot]=i;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[t]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[t]==<span class="number">0</span>)&#123;phi[i*prime[t]]=phi[i]*prime[t];<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*prime[t]]=phi[i]*(prime[t]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h1><h2 id="SDOI2008-沙拉公主的困惑"><a href="#SDOI2008-沙拉公主的困惑" class="headerlink" title="SDOI2008 沙拉公主的困惑"></a>SDOI2008 沙拉公主的困惑</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为$1$到$N$的阶乘，但是，政府只发行编号与$M!$互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对$R$取模后的答案即可。$R$是一个质数。</p><p>输入第一行为两个整数$T,R$。$R&lt;=10^9+10,T&lt;=10000$，表示该组中测试数据数目，$R$为模数。</p><p>后面$T$行，每行一对整数$N,M$，见题目描述。</p><p>输出共$T$行，对于每一对$N,M$，输出$1$至$N!$中与$M!$素质的数的数量对$R$取模后的值。</p><p>对于$100 \ percent$的数据，$1 &lt; = M &lt; = N &lt; = 10000000$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意明确$m&lt;=n$，且易知$m!|n!$那么只需要算出$\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\varphi(m!)∗n!/m!(modp)$</p><p>对于$\varphi(m!)$来说，$m!$的值过大，只能利用通项公式来求解，易知$m!$的所有质因数即为$1$到$m$中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> vis[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prime[<span class="number">500500</span>],ans[M+<span class="number">100</span>],fac[M+<span class="number">100</span>],rev[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,p,T,tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;T,&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])prime[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)fac[i]=fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    rev[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])    ans[i]=ans[i<span class="number">-1</span>]*(i<span class="number">-1</span>)%p*rev[i%p]%p;</span><br><span class="line">        <span class="keyword">else</span>                ans[i]=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fac[n]*ans[m]%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元总结</title>
      <link href="/2017/03/28/Multiplicative-Inverse/"/>
      <url>/2017/03/28/Multiplicative-Inverse/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/28/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E6%80%BB%E7%BB%93/">原文</a>）</p></div><h1 id="乘法逆元的定义"><a href="#乘法逆元的定义" class="headerlink" title="乘法逆元的定义"></a>乘法逆元的定义</h1><p>若$ax≡1(modp)$, 则称$a$关于模$p$的乘法逆元为$x$。</p><p>当$a$与$p$互质时，$a$关于模$p$的乘法逆元有解。如果不互质，则无解。如果$p$为质数，则从$1$到$p-1$的任意数都与p互质，即在$1$到$p-1$之间都恰好有一个关于模$p$的乘法逆元。且$1$到$p-1$中的所有数的逆元对应$1$到$p-1$中的所有数，既是单射也是满射。</p><h1 id="逆元的求解"><a href="#逆元的求解" class="headerlink" title="逆元的求解"></a>逆元的求解</h1><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>逆元一般通过$ExGCD$求解，该方法的时间复杂度为$O(logn)$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;<span class="comment">//NOIP 同余方程    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        x = <span class="number">1</span>;    </span><br><span class="line">        y = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">return</span> a;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">int</span> gcd = <span class="built_in">exgcd</span>(b, a % b, x, y);    </span><br><span class="line">    <span class="keyword">int</span> tmp = x;    </span><br><span class="line">    x = y;    </span><br><span class="line">    y = tmp - (a/b) * y;    </span><br><span class="line">    <span class="keyword">return</span> gcd;    </span><br><span class="line">&#125;    <span class="comment">//inv[n]=(x%p+x)%p;</span></span><br></pre></td></tr></table></figure><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>当$p$为质数时，同样可以通过费马小定理求解。</p><p>已知$n^{p−1}≡1(modp)$(费马小定理)</p><p>那么$inv[n]=n^{p−2}(modp)$。该方法的时间复杂度为$O(logn)$（快速幂）。</p><h2 id="线性求前n项的逆元"><a href="#线性求前n项的逆元" class="headerlink" title="线性求前n项的逆元"></a>线性求前n项的逆元</h2><p>$$inv[n]=(p-p/n) * inv[p \ mod \ n]$$</p><h2 id="递推求前n项的阶乘逆元"><a href="#递推求前n项的阶乘逆元" class="headerlink" title="递推求前n项的阶乘逆元"></a>递推求前n项的阶乘逆元</h2><p>该方法较简单易懂，理论复杂度是上一个方法的$3$倍。据说在某些奇怪的时刻会跑的比上面快。（因为数组的连续访问）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fac为阶乘，rev为阶乘的逆元。</span></span><br><span class="line">fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">rev[N]=<span class="built_in">mod_pow</span>(fac[N],mod<span class="number">-2</span>);<span class="comment">//mod_pow为带取模的快速幂</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)rev[i]=rev[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line"><span class="comment">//可以通过阶乘逆元再一次循环求逆元</span></span><br></pre></td></tr></table></figure><h1 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h1><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>已知$\sum_{i=1}^{p-1} \frac 1 i = \frac A B $,其中$p$为奇质数，求证$A≡0(modp)$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>设$T=lcm(1,2,…,p−1)$</p><p>则有</p><p>$\sum_{i=1}^{p-1} \frac 1 i = 11/i=(T/1+T/2+…+T/(p−1))/T$</p><p>此时只需证明</p><p>$T/1+T/2+…+T/(p−1)≡0(modp)$</p><p>根据性质（见上）我们可以知道，$1$到$p-1$中所有数的逆元对应$1$到$p-1$中的所有数，则原式可以化简为</p><p>$1+2+…+(p−1)≡0(modp)$</p><p>$p∗(p−1)≡0(modp)$</p><p>得证。</p><h2 id="T2-SDOI2008-沙拉公主的困惑"><a href="#T2-SDOI2008-沙拉公主的困惑" class="headerlink" title="T2 SDOI2008 沙拉公主的困惑"></a>T2 SDOI2008 沙拉公主的困惑</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为$1$到$N$的阶乘，但是，政府只发行编号与$M!$互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对$R$取模后的答案即可。$R$是一个质数。</p><p>输入第一行为两个整数$T,R$。$R&lt;=10^9+10,T&lt;=10000$，表示该组中测试数据数目，$R$为模数。</p><p>后面$T$行，每行一对整数$N,M$，见题目描述。</p><p>输出共$T$行，对于每一对$N,M$，输出$1$至$N!$中与$M!$素质的数的数量对$R$取模后的值。</p><p>对于$100 \ percent$的数据，$1 &lt; = M &lt; = N &lt; = 10000000$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意明确$m&lt;=n$，且易知$m!|n!$那么只需要算出$\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\varphi(m!)∗n!/m!(modp)$</p><p>对于$\varphi(m!)$来说，$m!$的值过大，只能利用通项公式来求解，易知$m!$的所有质因数即为$1$到$m$中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> vis[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prime[<span class="number">500500</span>],ans[M+<span class="number">100</span>],fac[M+<span class="number">100</span>],rev[M+<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,p,T,tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;T,&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])prime[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)fac[i]=fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">    rev[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])    ans[i]=ans[i<span class="number">-1</span>]*(i<span class="number">-1</span>)%p*rev[i%p]%p;</span><br><span class="line">        <span class="keyword">else</span>                ans[i]=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fac[n]*ans[m]%p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Number Theory </tag>
            
            <tag> ExGCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI2005 维修数列</title>
      <link href="/2017/03/21/NOI2005-Sequence/"/>
      <url>/2017/03/21/NOI2005-Sequence/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/21/NOI2005%E7%BB%B4%E4%BF%AE%E6%95%B0%E5%88%97/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2042">Luogu 2042</a></p><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=pSziimjjP">COGS 339</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/GU7WeiEhcKmutQw.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立尽量平衡的结构，而不应直接插入（这样初始形态就会变成一条链），否则会导致时间复杂度过高，同时操作后也要注意更新信息。</p><p>对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。</p><p>对于求和操作，具体实现与线段树相同。</p><p>对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。</p><p>（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入$4e6$个元素，但同时也说明队列中最多只有$5e5$个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用）</p><h2 id="V1（暴力）"><a href="#V1（暴力）" class="headerlink" title="V1（暴力）"></a>V1（暴力）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> tot,root,rev[N],size[N],w[N],fa[N],son[N][<span class="number">2</span>],id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=size[son[x][<span class="number">0</span>]]+size[son[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">        rev[son[x][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">        rev[son[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">        rev[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(fa[x]),<span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],t=(son[y][<span class="number">0</span>]==x);</span><br><span class="line">    <span class="keyword">if</span>(z) son[z][son[z][<span class="number">1</span>]==y]=x;fa[x]=z;</span><br><span class="line">    son[y][!t]=son[x][t];fa[son[y][!t]]=y;</span><br><span class="line">    son[x][t]=y;fa[y]=x;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(z!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[z][<span class="number">0</span>]==y^son[y][<span class="number">0</span>]==x) <span class="built_in">zg</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">zg</span>(y);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">zg</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f) root=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++tot;</span><br><span class="line">        son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        size[x]=<span class="number">1</span>;</span><br><span class="line">        w[x]=v;fa[x]=f;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(son[x][v&gt;w[x]],v,x);</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root;</span><br><span class="line">    <span class="keyword">while</span>(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">int</span> l=son[k][<span class="number">0</span>],r=son[k][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(size[l]+<span class="number">1</span>==rank)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size[l]&gt;=rank)<span class="keyword">return</span> <span class="built_in">find</span>(l,rank);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(r,rank-size[l]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">19</span>];</span><br><span class="line"><span class="keyword">int</span> sum1,ans1,max1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])<span class="built_in">inorder</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(w[x]!=inf&amp;&amp;w[x]!=-inf)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[w[x]]);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])<span class="built_in">inorder</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inordermax</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])<span class="built_in">inordermax</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(w[x]!=inf&amp;&amp;w[x]!=-inf)</span><br><span class="line">    &#123;</span><br><span class="line">        max1=<span class="built_in">max</span>(max1,a[w[x]]);</span><br><span class="line">        sum1+=a[w[x]]*num[x];</span><br><span class="line">        <span class="keyword">if</span>(sum1&gt;<span class="number">0</span>)ans1=<span class="built_in">max</span>(ans1,sum1);</span><br><span class="line">        <span class="keyword">else</span>    sum1=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])<span class="built_in">inordermax</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,m,tmp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">insert</span>(root,-inf,<span class="number">0</span>);<span class="built_in">insert</span>(root,inf,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">insert</span>(root,i,<span class="number">0</span>);</span><br><span class="line">    tmp=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,pos,tt,x;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">find</span>(root,pos+<span class="number">1</span>),ne=<span class="built_in">find</span>(root,pos+<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">update</span>(now),<span class="built_in">update</span>(ne);</span><br><span class="line">            <span class="built_in">splay</span>(now,<span class="number">0</span>);<span class="built_in">splay</span>(ne,root);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[++tmp]),<span class="built_in">insert</span>(son[ne][<span class="number">0</span>],tmp,ne);</span><br><span class="line">            <span class="built_in">update</span>(root),<span class="built_in">update</span>(son[root][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">find</span>(root,pos),ne=<span class="built_in">find</span>(root,pos+tt+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(now,<span class="number">0</span>);<span class="built_in">splay</span>(ne,root);</span><br><span class="line">            fa[son[ne][<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">            son[ne][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">update</span>(ne);<span class="built_in">update</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;pos,&amp;tt,&amp;x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=pos+<span class="number">1</span>;t&lt;=pos+tt;++t)</span><br><span class="line">            a[w[<span class="built_in">find</span>(root,t)]]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">find</span>(root,pos),ne=<span class="built_in">find</span>(root,pos+tt+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">update</span>(now),<span class="built_in">update</span>(ne);</span><br><span class="line">            <span class="built_in">splay</span>(now,<span class="number">0</span>);<span class="built_in">splay</span>(ne,root);</span><br><span class="line">            <span class="keyword">int</span> s=son[ne][<span class="number">0</span>];</span><br><span class="line">            rev[s]^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;pos,&amp;tt);</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)</span><br><span class="line">            sum+=a[<span class="built_in">find</span>(root,pos+t)<span class="number">-2</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1=ans1=<span class="number">0</span>;max1=<span class="number">-0x7fffffff</span>;</span><br><span class="line">            <span class="built_in">inordermax</span>(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans1==<span class="number">0</span>?max1:ans1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    inorder(root);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="V2（正解）"><a href="#V2（正解）" class="headerlink" title="V2（正解）"></a>V2（正解）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,root,cnt;</span><br><span class="line"><span class="keyword">int</span> sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][<span class="number">2</span>];;</span><br><span class="line"><span class="keyword">bool</span> tag[N],rev[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sonl=son[x][<span class="number">0</span>],sonr=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(tag[x])</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sonl)tag[sonl]=<span class="literal">true</span>,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];</span><br><span class="line">        <span class="keyword">if</span>(sonr)tag[sonr]=<span class="literal">true</span>,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];</span><br><span class="line">        <span class="keyword">if</span>(v[x]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];</span><br><span class="line">            <span class="keyword">if</span>(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sonl)lx[sonl]=rx[sonl]=<span class="number">0</span>,mx[sonl]=v[x];</span><br><span class="line">            <span class="keyword">if</span>(sonr)lx[sonr]=rx[sonr]=<span class="number">0</span>,mx[sonr]=v[x];</span><br><span class="line">        &#125;</span><br><span class="line">        rev[x]=tag[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">        rev[x]^=<span class="number">1</span>;rev[sonl]^=<span class="number">1</span>;rev[sonr]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(lx[sonl],rx[sonl]);<span class="built_in">swap</span>(lx[sonr],rx[sonr]);</span><br><span class="line">        <span class="built_in">swap</span>(son[sonl][<span class="number">0</span>],son[sonl][<span class="number">1</span>]);<span class="built_in">swap</span>(son[sonr][<span class="number">0</span>],son[sonr][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])<span class="built_in">inorder</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(v[x]!=inf&amp;&amp;v[x]!=-inf)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[x]);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])<span class="built_in">inorder</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sonl=son[x][<span class="number">0</span>],sonr=son[x][<span class="number">1</span>];</span><br><span class="line">    sum[x]=sum[sonl]+sum[sonr]+v[x];</span><br><span class="line">    size[x]=size[sonl]+size[sonr]+<span class="number">1</span>;</span><br><span class="line">    mx[x]=<span class="built_in">max</span>(mx[sonl],mx[sonr]);</span><br><span class="line">    mx[x]=<span class="built_in">max</span>(mx[x],rx[sonl]+v[x]+lx[sonr]);</span><br><span class="line">    lx[x]=<span class="built_in">max</span>(lx[sonl],sum[sonl]+v[x]+lx[sonr]);</span><br><span class="line">    rx[x]=<span class="built_in">max</span>(rx[sonr],sum[sonr]+v[x]+rx[sonl]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],l,r;</span><br><span class="line">    l=(son[y][<span class="number">1</span>]==x);r=l^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==k)k=x;</span><br><span class="line">    <span class="keyword">else</span> son[z][son[z][<span class="number">1</span>]==y]=x;</span><br><span class="line">    fa[son[x][r]]=y;fa[y]=x;fa[x]=z;</span><br><span class="line">    son[y][l]=son[x][r];son[x][r]=y;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(y!=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[y][<span class="number">0</span>]==x^son[z][<span class="number">0</span>]==y)<span class="built_in">rotate</span>(x,k);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> l=son[x][<span class="number">0</span>],r=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(size[l]+<span class="number">1</span>==rk)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(size[l]&gt;=rk)<span class="keyword">return</span> <span class="built_in">find</span>(l,rk);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(r,rk-size[l]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l=son[x][<span class="number">0</span>],r=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">rec</span>(l);<span class="built_in">rec</span>(r);q.<span class="built_in">push</span>(x);</span><br><span class="line">    fa[x]=son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    tag[x]=rev[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">find</span>(root,k),y=<span class="built_in">find</span>(root,k+tt+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">splay</span>(x,root);<span class="built_in">splay</span>(y,son[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> son[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">split</span>(k,tt),y=fa[x];</span><br><span class="line">    v[x]=val;tag[x]=<span class="number">1</span>;sum[x]=size[x]*val;</span><br><span class="line">    <span class="keyword">if</span>(val&gt;=<span class="number">0</span>)lx[x]=rx[x]=mx[x]=sum[x];</span><br><span class="line">    <span class="keyword">else</span> lx[x]=rx[x]=<span class="number">0</span>,mx[x]=val;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rever</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">split</span>(k,tt),y=fa[x];</span><br><span class="line">    <span class="keyword">if</span>(!tag[x])</span><br><span class="line">    &#123;</span><br><span class="line">        rev[x]^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(lx[x],rx[x]);</span><br><span class="line">        <span class="built_in">update</span>(y);<span class="built_in">update</span>(fa[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">split</span>(k,tt),y=fa[x];</span><br><span class="line">    <span class="built_in">rec</span>(x);son[y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,now=id[mid],last=id[s];</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[now]=a[l];size[now]=<span class="number">1</span>;</span><br><span class="line">        tag[now]=rev[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[l]&gt;=<span class="number">0</span>)lx[now]=rx[now]=mx[now]=a[l];</span><br><span class="line">        <span class="keyword">else</span> lx[now]=rx[now]=<span class="number">0</span>,mx[now]=a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">build</span>(l,mid<span class="number">-1</span>,mid),<span class="built_in">build</span>(mid+<span class="number">1</span>,r,mid);</span><br><span class="line">    v[now]=a[mid];fa[now]=last;<span class="built_in">update</span>(now);</span><br><span class="line">    son[last][mid&gt;=s]=now;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;i++)</span><br><span class="line">    <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())id[i]=q.<span class="built_in">front</span>(),q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">else</span> id[i]=++cnt;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,tt,<span class="number">0</span>);<span class="keyword">int</span> z=id[(<span class="number">1</span>+tt)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">find</span>(root,k+<span class="number">1</span>),y=<span class="built_in">find</span>(root,k+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">splay</span>(x,root);<span class="built_in">splay</span>(y,son[x][<span class="number">1</span>]);</span><br><span class="line">    fa[z]=y;son[y][<span class="number">0</span>]=z;</span><br><span class="line">    <span class="built_in">update</span>(y);<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    mx[<span class="number">0</span>]=a[<span class="number">1</span>]=a[n+<span class="number">2</span>]=-inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)id[i]=i;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    root=(n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;cnt=n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> k,tt,val;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">19</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),<span class="built_in">insert</span>(k,tt);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),<span class="built_in">delet</span>(k,tt);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;X&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mx[root]);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>&amp;&amp;op[<span class="number">2</span>]==<span class="string">&#x27;K&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),val=<span class="built_in">read</span>(),<span class="built_in">modify</span>(k,tt,val);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>(),<span class="built_in">rever</span>(k,tt);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;G&#x27;</span>)&#123;k=<span class="built_in">read</span>(),tt=<span class="built_in">read</span>();<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum[<span class="built_in">split</span>(k,tt)]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        inorder(root);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Balance Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通平衡树</title>
      <link href="/2017/03/19/Normal-Balance-Tree/"/>
      <url>/2017/03/19/Normal-Balance-Tree/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/19/%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://218.28.19.228:8081/cogs/problem/problem.php?pid=vJJxmkUVP">COGS 1829</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：</p><ol><li><p>插入$x$数；</p></li><li><p>删除$x$数(若有多个相同的数，因只删除一个)；</p></li><li><p>查询$x$数的排名(若有多个相同的数，因输出最小的排名)；</p></li><li><p>查询排名为$x$的数；</p></li><li><p>求$x$的前驱(前驱定义为小于$x$，且最大的数)；</p></li><li><p>求$x$的后继(后继定义为大于$x$，且最小的数)。</p></li></ol><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为$n$，表示操作的个数，下面$n$行每行有两个数$opt$和$x$，$opt$表示操作的序号$(1&lt;=opt&lt;=6)$，$x$含义如上所示。</p><p>$n$的数据范围：$n&lt;=100000$</p><p>每个数的数据范围：$[−1e7,1e7]$（BZOJ3224:$[−2e9,2e9]$）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于操作$3,4,5,6$每行输出一个数，表示对应答案。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 106465</span><br><span class="line">4 1</span><br><span class="line">1 317721</span><br><span class="line">1 460929</span><br><span class="line">1 644985</span><br><span class="line">1 84185</span><br><span class="line">1 89851</span><br><span class="line">6 81968</span><br><span class="line">1 492737</span><br><span class="line">5 493598</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">106465</span><br><span class="line">84185</span><br><span class="line">492737</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>各种平衡树的模板题（包括SPLAY，TREAP，SBT等等。然而只会SPLAY）</p><h2 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">splay</span>&#123;</span><span class="keyword">int</span> data,ls,rs,fa,size;&#125;a[N];  </span><br><span class="line"><span class="keyword">int</span> q,root=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;a[x].size=a[a[x].ls].size+a[a[x].rs].size+<span class="number">1</span>;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> y=a[x].fa; </span><br><span class="line">    <span class="keyword">int</span> z=a[y].fa; </span><br><span class="line">    a[y].fa=x;a[x].fa=z;  </span><br><span class="line">    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  </span><br><span class="line">    <span class="keyword">if</span>(y==a[z].ls)    a[z].ls=x;</span><br><span class="line">    <span class="keyword">else</span>             a[z].rs=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=a[x].fa;  </span><br><span class="line">    <span class="keyword">int</span> z=a[y].fa;</span><br><span class="line">    a[y].fa=x,a[x].fa=z;</span><br><span class="line">    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;</span><br><span class="line">    <span class="keyword">if</span>(y==a[z].ls)     a[z].ls=x;</span><br><span class="line">    <span class="keyword">else</span>             a[z].rs=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> s)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (a[x].fa!=s)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> y=a[x].fa;  </span><br><span class="line">        <span class="keyword">int</span> z=a[y].fa;  </span><br><span class="line">        <span class="keyword">if</span>(z==s)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==a[y].ls) <span class="built_in">zig</span>(x);  </span><br><span class="line">            <span class="keyword">else</span>           <span class="built_in">zag</span>(x);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(y==a[z].ls)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(x==a[y].ls) <span class="built_in">zig</span>(y),<span class="built_in">zig</span>(x);  </span><br><span class="line">            <span class="keyword">else</span>           <span class="built_in">zag</span>(x),<span class="built_in">zig</span>(x);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(x==a[y].rs) <span class="built_in">zag</span>(y),<span class="built_in">zag</span>(x);  </span><br><span class="line">            <span class="keyword">else</span>           <span class="built_in">zig</span>(x),<span class="built_in">zag</span>(x);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(x);  </span><br><span class="line">    <span class="keyword">if</span> (s==<span class="number">0</span>) root=x;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> p,x=root;  </span><br><span class="line">    <span class="keyword">while</span> (x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        p=x;  </span><br><span class="line">        <span class="keyword">if</span> (a[x].data&gt;w) x=a[x].ls;  </span><br><span class="line">        <span class="keyword">else</span> x=a[x].rs;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> fa,<span class="keyword">int</span> key)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    x=++tot;  </span><br><span class="line">    a[x].ls=a[x].rs=<span class="number">0</span>;  </span><br><span class="line">    a[x].fa=fa;  </span><br><span class="line">    a[x].data=key;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (root==<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">newnode</span>(root,<span class="number">0</span>,w);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="built_in">Search</span>(w);  </span><br><span class="line">    <span class="keyword">if</span> (w&lt;a[i].data) <span class="built_in">newnode</span>(a[i].ls,i,w);     </span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">newnode</span>(a[i].rs,i,w);</span><br><span class="line">    <span class="built_in">splay</span>(tot,<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root,ans=tot+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[x].data&gt;w)&#123;x=a[x].ls;<span class="keyword">continue</span>;&#125;  </span><br><span class="line">        <span class="keyword">if</span>(a[x].data&lt;w)&#123;x=a[x].rs;<span class="keyword">continue</span>;&#125;  </span><br><span class="line">        <span class="keyword">if</span>(a[x].data==w)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ans=x;</span><br><span class="line">            x=a[x].ls; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(ans==tot+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">while</span>(a[x].rs)x=a[x].rs;<span class="keyword">return</span> x;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">while</span> (a[x].ls)x=a[x].ls;<span class="keyword">return</span> x;&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpre1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">getmax</span>(a[root].ls);&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getne1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">getmin</span>(a[root].rs);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">get</span>(w);  </span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">int</span> pp=<span class="built_in">getpre1</span>(x),nn=<span class="built_in">getne1</span>(x);  </span><br><span class="line">    <span class="built_in">splay</span>(pp,<span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">splay</span>(nn,root);  </span><br><span class="line">    <span class="keyword">int</span> y=a[x].fa;  </span><br><span class="line">    a[x].fa=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(x==a[y].ls) a[y].ls=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>           a[x].ls=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(root);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">get</span>(w);  </span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> a[a[x].ls].size;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findkth</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> s=a[a[x].ls].size;  </span><br><span class="line">    <span class="keyword">if</span> (k==s+<span class="number">1</span>) <span class="keyword">return</span> a[x].data;  </span><br><span class="line">    <span class="keyword">if</span> (s&gt;=k) <span class="keyword">return</span> <span class="built_in">findkth</span>(a[x].ls,k);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findkth</span>(a[x].rs,k-s<span class="number">-1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpre</span><span class="params">(<span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> y=<span class="built_in">get</span>(w);  </span><br><span class="line">    <span class="built_in">insert</span>(w);  </span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">-1</span>)<span class="built_in">splay</span>(y,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">getmax</span>(a[root].ls);  </span><br><span class="line">    <span class="built_in">delet</span>(w);  </span><br><span class="line">    <span class="keyword">return</span> a[ans].data;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getne</span><span class="params">(<span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">insert</span>(w);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">getmin</span>(a[root].rs);</span><br><span class="line">    <span class="built_in">delet</span>(w);</span><br><span class="line">    <span class="keyword">return</span> a[ans].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root=tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">insert</span>(-inf);<span class="built_in">insert</span>(inf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)       <span class="built_in">insert</span>(k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="built_in">delet</span>(k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">findkth</span>(root,k+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getpre</span>(k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getne</span>(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> tot,root,size[N],num[N],key[N],fa[N],son[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=size[son[x][<span class="number">0</span>]]+size[son[x][<span class="number">1</span>]]+num[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//push_down(fa[x]);push_down(x); </span></span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y],t=(son[y][<span class="number">0</span>]==x);</span><br><span class="line">    <span class="keyword">if</span>(z) son[z][son[z][<span class="number">1</span>]==y]=x;fa[x]=z;</span><br><span class="line">    son[y][!t]=son[x][t];fa[son[y][!t]]=y;</span><br><span class="line">    son[x][t]=y;fa[y]=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(z!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(son[z][<span class="number">0</span>]==y^son[y][<span class="number">0</span>]==x) <span class="built_in">zg</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">zg</span>(y);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">zg</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f) root=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++tot;</span><br><span class="line">        son[x][<span class="number">0</span>]=son[x][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        size[x]=num[x]=<span class="number">1</span>;</span><br><span class="line">        key[x]=v;fa[x]=f;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v==key[x])</span><br><span class="line">    &#123;</span><br><span class="line">        num[x]++;size[x]++;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(son[x][v&gt;key[x]],v,x);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=root;</span><br><span class="line">    <span class="keyword">while</span>(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">get</span>(x);<span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(num[x]&gt;<span class="number">1</span>) &#123;num[x]--;size[x]--;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!son[x][<span class="number">0</span>]||!son[x][<span class="number">1</span>]) root=son[x][<span class="number">0</span>]+son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=son[x][<span class="number">1</span>];<span class="keyword">while</span>(son[y][<span class="number">0</span>]) y=son[y][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">splay</span>(y,x);</span><br><span class="line">        son[y][<span class="number">0</span>]=son[x][<span class="number">0</span>];fa[son[y][<span class="number">0</span>]]=y;</span><br><span class="line">        root=y;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[root]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrank</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(root,v,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=size[son[root][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">delet</span>(v);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=root;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=size[son[y][<span class="number">0</span>]]||x&gt;size[son[y][<span class="number">0</span>]]+num[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=size[son[y][<span class="number">0</span>]]) y=son[y][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> x-=size[son[y][<span class="number">0</span>]]+num[y],y=son[y][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(root,v,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x=son[root][<span class="number">0</span>];<span class="keyword">while</span>(son[x][<span class="number">1</span>]) x=son[x][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">delet</span>(v);</span><br><span class="line">    <span class="keyword">return</span> key[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ne</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(root,v,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> x=son[root][<span class="number">1</span>];<span class="keyword">while</span>(son[x][<span class="number">0</span>]) x=son[x][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">delet</span>(v);</span><br><span class="line">    <span class="keyword">return</span> key[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)         <span class="built_in">insert</span>(root,y,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">2</span>)         <span class="built_in">delet</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">3</span>)         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getrank</span>(y));</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">4</span>)         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">kth</span>(y));</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">5</span>)         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">pre</span>(y));</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">6</span>)        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ne</span>(y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Balance Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ2778 DNA Sequence</title>
      <link href="/2017/03/18/DNA-Sequence/"/>
      <url>/2017/03/18/DNA-Sequence/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/18/DNA%20Sequence/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://poj.org/problem?id=2778">POJ 2778</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments.</p><p>Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. </p><p>First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.</p><p>Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. </p><p>Output An integer, the number of DNA sequences, mod 100000.</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">AT</span><br><span class="line">AC</span><br><span class="line">AG</span><br><span class="line">AA</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目大意为给定$n$个病毒串，求不包含这些病毒串且长度为$m$的资源串个数（均由A,G,C,T组成）。</p><p>这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即$res[i][t]$存的是从$i$到$t$恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res′=res^m$时，$res′[i][t]$表示从$i$到$t$恰好走$m$步能到达的方案数。</p><p>有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点$0$<br>到叶节点$i$的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其$fail$指针指向病毒串），只需要传递一下即可。</p><p>刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又$TLE$了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。（看来当时还没理解AC自动机的原理）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N =<span class="number">200</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod =<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf =<span class="number">255</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,tr[N][<span class="number">4</span>],tot,tmp,fail[N];</span><br><span class="line"><span class="keyword">int</span> idd[N];</span><br><span class="line"><span class="keyword">bool</span> tag[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ss[<span class="number">4</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">martix</span>&#123;</span><span class="keyword">long</span> <span class="keyword">long</span> a[N][N];&#125;res,ans;</span><br><span class="line">martix <span class="keyword">operator</span> * (martix c,martix b)</span><br><span class="line">&#123;</span><br><span class="line">    martix ret;</span><br><span class="line">    <span class="built_in">memset</span>(ret.a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ret.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;=tot;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=tot;++k)</span><br><span class="line">        ret.a[i][t]+=c.a[i][k]*b.a[k][t];</span><br><span class="line">        ret.a[i][t]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;idd[ss[<span class="number">0</span>]]=<span class="number">0</span>;idd[ss[<span class="number">1</span>]]=<span class="number">1</span>;idd[ss[<span class="number">2</span>]]=<span class="number">2</span>;idd[ss[<span class="number">3</span>]]=<span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now][idd[s[i]]]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[now][idd[s[i]]]=++tot;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)tr[tot][j]=<span class="number">-1</span>;    </span><br><span class="line">        <span class="comment">//    tag[tot]=0;</span></span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][idd[s[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[now]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;fail[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">0</span>][j]!=<span class="number">-1</span>)q.<span class="built_in">push</span>(tr[<span class="number">0</span>][j]),fail[tr[<span class="number">0</span>][j]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tr[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tag[fail[x]])tag[x]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">        <span class="keyword">if</span>(tr[x][j]!=<span class="number">-1</span>)fail[tr[x][j]]=tr[fail[x]][j],q.<span class="built_in">push</span>(tr[x][j]);    </span><br><span class="line">        <span class="keyword">else</span> tr[x][j] =tr[fail[x]][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">    <span class="keyword">if</span>(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)tr[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="built_in">getfail</span>();</span><br><span class="line">    <span class="built_in">slove</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;++i)ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;cout&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m&amp;<span class="number">1</span>) ans=ans*res;</span><br><span class="line">        m/=<span class="number">2</span>;</span><br><span class="line">        res=res*res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> anss=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;++i)(anss+=ans.a[<span class="number">0</span>][i])%=mod;</span><br><span class="line">    cout&lt;&lt;anss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AC Automaton </tag>
            
            <tag> String Manipulation </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>病毒侵袭</title>
      <link href="/2017/03/17/AC-template/"/>
      <url>/2017/03/17/AC-template/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/17/%E7%97%85%E6%AF%92%E5%85%A5%E4%BE%B5/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2896">HDU 2896</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~</p><p>但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。</p><p>万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个整数$N(1&lt;=N&lt;=500)$，表示病毒特征码的个数。</p><p>接下来$N$行，每行表示一个病毒特征码，特征码字符串长度在$20—200$之间。</p><p>每个病毒都有一个编号，依此为$1 \sim N$。</p><p>不同编号的病毒特征码不会相同。</p><p>在这之后一行，有一个整数$M（1&lt;=M&lt;=1000）$，表示网站数。</p><p>接下来$M$行，每行表示一个网站源码，源码字符串长度在$7000—10000$之间。</p><p>每个网站都有一个编号，依此为$1 \sim M$。</p><p>以上字符串中字符都是$ASCII$码可见字符（不包括回车）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web 网站编号: 病毒编号 病毒编号 ...</span><br></pre></td></tr></table></figure><p>冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。</p><p>最后一行输出统计信息，如下格式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">total: 带病毒网站数</span><br></pre></td></tr></table></figure><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">2</span><br><span class="line">aaabbbccc</span><br><span class="line">bbaacc</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web 1: 1 2 3</span><br><span class="line">total: 1</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>AC自动机模板题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">501</span>*<span class="number">201</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1001</span>],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">bool</span> use[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> noww)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[now][s[i]]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[now][s[i]]=++tot;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxf;++j)tr[tot][j]=<span class="number">-1</span>;</span><br><span class="line">            tag[tot]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[now]=noww;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxf;++i)</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">0</span>][i]!=<span class="number">-1</span>)</span><br><span class="line">    fail[tr[<span class="number">0</span>][i]]=<span class="number">0</span>,q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">else</span> tr[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxf;++j)</span><br><span class="line">        <span class="keyword">if</span>(tr[x][j]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;q.<span class="built_in">push</span>(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        tr[x][j]=tr[fail[x]][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> noww)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(use,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(use));</span><br><span class="line">    tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        now=tr[now][s[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=now;j;j=fail[j])</span><br><span class="line">        <span class="keyword">if</span>(tag[j]&amp;&amp;!use[tag[j]])</span><br><span class="line">        ans[++tmp]=tag[j],use[tag[j]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        ans2++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;web %d:&quot;</span>,noww);</span><br><span class="line">        <span class="built_in">sort</span>(ans+<span class="number">1</span>,ans+tmp+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tmp;++j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,ans[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxf;++i)tr[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="built_in">getfail</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s),<span class="built_in">solve</span>(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;total: %d\n&quot;</span>,ans2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AC Automaton </tag>
            
            <tag> String Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟赛 2017-03-17</title>
      <link href="/2017/03/17/NOIP-2017-3-17/"/>
      <url>/2017/03/17/NOIP-2017-3-17/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/17/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B%202017%203%2017/">原文</a>）</p></div><h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问题。今天，他想到了一个十分有意思的题目：</p><p>首先，花花会在$x$轴正半轴和$y$轴正半轴分别挑选$n$个点。随后，他将$x$轴的点与$y$轴的点一一连接，形成$n$条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅有一种。最后，花花会给出$m$个询问。对于每个询问，将会给定一个点$P(x_p,y_p)$，问线段$OP$（$O$ 为坐标原点）与$n$条线段会产生多少个交点？</p><p>输入第 $1$ 行包含一个正整数 $n$，表示线段的数量；</p><p>第 $2$ 行包含 $n$ 个正整数，表示花花在 $x$ 轴选取的点的横坐标；</p><p>第 $3$ 行包含 $n$ 个正整数，表示花花在 $y$ 轴选取的点的纵坐标；</p><p>第 $4$ 行包含一个正整数 $m$，表示询问数量；</p><p>随后 $m$ 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 5 3</span><br><span class="line">3 5 4</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $40 \ percent $ 的数据：$n,m ≤ 10$</p><p>另有 $20 \ percent $ 的数据：$n,m ≤ 100$</p><p>另有 $20 \ percent $ 的数据：$n,m ≤ 1000$</p><p>对于 $100 \ percent $ 的数据：$n,m ≤ 10^5,y &lt; 2^{31}$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y_p$ 与 $y_mid$ 大小即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x[N],y[N];</span><br><span class="line"><span class="keyword">double</span> a[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">get</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">get</span>(x[i]);<span class="built_in">sort</span>(x+<span class="number">1</span>,x+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">get</span>(y[i]);<span class="built_in">sort</span>(y+<span class="number">1</span>,y+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,xx,yy;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span>(xx);<span class="built_in">get</span>(yy);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n,mid;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));</span><br><span class="line">            <span class="keyword">double</span> yt=a[mid]*(db)xx+y[mid];</span><br><span class="line">            <span class="keyword">if</span>(yt&lt;=(db)yy) l=mid;</span><br><span class="line">            <span class="keyword">else</span>          r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="花花的聚会"><a href="#花花的聚会" class="headerlink" title="花花的聚会"></a>花花的聚会</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>花花住在 H 国。H 国有 $n$ 个城市，其中 $1$ 号城市为其首都。城市间有$n − 1$条单向道路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市走到首都的路径是唯一的。</p><p>过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 $m$ 种过路券，每张过路券以三个整数表示：$v,k,w$：你可以在城市 $v$ 以价格 $w$ 买到一张过路券。这张券可以使用 $k$ 次。这意味着，拿着这张券通过了 $k$ 条道路之后，这张券就不能再使用了。</p><p>请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，并且在所在的城市再买一张。</p><p>花花家在首都。他有 $q$ 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。</p><p>花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮他么？</p><p>输入的第一行包含两个空格隔开的整数 $n$ 和 $m$，表示 H 国的城市数量和过路券的种数。</p><p>之后的 $n − 1$ 行各自包含两个数 $a_i$ 和 $b_i$ ，代表城市 $a_i$ 到城市 $b_i$ 间有一条单向道路。</p><p>之后的 $m$ 行每行包括三个整数 $v_i$ ,$k_i$ 和 $w_i$ ，表示一种过路券。</p><p>下一行包含一个整数 $q$，表示花花朋友的数量。</p><p>之后的 $q$ 行各自包含一个整数，表示花花朋友的所在城市。</p><p>输出共 $q$ 行，每一行代表一位朋友的路费。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7</span><br><span class="line">3 1</span><br><span class="line">2 1</span><br><span class="line">7 6</span><br><span class="line">6 3</span><br><span class="line">5 3</span><br><span class="line">4 3</span><br><span class="line">7 2 3</span><br><span class="line">7 1 1</span><br><span class="line">2 3 5</span><br><span class="line">3 6 2</span><br><span class="line">4 2 4</span><br><span class="line">5 3 10</span><br><span class="line">6 1 20</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">22</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $40 \ percent$ 的数据：$n,m,q ≤ 10,w_i ≤ 10$</p><p>另有 $20 \ percent$ 的数据：$n,m,q ≤ 500,w_i ≤ 100$</p><p>另有 $20 \ percent$ 的数据：$n,m,q ≤ 5000,w_i ≤ 1000$</p><p>对于 $100 \ percent$ 的数据：$n,m,q ≤ 10^5 ,w_i ≤ 10000,1 ≤ v_i,k_i ≤ n$</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：</p><p>$$f[y] = min {\lbrace f[x] + w[y][i] \rbrace} ( x 为 y 祖先, dep[x] - dep[y] &gt; = k[y][i] )$$</p><p>对于寻找$min \lbrace f[x] \rbrace $的操作，则可以通过倍增或树链剖分的方法实现。(要开 $long long$ 不然会爆)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxlogn =<span class="number">21</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> deep[N],head[N],head2[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> st[N][maxlogn],minn[N][maxlogn],f[N];</span><br><span class="line"><span class="keyword">int</span> tot,tot2,n,m,qu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edg</span>&#123;</span><span class="keyword">int</span> t,ne;&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edg2</span>&#123;</span><span class="keyword">int</span> k,w,ne;&#125;e2[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].ne=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e2[++tot2].k=k;</span><br><span class="line">    e2[tot2].w=w;</span><br><span class="line">    e2[tot2].ne=head2[x];</span><br><span class="line">    head2[x]=tot2;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[x][<span class="number">0</span>]=pre;minn[x][<span class="number">0</span>]=f[pre];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxlogn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[x][i]=st[st[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        minn[x][i]=<span class="built_in">min</span>(minn[x][i<span class="number">-1</span>],minn[st[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=x==<span class="number">1</span>?<span class="number">0</span>:inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head2[x];i;i=e2[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp=inf,y=x,k=e2[i].k,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>)tmp=<span class="built_in">min</span>(tmp,minn[y][p]),y=st[y][p];</span><br><span class="line">            p++;k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x]=<span class="built_in">min</span>(f[x],tmp+e2[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(y!=pre)<span class="built_in">getf</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;party.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;party.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">in</span>(x,y),<span class="built_in">in</span>(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,k,w;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;k,&amp;w),<span class="built_in">in2</span>(x,k,w);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;qu);<span class="built_in">getf</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=qu;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[x]);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一些功能。</p><p>功能列表如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; w</span><br><span class="line"></span><br><span class="line">w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。</span><br><span class="line">该命令将选定光标向左移动，如果已经是最左端则不移动。</span><br><span class="line">命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。</span><br><span class="line"></span><br><span class="line">&gt; w</span><br><span class="line"></span><br><span class="line">w 同上。</span><br><span class="line">与&lt; 命令不同的是，该命令将光标向右移动。</span><br><span class="line">命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。</span><br><span class="line"></span><br><span class="line">I w c</span><br><span class="line"></span><br><span class="line">w 同上。</span><br><span class="line">c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。</span><br><span class="line">该命令始终输出“T”。</span><br><span class="line"></span><br><span class="line">D w</span><br><span class="line"></span><br><span class="line">w 同上。</span><br><span class="line">代表删除该光标右侧的一个字符。</span><br><span class="line">命令执行成功时输出“T”，若光标右侧没有字符输出“F”。</span><br><span class="line"></span><br><span class="line">R</span><br><span class="line"></span><br><span class="line">代表翻转左光标和右光标之间的字符。</span><br><span class="line">该命令只有左光标在右光标左侧时才能执行。</span><br><span class="line">（两光标重合时也不能执行）</span><br><span class="line">命令执行成功时输出“T”，否则输“F”。</span><br><span class="line"></span><br><span class="line">S</span><br><span class="line"></span><br><span class="line">代表显示当前处理的文本。</span><br><span class="line">该命令只输出文本，不输出“T”和“F”。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。</p><p>注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。</p><p>输入第一行是初始时文本编辑器内容。</p><p>第二行是一个正整数 $N$，$N$ 表示操作次数。</p><p>接下来有 $N$ 行，每行有一个命令，命令格式如上方表格。</p><p>对于每个命令，按上方表格要求执行并输出。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goodykc</span><br><span class="line">11</span><br><span class="line">I R u</span><br><span class="line">I R l</span><br><span class="line">&gt; L</span><br><span class="line">&gt; L</span><br><span class="line">&gt; L</span><br><span class="line">&gt; L</span><br><span class="line">R</span><br><span class="line">D R</span><br><span class="line">&lt; R</span><br><span class="line">D R</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">goodluck</span><br></pre></td></tr></table></figure><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $40 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $≤ 100$，数据不包含翻转（Reverse）操作；</p><p>另有 $30 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $ ≤ 10^5$ ，数据不包含翻转（Reverse）操作；</p><p>另有 $20 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $ ≤ 10^5$ ，数据包含翻转（Reverse）操作；</p><p>对于 $100 \ percent$ 的数据：$1 ≤ N$ , 初始文本长度 $ ≤ 4 × 10^6$ ，输出文件大小 $≤ 20MB$。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。</p><p>具体的实现代码十分清楚，但还有许多细节要注意，因为 $l,r$ 的相对位置可能互换，所以只能写左开右开或左闭右闭区间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot,m,pos[<span class="number">2</span>],cnt[<span class="number">2</span>],pre[N],next[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> opreator,ch[N],str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">()</span></span>&#123;<span class="built_in">getchar</span>();<span class="keyword">return</span> <span class="built_in">getchar</span>()==<span class="string">&#x27;L&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> opreator,<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    ch[tot]=c;</span><br><span class="line">    <span class="keyword">int</span> u=pos[opreator],v=next[u];</span><br><span class="line"></span><br><span class="line">    pre[tot]=u;next[tot]=v;</span><br><span class="line">    next[u]=tot;pre[v]=tot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt[opreator^<span class="number">1</span>]&gt;=cnt[opreator])cnt[opreator^<span class="number">1</span>]++;</span><br><span class="line"></span><br><span class="line">    pos[opreator]=tot;cnt[opreator]++;</span><br><span class="line">    <span class="keyword">if</span> (pos[opreator^<span class="number">1</span>]==u)pos[opreator^<span class="number">1</span>]=tot;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll</span><span class="params">(<span class="keyword">int</span> opreator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[opreator]==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> u=pos[opreator],v=pre[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next[v]!=u)<span class="built_in">swap</span>(next[v],pre[v]);</span><br><span class="line"></span><br><span class="line">    pos[opreator]=v; cnt[opreator]--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rl</span><span class="params">(<span class="keyword">int</span> opreator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next[pos[opreator]]==<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> u=next[pos[opreator]],v=next[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre[v]!=u)<span class="built_in">swap</span>(next[v],pre[v]);</span><br><span class="line"></span><br><span class="line">    pos[opreator]=u;cnt[opreator]++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D</span><span class="params">(<span class="keyword">int</span> opreator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next[pos[opreator]]== <span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> u = pos[opreator], v = next[u], w = next[v];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre[w]!=v) <span class="built_in">swap</span>(next[w], pre[w]);</span><br><span class="line">    <span class="keyword">if</span> (cnt[opreator^<span class="number">1</span>]&gt;cnt[opreator])cnt[opreator^<span class="number">1</span>]--;</span><br><span class="line">    <span class="keyword">if</span> (pos[opreator^<span class="number">1</span>]==v)pos[opreator^<span class="number">1</span>]=u;</span><br><span class="line"></span><br><span class="line">    next[u]= w;pre[w]=u;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[<span class="number">1</span>]-cnt[<span class="number">0</span>]&lt;=<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;F\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt[<span class="number">1</span>]-cnt[<span class="number">0</span>]==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> now=pos[<span class="number">0</span>],ne=next[now],c=pos[<span class="number">1</span>],d=next[c];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(pre[ne], next[ne]);<span class="built_in">swap</span>(pre[c],next[c]);</span><br><span class="line">    next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;</span><br><span class="line">    pos[<span class="number">1</span>]=ne;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[next[u]]!= u)<span class="built_in">swap</span>(pre[next[u]],next[next[u]]);</span><br><span class="line">        u=next[u];</span><br><span class="line">        <span class="keyword">if</span> (u==<span class="number">2</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(ch[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">2</span>;</span><br><span class="line">    pre[<span class="number">1</span>]=<span class="number">-1</span>;next[<span class="number">1</span>]= <span class="number">2</span>;</span><br><span class="line">    pre[<span class="number">2</span>]=<span class="number">1</span>;next[<span class="number">2</span>]=<span class="number">-1</span>;</span><br><span class="line">    pos[<span class="number">0</span>]=pos[<span class="number">1</span>]=cnt[<span class="number">0</span>]=cnt[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        ch[tot]=str[i];</span><br><span class="line">        pre[tot]= i==<span class="number">0</span>?<span class="number">1</span>:tot<span class="number">-1</span>;</span><br><span class="line">        next[tot]= i==len<span class="number">-1</span>?<span class="number">2</span>:tot+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next[<span class="number">1</span>]=<span class="number">3</span>;pre[<span class="number">2</span>]=tot;</span><br><span class="line">        pos[<span class="number">1</span>]=tot;cnt[<span class="number">1</span>]=len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">act</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(opreator==<span class="string">&#x27;&lt;&#x27;</span>)         <span class="built_in">ll</span>(<span class="built_in">move</span>());</span><br><span class="line">    <span class="keyword">if</span>(opreator==<span class="string">&#x27;&gt;&#x27;</span>)         <span class="built_in">rl</span>(<span class="built_in">move</span>());</span><br><span class="line">    <span class="keyword">if</span>(opreator==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="built_in">move</span>();</span><br><span class="line">        <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (c&lt;<span class="number">33</span>||c&gt;<span class="number">126</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">in</span>(d,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opreator==<span class="string">&#x27;D&#x27;</span>)         <span class="built_in">D</span>(<span class="built_in">move</span>());</span><br><span class="line">    <span class="keyword">if</span> (opreator==<span class="string">&#x27;R&#x27;</span>)         <span class="built_in">R</span>();</span><br><span class="line">    <span class="keyword">if</span> (opreator==<span class="string">&#x27;S&#x27;</span>)         <span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        opreator=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span> (opreator!=<span class="string">&#x27;&lt;&#x27;</span>&amp;&amp; opreator!=<span class="string">&#x27;&gt;&#x27;</span>&amp;&amp;!(opreator &gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp; opreator &lt;=<span class="string">&#x27;Z&#x27;</span>))opreator=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">act</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Chain Subdivision </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Linked List </tag>
            
            <tag> Computation Geometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAOI2007 理想的正方形</title>
      <link href="/2017/03/14/HAOI2007-square/"/>
      <url>/2017/03/14/HAOI2007-square/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/14/%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2216">Luogu 2216</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/Tnt2a1BP8wdcMIV.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二维滑动窗口，先对每一行建立双端队列，记录每一个$1*n$的长方体中的极值，将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n*1$的长方体(在原矩阵中为$n*n$的正方形)中的极值（$miny[i][t],maxy[i][t]$存储的是以$(i,t)$为右下角端点的$n*n$正方形的极值信息），枚举即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e3</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];</span><br><span class="line"><span class="keyword">int</span> y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];</span><br><span class="line"><span class="keyword">int</span> mapp[N][N],a,b,n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=inf;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get</span>(a),<span class="built_in">get</span>(b),<span class="built_in">get</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)<span class="built_in">get</span>(mapp[i][t]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--;</span><br><span class="line">        x1[++tailx1[i]]=t;</span><br><span class="line">        <span class="keyword">while</span>(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++;</span><br><span class="line">        minx[i][t]=mapp[i][x1[headx1[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--;</span><br><span class="line">        x2[++tailx2[i]]=t;</span><br><span class="line">        <span class="keyword">while</span>(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++;</span><br><span class="line">        maxx[i][t]=mapp[i][x2[headx2[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--;</span><br><span class="line">        y1[++taily1[t]]=i;</span><br><span class="line">        <span class="keyword">while</span>(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++;</span><br><span class="line">        miny[i][t]=minx[y1[heady1[t]]][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--;</span><br><span class="line">        y2[++taily2[t]]=i;</span><br><span class="line">        <span class="keyword">while</span>(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++;</span><br><span class="line">        maxy[i][t]=maxx[y2[heady2[t]]][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">if</span>(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟赛 2017-03-12</title>
      <link href="/2017/03/12/NOIP-2017-3-12/"/>
      <url>/2017/03/12/NOIP-2017-3-12/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/13/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B%202017%203%2012/">原文</a>）</p></div><h1 id="Blue"><a href="#Blue" class="headerlink" title="Blue"></a>Blue</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。</p><p>他最近开始研究青蛙过河的问题，可以简化成：数轴上 $0$ 为岸边，$L$ 为河对岸。$(0,L)$中间存在 $n$ 个石子。已知青蛙一跳可以跳距离 $D$，而且不能沾水。求问能不能跳到河对岸。</p><p>当然他觉得这个问题非常 naïve，于是在思考如果青蛙有$m$个，且石头被踩过之后就会沉下去，$m$ 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。</p><p>输入第一行为一个正整数 $T$ 代表数据组数。每组数据第一行四个正整数：$n、m、D、L$。</p><p>第二行 $n$ 个升序正整数 $a_i$ 代表第 $i$ 个石子坐标为 $a_i$。保证没有重复且都小于 $L$。</p><p>输出 $T$ 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10 9 16 30</span><br><span class="line">2 4 6 9 11 15 18 19 25 27 </span><br><span class="line">10 1 23 30</span><br><span class="line">10 11 13 14 15 16 18 26 27 29 </span><br><span class="line">10 7 28 30</span><br><span class="line">2 3 7 9 12 15 20 24 27 28 </span><br><span class="line">10 3 18 30</span><br><span class="line">1 6 9 14 18 19 22 27 28 29 </span><br><span class="line">10 7 10 30</span><br><span class="line">1 2 4 6 18 19 20 22 23 26 </span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">Excited</span><br><span class="line">Excited</span><br><span class="line">Excited</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$10 \ percent$的数据保证 $m=1$</p><p>对于另外$10 \ percent$的数据保证 $D=L$</p><p>对于另外$10 \ percent$的数据保证 $n=L−1$</p><p>对于另外$30 \ percent$的数据保证 $n&lt;=100,L&lt;=10^5$</p><p>对于$100 \ percent$的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$</p><p>数据范围中的 $n、m$ 皆代表题目描述中 $n、m$ 的总和。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和$d$的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。</p><p>具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了…</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tt,n,m,d,l,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)b[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> anss=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">1</span>;now&lt;=n;++now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[now]-b[++anss]&lt;=d)b[anss]=a[now];</span><br><span class="line">        <span class="keyword">if</span>(anss==ans)anss=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)</span><br><span class="line">    <span class="keyword">if</span>(l-b[i]&gt;d)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(d),<span class="built_in">read</span>(l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">int</span> ll=<span class="number">0</span>,rr=m,mid;</span><br><span class="line">        <span class="keyword">while</span>(ll!=rr)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=ll+rr+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid))    ll=mid;</span><br><span class="line">            <span class="keyword">else</span>            rr=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rr==m)    <span class="built_in">printf</span>(<span class="string">&quot;Excited\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Weed"><a href="#Weed" class="headerlink" title="Weed"></a>Weed</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。</p><p>为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。</p><p>电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为$v_i$的金坷垃，或者除掉最新$v_i$层（不是量）撒的金坷垃。如果上面只留有不足$v_i$层金坷垃，那么就相当于电脑上面没有金坷垃了。</p><p>duyege非常严谨，一开始先给你$m$个上述操作要你依次完成。然后又对实验步骤进行了$q$次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最终金坷垃的量有多少。</p><p>输入第一行为两个正整数$m、q$，接下来$m$行每行$2$个整数$k、v_i$。$k$为$0$时撒金坷垃，为$1$时除金坷垃。接下来$q$行每行$3$个整数$c_i、k、v_i$，$c_i$代表被更改的操作是第$c_i$个，后面$2$个数描述更改为这样的操作。</p><p>输出 $q$ 行代表每次金坷垃的量为多少。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">0 10</span><br><span class="line">1 5</span><br><span class="line">0 13</span><br><span class="line">0 18</span><br><span class="line">0 2</span><br><span class="line">1 1</span><br><span class="line">0 8</span><br><span class="line">0 9</span><br><span class="line">1 3</span><br><span class="line">0 7</span><br><span class="line">9 0 3</span><br><span class="line">10 1 7</span><br><span class="line">6 0 8</span><br><span class="line">10 0 5</span><br><span class="line">8 1 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">58</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">66</span><br><span class="line">41</span><br></pre></td></tr></table></figure><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$30 \ percent$的数据，$m&lt;=1000,q&lt;=1000$</p><p>对于另外$20 \ percent$的数据，每次 $k=1$ 时都会将金坷垃清空。</p><p>对于$100 \ percent$的数据，$m&lt;=2*10^5,q&lt;=2*10^5,v_i&lt;=10^4$</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现…</p><p>题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build</span>&#123;</span><span class="keyword">int</span> sum,in,out;&#125;tr[<span class="number">8</span>*N];</span><br><span class="line"><span class="keyword">int</span> n,q,k,a[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pot&gt;=tr[x].in)            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!pot)                    <span class="keyword">return</span> tr[x].sum;</span><br><span class="line">    <span class="keyword">if</span>(pot&lt;=tr[x*<span class="number">2</span>+<span class="number">1</span>].in)</span><br><span class="line">    <span class="keyword">return</span> tr[x].sum-tr[x*<span class="number">2</span>+<span class="number">1</span>].sum+<span class="built_in">find</span>(x*<span class="number">2</span>+<span class="number">1</span>,pot);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x*<span class="number">2</span>,pot-tr[x*<span class="number">2</span>+<span class="number">1</span>].in+tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].in=tr[x*<span class="number">2</span>+<span class="number">1</span>].in+<span class="built_in">max</span>(<span class="number">0</span>,tr[x*<span class="number">2</span>].in-tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">    tr[x].out=tr[x*<span class="number">2</span>].out+<span class="built_in">max</span>(<span class="number">0</span>,tr[x*<span class="number">2</span>+<span class="number">1</span>].out-tr[x*<span class="number">2</span>].in);</span><br><span class="line">    tr[x].sum=tr[x*<span class="number">2</span>+<span class="number">1</span>].sum+<span class="built_in">find</span>(x*<span class="number">2</span>,tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l]&lt;<span class="number">0</span>)    tr[x].out=-a[l];</span><br><span class="line">        <span class="keyword">else</span>        tr[x].in=<span class="number">1</span>,tr[x].sum=a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x*<span class="number">2</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(x*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pot,<span class="keyword">int</span> w,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;tr[x],<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[x]));</span><br><span class="line">        <span class="keyword">if</span>(w&lt;<span class="number">0</span>)        tr[x].out=-w;</span><br><span class="line">        <span class="keyword">else</span>        tr[x].in=<span class="number">1</span>,tr[x].sum=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pot&gt;mid)    <span class="built_in">change</span>(x*<span class="number">2</span>+<span class="number">1</span>,pot,w,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">else</span>        <span class="built_in">change</span>(x*<span class="number">2</span>,pot,w,l,mid);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(k),<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(k)a[i]*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,w;</span><br><span class="line">        <span class="built_in">read</span>(x);<span class="built_in">read</span>(k);<span class="built_in">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span>(k)w*=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,x,w,<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Drink"><a href="#Drink" class="headerlink" title="Drink"></a>Drink</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个遥远的国度有一个腰缠万贯的资本家Link，每一个拜访他的人都可以得到一份丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了Link家。Link智商超群（不然也赚不到这么多资本），所以决定用特殊的方法赏赐毒液哥。</p><p>Link的藏宝库是一个$N * M$棋盘，每个格子里都有宝物。Link会对棋盘做$Q$次操作，每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转$90$度）。毒液哥不仅财富值被Link碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财的他想知道最后棋盘内所有的宝物价值以方便他挑选。</p><p>作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）和资产阶级代表（Link）之间的贫富差距么。</p><p>输入第一行三个数 $N, M, Q$ 分别表示棋盘的行数、列数和操作个数。</p><p>接下来 $N$ 行每行 $M$ 个数表示一开始棋盘上宝物的价值。</p><p>接下来 $Q$ 行每行 $3$ 个数 $x, y, c$ 表示操作区域为以第 $x$ 行第 $y$ 列为左上角的边长为 $c$ 的正方形。</p><p>输出一个 $N * M$ 的矩阵表示最后的棋盘。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">1 1 3</span><br><span class="line">3 3 2</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 5 1 4 </span><br><span class="line">2 7 6 8 </span><br><span class="line">3 7 2 3 </span><br><span class="line">5 6 8 4 </span><br></pre></td></tr></table></figure><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $30 \ percent$的数据，$N, M, Q &lt;= 100$.</p><p>对于另外 $30 \ percent$的数据，保证所有 $Q$ 个正方形两两之间不相交或相等。</p><p>对于 $100 \ percent$的数据, $N, M, Q &lt;= 1000$，棋盘内所有数取值都为 $0 ~ 9$。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（$p=0$），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（$p=(p+1)%4$），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @Author: 閫搁棽</span></span><br><span class="line"><span class="comment">* @Date:   2016-09-25 13:04:44</span></span><br><span class="line"><span class="comment">* @Last Modified by:   閫搁棽</span></span><br><span class="line"><span class="comment">* @Last Modified time: 2016-10-01 10:19:00</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstdio&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstdlib&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstring&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 2005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Eps</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Get(x, a) (x ? x -&gt; a : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Num = <span class="number">0</span>, Flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            Flag = -Flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        Num = Num * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> Num * Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">int</span> A[MAX_SIZE * MAX_SIZE][<span class="number">4</span>], Map[MAX_SIZE][MAX_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> &amp;Direction, <span class="keyword">int</span> &amp;Now, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Next = A[Now][j - Direction + <span class="number">4</span> &amp; <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(Direction = <span class="number">0</span>; A[Next][j - Direction + <span class="number">6</span> &amp; <span class="number">3</span>] != Now; ++Direction);</span><br><span class="line">    Now = Next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="comment">//    freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            Map[i][j] = <span class="built_in">Get_Int</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (N + <span class="number">2</span>) * (M + <span class="number">2</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][<span class="number">0</span>] = i - M - <span class="number">2</span>;</span><br><span class="line">        A[i][<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        A[i][<span class="number">2</span>] = i + M + <span class="number">2</span>;</span><br><span class="line">        A[i][<span class="number">3</span>] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">Get_Int</span>(), y = <span class="built_in">Get_Int</span>(), c = <span class="built_in">Get_Int</span>();</span><br><span class="line">        <span class="keyword">int</span> Direction = <span class="number">0</span>, Now = <span class="number">1</span>;</span><br><span class="line">        vector&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; Border[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line">            <span class="built_in">Move</span>(Direction, Now, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; ++i)</span><br><span class="line">            <span class="built_in">Move</span>(Direction, Now, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Border[j][<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(Direction, Now));</span><br><span class="line">                <span class="built_in">Move</span>(Direction, Now, j);</span><br><span class="line">                Border[j][<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(Direction, Now));</span><br><span class="line">                <span class="built_in">Move</span>(Direction, Now, j + <span class="number">2</span> &amp; <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(i != c)</span><br><span class="line">                    <span class="built_in">Move</span>(Direction, Now, j + <span class="number">1</span> &amp; <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Now = Border[j][<span class="number">1</span>][i];</span><br><span class="line">                A[Now.second][j + <span class="number">6</span> - Now.first &amp; <span class="number">3</span>] = Border[j + <span class="number">3</span> &amp; <span class="number">3</span>][<span class="number">0</span>][i].second;</span><br><span class="line">                Now = Border[j][<span class="number">0</span>][i];</span><br><span class="line">                A[Now.second][j + <span class="number">4</span> - Now.first &amp; <span class="number">3</span>] = Border[j + <span class="number">1</span> &amp; <span class="number">3</span>][<span class="number">1</span>][i].second;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Direction = <span class="number">0</span>, Now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Move</span>(Direction, Now, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = Direction, Next = Now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Move</span>(temp, Next, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Map[(Next - <span class="number">1</span>) / (M + <span class="number">2</span>)][(Next - <span class="number">1</span>) % (M + <span class="number">2</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Segment Tree </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCOI2010 股票交易</title>
      <link href="/2017/03/11/SCOI2010-stock/"/>
      <url>/2017/03/11/SCOI2010-stock/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/11/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2569">Luogu 2569</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/1CEApHJgZcvU6Xs.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="o-t∗maxp-2-算法"><a href="#o-t∗maxp-2-算法" class="headerlink" title="$o(t∗maxp^2)$算法"></a>$o(t∗maxp^2)$算法</h2><p>$o(t∗maxp^2)$算法有70分，还是比较良心的。</p><p>这题转移方程也不难想，可以设$dp[i][j]$为第$i$天后手中还剩$t$张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买$3$张股票，那么$dp[1][4]$是便是无效的，不妨将$dp$数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2017</span>;</span><br><span class="line"><span class="keyword">int</span> n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;maxp,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,ap+i,bp+i,as+i,bs+i);</span><br><span class="line">  <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;<span class="comment">//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j]);<span class="comment">//该天没有操作</span></span><br><span class="line">          <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;=<span class="built_in">min</span>(j+bs[i],maxp);++k)</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][k]+(k-j)*bp[i]);<span class="comment">//卖出</span></span><br><span class="line">          <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="built_in">max</span>(j-as[i],<span class="number">0</span>);k&lt;j;++k)</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][k]-(j-k)*ap[i]);<span class="comment">//买入</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="o-t∗maxp-算法（单调队列）"><a href="#o-t∗maxp-算法（单调队列）" class="headerlink" title="$o(t∗maxp)$算法（单调队列）"></a>$o(t∗maxp)$算法（单调队列）</h2><p>此题单调队列优化思想不难，但是还要注意各种细节。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2017</span>;</span><br><span class="line"><span class="keyword">int</span> n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;maxp,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,ap+i,bp+i,as+i,bs+i);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as[i];++j)    dp[i][j]=-ap[i]*j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)    dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)<span class="comment">//买入 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;<span class="built_in">max</span>(<span class="number">0</span>,j-as[i]))head++;</span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][q[head]]-(j-q[head])*ap[i]);</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i-w<span class="number">-1</span>][j]+j*ap[i]&gt;=dp[i-w<span class="number">-1</span>][q[tail]]+q[tail]*ap[i])tail--;</span><br><span class="line">                q[++tail]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=maxp;j&gt;=<span class="number">0</span>;--j)<span class="comment">//卖出 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&gt;<span class="built_in">min</span>(maxp,j+bs[i]))head++;</span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][q[head]]+(q[head]-j)*bp[i]);</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i-w<span class="number">-1</span>][j]+j*bp[i]&gt;=dp[i-w<span class="number">-1</span>][q[tail]]+q[tail]*bp[i])tail--;</span><br><span class="line">                q[++tail]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化 题目列表</title>
      <link href="/2017/03/10/dp-list/"/>
      <url>/2017/03/10/dp-list/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8/">原文</a>）</p></div><h1 id="单调队列优化dp"><a href="#单调队列优化dp" class="headerlink" title="单调队列优化dp"></a>单调队列优化dp</h1><p>BZOJ 1855、BZOJ 2442、BZOJ 2500、BZOJ 1047</p><h1 id="单调栈优化dp"><a href="#单调栈优化dp" class="headerlink" title="单调栈优化dp"></a>单调栈优化dp</h1><p>BZOJ 1057、BZOJ 1683、BZOJ 3956、BZOJ 3611</p><h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><p>BZOJ 1879、BZOJ 1087、BZOJ 2669、BZOJ 3812</p><h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675</p><h1 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h1><p>POJ1160 HDU2829 HDU3480 HDU3506 HDU3516</p><h1 id="斜率优化DP和四边形不等式优化DP题单整理"><a href="#斜率优化DP和四边形不等式优化DP题单整理" class="headerlink" title="斜率优化DP和四边形不等式优化DP题单整理"></a>斜率优化DP和四边形不等式优化DP题单整理</h1><p><a href="http://blog.csdn.net/shiwei408/article/details/8791011">http://blog.csdn.net/shiwei408/article/details/8791011</a></p><p><a href="http://blog.csdn.net/tomorrowtodie/article/details/52279807">http://blog.csdn.net/tomorrowtodie/article/details/52279807</a></p><p><a href="http://blog.csdn.net/u014800748/article/details/45750737">http://blog.csdn.net/u014800748/article/details/45750737</a></p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNOI2008 玩具装箱Toy（详解）</title>
      <link href="/2017/03/10/HNOI2008-toy/"/>
      <url>/2017/03/10/HNOI2008-toy/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/10/%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P3195">Luogu 3195</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://s2.loli.net/2022/01/12/5sVo4uDBrpAwcMW.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>设$dp[i]$为处理前$i$个玩具的最小花费，$a[i]$为前$i$个玩具长度的前缀和。</p><p>易得转移方程为$dp[i]=min \lbrace  dp[j]+(i−j−1+a[i]−a[j]−l)^2 \rbrace (0 \leq i &lt; j \leq n)$</p><p>此方法时间复杂度为$O(n^2)$，只能水到20分。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,dp[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>+a[i]-a[j]-l)*(i-j<span class="number">-1</span>+a[i]-a[j]-l));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。</p><p>斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，一般可以通过决策表的方法进行验证，对于此题来说，数据容易生成，可以尝试一下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,dp[N],a[N],best[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>+a[i]-a[j]-l)*(i-j<span class="number">-1</span>+a[i]-a[j]-l))，best[i]=j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,best[i]);<span class="comment">//决策表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>易观察到$best[i]$单调不降，满足决策单调性。</p><p>证明见下：</p><p>对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有</p><p>$$dp[k]+(i−k−1+a[i]−a[k]−l)^2 &lt; dp[j]+(i−j−1+a[i]−a[j]−l)^2$$</p><p>$$dp[k]−dp[j] &lt; (i−j−1+a[i]−a[j]−l)^2−(i−k−1+a[i]−a[k]−l)^2$$</p><p>对于该方程，可设</p><p>$$b[i]=a[i]+i$$</p><p>$$l=l+1$$</p><p>则有</p><p>$$dp[k]−dp[j]&lt;(b[i]−b[j]−l)^2−(b[i]−b[k]−l)^2$$</p><p>化简得</p><p>$$((dp[k]+b[k]^2)−(dp[j]+b[j]^2))/(b[k]−b[j])&lt;2b[i]−2l$$</p><p>此时的形式为点斜式方程：</p><p>$$(yk−yj)/(xk−xj) &lt; ansi$$</p><p>已知$b[i]$为前缀和的形式，所以$b[i]$单调递增，可知斜率为单调递增。则适用决策单调性。</p><p>设</p><p>$$g[k,j]=(yk−yj)/(xk−xj)$$</p><p>则当且仅当$g[A1,A2] &lt; b[i]−2l$时，由$A1$转移而来优于$A2$。</p><p><strong>当$g[c,b] &lt; g[b,a]$时,易证得$b$必不为最优决策。</strong></p><p><strong>当$g[c,b] &lt; ansi$，此时$c$决策优于$b$，则$b$一定不为最优决策。</strong></p><p><strong>当$g[c,b]&gt;=ansi$，此时$b$决策优于$c$，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时$b$决策不优于$a$决策。</strong></p><p><strong>综上所述，则可将所有满足$g[c,b] &lt; g[b,a]$的决策$b$排除掉。此时函数满足上凸的性质，即有斜率递减。</strong></p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p><strong>以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：</strong></p><p><strong>1： 用单调队列维护点集信息。</strong></p><p><strong>2： 求解$dp[i]$，可以从队首开始扫描，当$g(head+1,head) &lt; ansi$时，可知$head+1$优于$head$，故继续扫描，直到不满足条件，此时$bext[i]=head$,即使$dp[i]$最优的决策为队首。</strong></p><p><strong>3： 当加入点$i$，我们要维护队列的上凸性质,即从队尾开始扫描，判断$g(i,tail)$是否小于$g(tail，tail-1)$，如果满足，则可删除$tail$，并继续扫描，直到不满足该条件，则$i$在此处入队，队列仍满足上凸性质。</strong></p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,a[N],b[N],dp[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">g</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k,<span class="keyword">long</span> <span class="keyword">long</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)b[i]=a[i]+i;</span><br><span class="line">    l++;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="built_in">g</span>(q[head+<span class="number">1</span>],q[head])&lt;<span class="number">2</span>*b[i]<span class="number">-2</span>*l)head++;</span><br><span class="line">        <span class="keyword">int</span> j=q[head];</span><br><span class="line">        dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="built_in">g</span>(i,q[tail])&lt;<span class="built_in">g</span>(q[tail],q[tail<span class="number">-1</span>]))tail--;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组十三题</title>
      <link href="/2017/03/08/Suffix-Array-13problems/"/>
      <url>/2017/03/08/Suffix-Array-13problems/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98/#more">原文</a>）</p></div><h1 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h1><p><a href="https://wenku.baidu.com/view/ed1be61e10a6f524ccbf85fd.html">后缀数组——处理字符串的有力工具–罗穗骞</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="POJ1743-Musical-Theme"><a href="#POJ1743-Musical-Theme" class="headerlink" title="POJ1743 Musical Theme"></a>POJ1743 Musical Theme</h2><p>本题题目描述与论文略有差别。</p><p>应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..））</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">1</span>,j=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>,maxsa=<span class="number">-1</span>,minsa=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(h[i]&lt;k)maxsa=<span class="number">-1</span>,minsa=inf;</span><br><span class="line">    <span class="keyword">if</span>(sa[i]&lt;minsa)minsa=sa[i];</span><br><span class="line">    <span class="keyword">if</span>(sa[i]&gt;maxsa)maxsa=sa[i];</span><br><span class="line">    <span class="keyword">if</span>(maxsa-minsa&gt;k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">break</span>;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    s[<span class="number">0</span>]=s[<span class="number">1</span>]-x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;++i)s[i]=s[i+<span class="number">1</span>]-s[i];</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)s[i]+=<span class="number">150</span>;</span><br><span class="line">    <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">getheight</span>(n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1e6</span>,ans;</span><br><span class="line">    <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">can</span>(ans,n))  l=ans;</span><br><span class="line">        <span class="keyword">else</span>      r=ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(l)&gt;=<span class="number">5</span>?l:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3261-Milk-Patterns"><a href="#POJ3261-Milk-Patterns" class="headerlink" title="POJ3261 Milk Patterns"></a>POJ3261 Milk Patterns</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];</span><br><span class="line"><span class="keyword">int</span> s[N],k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&lt;ans)tot=<span class="number">0</span>;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot==k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,s+i);</span><br><span class="line">    <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">getheight</span>(n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n+<span class="number">1</span>,ans,mid;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n))ans=l=mid;</span><br><span class="line">        <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ694-Distinct-Substrings"><a href="#SPOJ694-Distinct-Substrings" class="headerlink" title="SPOJ694 Distinct Substrings"></a>SPOJ694 Distinct Substrings</h2><p>这题论文中的方法不太好想，可以换一种思路。</p><p>易证长度为$len$的字符串一共有$(len+1)∗len/2$个子串。</p><p>而其中重复的字串个数则为height数组的总和，减去即可。</p><p>以这一组数据为例，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sa[i-1]  abba</span><br><span class="line">sa[i]    abcd //height[i] = 2</span><br></pre></td></tr></table></figure><p>两者相同的字串有$2∗(2+1)/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。</p><p>这个例子中只应减去$a,ab$这两个重复字符，之后必有两个后缀为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bba</span><br><span class="line">bcd //height = 1</span><br></pre></td></tr></table></figure><p>重复的子串$b$ 将在此处减掉。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e4</span>+<span class="number">5</span>;       </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;       </span><br><span class="line"><span class="keyword">char</span> s[N];   </span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],tong[N],wv[N];      </span><br><span class="line"><span class="keyword">int</span> rank[N],height[N];      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> t;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);  </span><br><span class="line">    <span class="keyword">while</span>(t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);  </span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);   </span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,<span class="number">128</span>);  </span><br><span class="line">        <span class="built_in">calheight</span>(n);  </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=n*(n+<span class="number">1</span>)/<span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        ans-=height[i];  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ705-不同的子串"><a href="#SPOJ705-不同的子串" class="headerlink" title="SPOJ705 不同的子串"></a>SPOJ705 不同的子串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,i=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line"><span class="built_in">getheight</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)sa[i]++;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans+=n-sa[i]-(i==<span class="number">1</span>?<span class="number">0</span>:h[i])+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URAL1297-Palindrome"><a href="#URAL1297-Palindrome" class="headerlink" title="URAL1297 Palindrome"></a>URAL1297 Palindrome</h2><p>这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tong[N],wv[N],wa[N],wb[N];</span><br><span class="line"><span class="keyword">int</span> rank1[N],height[N],sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=a[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)rank1[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank1[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank1[i]<span class="number">-1</span>];a[i+k]==a[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preRMQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">1</span>;i++)dp[i][<span class="number">0</span>]=height[i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=<span class="number">2</span>*n+<span class="number">1</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=<span class="number">2</span>*n+<span class="number">1</span>;i++)</span><br><span class="line">    dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=rank1[l],b=rank1[r];</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">int</span> t=(<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="built_in"><span class="keyword">double</span></span>(b-a+<span class="number">1</span>))/<span class="built_in">log</span>(<span class="number">2.00</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[a][t],dp[b-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,res,flag,max;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        max=<span class="number">0</span>;</span><br><span class="line">        n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)a[i]=(<span class="keyword">int</span>)s[i];</span><br><span class="line">        a[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)a[i+n+<span class="number">1</span>]=<span class="built_in"><span class="keyword">int</span></span>(s[n-i<span class="number">-1</span>]);</span><br><span class="line">        a[<span class="number">2</span>*n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(<span class="number">2</span>*n+<span class="number">2</span>,<span class="number">123</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">preRMQ</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">lcp</span>(i,<span class="number">2</span>*n-i)*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;res)max=res,flag=i;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res=<span class="built_in">lcp</span>(i,<span class="number">2</span>*n-i+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;res) max=res,flag=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max%<span class="number">2</span>==<span class="number">1</span>)<span class="keyword">for</span>(i=flag-max/<span class="number">2</span>;i&lt;=flag+max/<span class="number">2</span>;i++)   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(i=flag-max/<span class="number">2</span>;i&lt;=flag+max/<span class="number">2</span><span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ2406-Power-Strings"><a href="#POJ2406-Power-Strings" class="headerlink" title="POJ2406 Power Strings"></a>POJ2406 Power Strings</h2><p>本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个$logn$。</p><h2 id="POJ3693-Maximum-repetition-substring"><a href="#POJ3693-Maximum-repetition-substring" class="headerlink" title="POJ3693 Maximum repetition substring"></a>POJ3693 Maximum repetition substring</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];</span><br><span class="line"><span class="keyword">int</span> k,now,jj,maxr,cnt;</span><br><span class="line"><span class="keyword">int</span> d[N][<span class="number">21</span>],ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prermq</span><span class="params">(<span class="keyword">int</span>*a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)d[i][<span class="number">0</span>]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;++j)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;n;++i)</span><br><span class="line">d[i][j]=<span class="built_in">min</span>(d[i][j<span class="number">-1</span>],d[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">askrmq</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">l=rank[l],r=rank[r];</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="built_in">swap</span>(l,r);</span><br><span class="line">l++;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>))&lt;=r-l+<span class="number">1</span>)k++;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(d[l][k],d[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ccase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(tong,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tong));</span><br><span class="line"><span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">ccase++;</span><br><span class="line">k=now=jj=maxr=cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line"><span class="built_in">getheight</span>(n);</span><br><span class="line"><span class="built_in">prermq</span>(h,n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;n;j+=i) </span><br><span class="line">&#123;</span><br><span class="line">k=<span class="built_in">askrmq</span>(j,j+i);</span><br><span class="line">now=k/i+<span class="number">1</span>;</span><br><span class="line">jj=j-(i-k%i);</span><br><span class="line"><span class="keyword">if</span> (jj&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">askrmq</span>(jj,jj+i)&gt;=(i-k%i))++now;</span><br><span class="line"><span class="keyword">if</span>(now&gt;maxr)    &#123;cnt=<span class="number">0</span>;maxr=now;ans[cnt++]=i;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(now==maxr)  ans[cnt++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">askrmq</span>(sa[i],sa[i]+ans[j])&gt;=(maxr<span class="number">-1</span>)*ans[j])</span><br><span class="line">&#123;</span><br><span class="line">    jj=sa[i],k=ans[j];</span><br><span class="line">    <span class="keyword">goto</span> dd;</span><br><span class="line">&#125;</span><br><span class="line">dd:;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,ccase);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxr*k;++i)<span class="built_in">putchar</span>(s[jj++]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ687-重复的字符串"><a href="#SPOJ687-重复的字符串" class="headerlink" title="SPOJ687 重复的字符串"></a>SPOJ687 重复的字符串</h2><p>暂略。</p><h2 id="POJ2774-Long-Long-Message"><a href="#POJ2774-Long-Long-Message" class="headerlink" title="POJ2774 Long Long Message"></a>POJ2774 Long Long Message</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],wv[N],tong[maxf+<span class="number">1</span>],rank[N],h[N];</span><br><span class="line"><span class="keyword">char</span> s[N],ss[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;m=p,j&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,i=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;longlongmessage.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;longlongmessage.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),m=<span class="built_in">strlen</span>(ss);</span><br><span class="line">    s[n]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+m;++i)s[i]=ss[i-n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> l=n+m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">da</span>(l+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">geth</span>(l);</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=l;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i<span class="number">-1</span>]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i<span class="number">-1</span>]&lt;n)))</span><br><span class="line">        maxx=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3415-Common-Substrings"><a href="#POJ3415-Common-Substrings" class="headerlink" title="POJ3415 Common Substrings"></a>POJ3415 Common Substrings</h2><p>暂略。</p><h2 id="POJ3294-生命形态"><a href="#POJ3294-生命形态" class="headerlink" title="POJ3294 生命形态"></a>POJ3294 生命形态</h2><p>本题和上题都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">111</span>][<span class="number">10001</span>],s[N];</span><br><span class="line"><span class="keyword">int</span> nn[<span class="number">111</span>],tt;</span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">111</span>];</span><br><span class="line"><span class="keyword">int</span> ll[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,p=<span class="number">1</span>,<span class="built_in">swap</span>(x,y),x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(j=sa[rank[i]<span class="number">-1</span>],k?k--:<span class="number">0</span>;s[j+k]==s[i+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> ansg;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tot1=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));  tot1=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nowq,nowt;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])nowt=t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;</span><br><span class="line">                <span class="keyword">if</span>(!inq[nowq])tot1++,inq[nowq]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!inq[nowt])tot1++,inq[nowt]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot1&gt;=k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> lll=inf,rrr=<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> tot1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));  tot1=<span class="number">0</span>;</span><br><span class="line">              lll=inf;rrr=<span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">int</span> nowq,nowt;</span><br><span class="line">              <span class="keyword">if</span>(sa[i<span class="number">-1</span>]&lt;lll)lll=sa[i<span class="number">-1</span>];<span class="keyword">if</span>(sa[i<span class="number">-1</span>]&gt;rrr)rrr=sa[i<span class="number">-1</span>];</span><br><span class="line">              <span class="keyword">if</span>(sa[i]&lt;lll)lll=sa[i];<span class="keyword">if</span>(sa[i]&gt;rrr)rrr=sa[i];</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])nowt=t;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;</span><br><span class="line">              <span class="keyword">if</span>(!inq[nowq])tot1++,inq[nowq]=<span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span>(!inq[nowt])tot1++,inq[nowt]=<span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span>(tot1==k)ll[++ansg]=lll;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tt)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(wa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wa));</span><br><span class="line">        <span class="built_in">memset</span>(wb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wb));</span><br><span class="line">        <span class="built_in">memset</span>(wv,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wv));</span><br><span class="line">        <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">        <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">memset</span>(nn,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nn));</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">2</span>;</span><br><span class="line">        ansg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss[i]);</span><br><span class="line">            nn[i]=<span class="built_in">strlen</span>(ss[i]);</span><br><span class="line">            nn[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;nn[i];++t)s[tot++]=ss[i][t];</span><br><span class="line">            nn[i]+=nn[i<span class="number">-1</span>]+(i==tt?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i!=tt)s[tot++]=tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        nn[tt]++;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">        <span class="built_in">geth</span>(n);</span><br><span class="line">        k=(tt)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n+<span class="number">1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n,<span class="number">0</span>))  l=mid;</span><br><span class="line">            <span class="keyword">else</span>      r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);<span class="keyword">goto</span> dd;&#125;</span><br><span class="line">        <span class="built_in">can</span>(l,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansg;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;l;++t)<span class="keyword">if</span>(s[ll[i]+t]!=s[ll[i<span class="number">-1</span>]+t])&#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=ll[i];t&lt;=ll[i]+l<span class="number">-1</span>;++t)<span class="built_in">putchar</span>(s[t]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dd:;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ220-破译进攻计划"><a href="#SPOJ220-破译进攻计划" class="headerlink" title="SPOJ220 破译进攻计划"></a>SPOJ220 破译进攻计划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];</span><br><span class="line"><span class="keyword">char</span> s[N],ss[<span class="number">13</span>][<span class="number">15031</span>];</span><br><span class="line"><span class="keyword">int</span> inq[<span class="number">13</span>],maxq[<span class="number">13</span>],minq[<span class="number">13</span>];</span><br><span class="line"><span class="keyword">int</span> tt,num;</span><br><span class="line"><span class="keyword">bool</span> use[<span class="number">13</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>,p=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            tot=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">            <span class="built_in">memset</span>(maxq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maxq));</span><br><span class="line">            <span class="built_in">memset</span>(minq,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(minq));</span><br><span class="line">            <span class="built_in">memset</span>(use,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(use));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=num;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t])</span><br><span class="line">            &#123;</span><br><span class="line">                inq[t]++;</span><br><span class="line">                minq[t]=<span class="built_in">min</span>(minq[t],sa[i]);</span><br><span class="line">                maxq[t]=<span class="built_in">max</span>(maxq[t],sa[i]);</span><br><span class="line">                <span class="keyword">if</span>(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot==num)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=num;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])</span><br><span class="line">            &#123;</span><br><span class="line">                inq[t]++;</span><br><span class="line">                minq[t]=<span class="built_in">min</span>(minq[t],sa[i<span class="number">-1</span>]);</span><br><span class="line">                maxq[t]=<span class="built_in">max</span>(maxq[t],sa[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot==num)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    nn[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">        <span class="built_in">memset</span>(wa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wa));</span><br><span class="line">        <span class="built_in">memset</span>(wb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wb));</span><br><span class="line">        <span class="built_in">memset</span>(wv,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wv));</span><br><span class="line">        <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>,qiguaizifu=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss[i]);</span><br><span class="line">            nn[i]=<span class="built_in">strlen</span>(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;nn[i];++t)</span><br><span class="line">            s[tot++]=ss[i][t];</span><br><span class="line">            s[tot++]=qiguaizifu++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)nn[i]+=(nn[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">        <span class="built_in">geth</span>(n);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n))  l=mid;</span><br><span class="line">            <span class="keyword">else</span>      r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ1226-Substrings"><a href="#POJ1226-Substrings" class="headerlink" title="POJ1226 Substrings"></a>POJ1226 Substrings</h2><p>暂略。</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> String Manipulation </tag>
            
            <tag> Suffix Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ Coding Style</title>
      <link href="/2017/03/07/C-C++-Coding-Style/"/>
      <url>/2017/03/07/C-C++-Coding-Style/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/07/c++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">原文</a>）</p></div><p>C/C++代码规范。包括命名规则，排版规则，文档及注释，编码要求等等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://www.ipicbed.com/images/2022/01/08/C-CodingStyle.png" alt="C/C++ Google Coding Style"></p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="起个合适的名字"><a href="#起个合适的名字" class="headerlink" title="起个合适的名字"></a>起个合适的名字</h2><h3 id="类的名称"><a href="#类的名称" class="headerlink" title="类的名称"></a>类的名称</h3><p>类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p><p>类的名字不需要告诉我们，它从哪个类继承而来的。</p><p>有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p><h3 id="方法和函数的名称"><a href="#方法和函数的名称" class="headerlink" title="方法和函数的名称"></a>方法和函数的名称</h3><p>方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p><p>函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p><p>可以加一些必要的后缀：</p><p>Max – 表示取最大值。</p><p>Cnt – 表示当前的计数值。</p><p>Key – 表示键值。</p><p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p><p>前缀也同样有用：</p><p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p><p>Get – 用于获取一个值。</p><p>Set – 用于设置一个值。</p><p>例如：IsHitRetryLimit。</p><h3 id="含有度量单位的名称"><a href="#含有度量单位的名称" class="headerlink" title="含有度量单位的名称"></a>含有度量单位的名称</h3><p>如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint32 mTimeoutMsecs;</span><br><span class="line">uint32 mMyWeightLbs;</span><br></pre></td></tr></table></figure><h3 id="缩写名称不要全部大写"><a href="#缩写名称不要全部大写" class="headerlink" title="缩写名称不要全部大写"></a>缩写名称不要全部大写</h3><p>无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FluidOz</span>;</span>            <span class="comment">// 而不是 FluidOZ</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkAbcKey</span>;</span>      <span class="comment">// 而不是 NetworkABCKey</span></span><br></pre></td></tr></table></figure><h2 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h2><p>用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p><p>名字的第一个字母应大写。</p><p>不含有下划线。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>;</span></span><br></pre></td></tr></table></figure><h2 id="类库或程序库命名"><a href="#类库或程序库命名" class="headerlink" title="类库或程序库命名"></a>类库或程序库命名</h2><p>使用命名空间防止名字冲突。</p><p>如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p><p>例如：（Tong Su 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TsLinkList</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数的命名"><a href="#方法和函数的命名" class="headerlink" title="方法和函数的命名"></a>方法和函数的命名</h2><p>使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoIt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类属性的命名"><a href="#类属性的命名" class="headerlink" title="类属性的命名"></a>类属性的命名</h2><p>属性（通常是非公有数据成员）名字以字母’m’开头。</p><p>在 ‘m(m_)’ 后面，使用与类名相同的规则。</p><p>‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">VarAbc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ErrorNumber</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mVarAbc;</span><br><span class="line"><span class="keyword">int</span> mErrorNumber;</span><br><span class="line">String* mpName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数参数的命名"><a href="#方法和函数参数的命名" class="headerlink" title="方法和函数参数的命名"></a>方法和函数参数的命名</h2><p>第一个字母必须小写。</p><p>第一个字母后面的单词使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StartYourEngines</span><span class="params">(Engine&amp;rSomeEngine,Engine&amp;rAnotherEngine)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量的命名"><a href="#局部变量的命名" class="headerlink" title="局部变量的命名"></a>局部变量的命名</h2><p>所有字母都用小写。</p><p>使用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NameOneTwo::HandleError</span><span class="params">(<span class="keyword">int</span> errorNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error= <span class="built_in">OsErr</span>();</span><br><span class="line">Time time_of_error;</span><br><span class="line">ErrorProcessor error_processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针变量的命名前缀"><a href="#指针变量的命名前缀" class="headerlink" title="指针变量的命名前缀"></a>指针变量的命名前缀</h2><p>指针变量多数情况应在前面加 ‘p’。</p><p>星号应靠近类型，而不是变量名。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String* pName=<span class="keyword">new</span> String;</span><br></pre></td></tr></table></figure><p>特别的：String* pName, name; 应分成两行来写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String* pName;</span><br><span class="line">String  name;</span><br></pre></td></tr></table></figure><h2 id="引用变量和返回引用函数的命名前缀"><a href="#引用变量和返回引用函数的命名前缀" class="headerlink" title="引用变量和返回引用函数的命名前缀"></a>引用变量和返回引用函数的命名前缀</h2><p>引用必须用‘r’作前缀修饰。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(StatusInfo&amp;rStatus)</span></span>;</span><br><span class="line"><span class="function">StatusInfo&amp; <span class="title">rStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">constStatusInfo&amp; <span class="title">Status</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 这里返回的是常量引用，所以不符合本规则</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StatusInfo&amp; mrStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局变量的命名前缀"><a href="#全局变量的命名前缀" class="headerlink" title="全局变量的命名前缀"></a>全局变量的命名前缀</h2><p>全局变量总是以 ‘g(g_)’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger g_Log;</span><br><span class="line">Logger* g_pLog;</span><br></pre></td></tr></table></figure><h2 id="全局常量的命名"><a href="#全局常量的命名" class="headerlink" title="全局常量的命名"></a>全局常量的命名</h2><p>全局常量全部大写，并以下划线分隔单词。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intA_GLOBAL_CONSTANT = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="静态变量的命名前缀"><a href="#静态变量的命名前缀" class="headerlink" title="静态变量的命名前缀"></a>静态变量的命名前缀</h2><p>静态变量以 ‘s’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">staticStatusInfo m_sStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类型typedef的命名"><a href="#自定义类型typedef的命名" class="headerlink" title="自定义类型typedef的命名"></a>自定义类型typedef的命名</h2><p>类型定义名称指的是用typedef定义的名称。</p><p>类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint16  ModuleType;</span><br><span class="line"><span class="keyword">typedef</span> uint32  SystemType;</span><br></pre></td></tr></table></figure><h2 id="宏定义的命名"><a href="#宏定义的命名" class="headerlink" title="宏定义的命名"></a>宏定义的命名</h2><p>所有单词的字母都用大写，并使用下划线分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) blah</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ERR(err) blah</span></span><br></pre></td></tr></table></figure><h2 id="C-函数的命名"><a href="#C-函数的命名" class="headerlink" title="C 函数的命名"></a>C 函数的命名</h2><p>C++项目中，应尽量少用C函数。</p><p>C函数使用GNU规范，所有字母都使用小写，并用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，为了兼容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” <span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>或在C/C++中推荐使用下面的格式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#ifdef__cplusplus__</span><br><span class="line"><span class="keyword">extern</span> “C”&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">#ifdef__cplusplus__</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="枚举的命名"><a href="#枚举的命名" class="headerlink" title="枚举的命名"></a>枚举的命名</h2><p>所有字母都大写，并用下划线作为单词分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">enumPinStateType&#123;</span><br><span class="line">PIN_OFF,</span><br><span class="line">PIN_ON;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>STATE_ERR,STATE_OPEN,STATE_RUNNING,STATE_DYING&#125;;</span><br></pre></td></tr></table></figure><h1 id="排版规则"><a href="#排版规则" class="headerlink" title="排版规则"></a>排版规则</h1><h2 id="布局和模板"><a href="#布局和模板" class="headerlink" title="布局和模板"></a>布局和模板</h2><h3 id="类的布局模板"><a href="#类的布局模板" class="headerlink" title="类的布局模板"></a>类的布局模板</h3><p>请使用下面的模板来创建一个新的类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment"> * 用一行来描述类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *#include &quot;XX.h&quot; &lt;BR&gt;</span></span><br><span class="line"><span class="comment"> *-llib</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类的详细说明</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @seesomething</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="comment">// 在这里包含系统头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含项目头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含局部头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置前置引用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XX</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 类的生命周期控制函数，如构造和析构，以及状态机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***Default constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">/***Copy constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">const</span> XX&amp; from);</span><br><span class="line"><span class="comment">/***Destructor.*/</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 在这里放置类的运算操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Assignment operator.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@param from THe value to assign to this object.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@return A reference to this object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">XX&amp; <span class="keyword">operator</span>=(XX&amp;from); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的操作                      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置属性存取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的状态查询</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 内联方法定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>定义的顺序是: public, protected, private。</p><p>要清楚public/protected/private都应该放置哪些东西。</p><h3 id="保护头文件不被重复包含"><a href="#保护头文件不被重复包含" class="headerlink" title="保护头文件不被重复包含"></a>保护头文件不被重复包含</h3><p>应使用宏定义来保护头文件不被重复包含：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>如果使用命名空间的时候，要把命名空间加到文件名前面：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="方法和函数的布局"><a href="#方法和函数的布局" class="headerlink" title="方法和函数的布局"></a>方法和函数的布局</h3><p>对于有较多参数的函数的写法。</p><p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg1, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg2,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg4)</span></span>; </span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(<span class="keyword">int</span> arg1 </span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg2</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg3</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg4)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="尽量使一行不要超过78个字母"><a href="#尽量使一行不要超过78个字母" class="headerlink" title="尽量使一行不要超过78个字母"></a>尽量使一行不要超过78个字母</h2><p>有许多编辑器屏幕只有78个字母宽。</p><h2 id="保证一行只写一条语句"><a href="#保证一行只写一条语句" class="headerlink" title="保证一行只写一条语句"></a>保证一行只写一条语句</h2><p>一行最多只写一条语句。</p><p>一行只定义一个变量。</p><h2 id="圆括号规则"><a href="#圆括号规则" class="headerlink" title="圆括号规则"></a>圆括号规则</h2><p>圆括号与关键字之间应放一个空格。</p><p>圆括号与函数名之间不要有空格。</p><p>Return 语句不要使用圆括号。</p><h2 id="使用goto-continue-break-和"><a href="#使用goto-continue-break-和" class="headerlink" title="使用goto continue break 和?:"></a>使用goto continue break 和?:</h2><h3 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h3><p>尽量避免使用Goto 语句。</p><h3 id="Continue-and-Break"><a href="#Continue-and-Break" class="headerlink" title="Continue and Break"></a>Continue and Break</h3><p>Continue和break实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p><h3 id="A-B-C"><a href="#A-B-C" class="headerlink" title="A?B:C"></a>A?B:C</h3><p>用括号把条件表达式括起来。</p><p>不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p><p>操作语句应分行写，除非它们能够简洁的放在一行当中。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(condition) ?<span class="built_in">funct1</span>() : <span class="built_in">func2</span>();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(condition)</span><br><span class="line">? longstatement</span><br><span class="line">: anotherlong statement;</span><br></pre></td></tr></table></figure><h2 id="运算符号的规则"><a href="#运算符号的规则" class="headerlink" title="运算符号的规则"></a>运算符号的规则</h2><p>一元操作符如（!、~ 等等）应贴近操作对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IsOk)</span><br><span class="line">    <span class="keyword">return</span> ++v;</span><br></pre></td></tr></table></figure><p>二元操作符如（+、%、== 等等）应在前后留空格。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 == v2)</span><br><span class="line">     <span class="keyword">return</span> v1 * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。</p><h2 id="变量声明语句块"><a href="#变量声明语句块" class="headerlink" title="变量声明语句块"></a>变量声明语句块</h2><p>变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。</p><p>声明语句块必须要对齐。类型，变量，等号和初始化值要分别对齐。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DWORD      mDword;</span><br><span class="line">DWORD*     mpDword;</span><br><span class="line"><span class="keyword">char</span>*      mpChar;</span><br><span class="line"><span class="keyword">char</span>       mChar;</span><br><span class="line"></span><br><span class="line">mDword     =    <span class="number">0</span>;</span><br><span class="line">mpDword    =    <span class="literal">NULL</span>;</span><br><span class="line">mpChar     =    <span class="literal">NULL</span>;</span><br><span class="line">mChar      =    <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="文档及注释"><a href="#文档及注释" class="headerlink" title="文档及注释"></a>文档及注释</h1><p>应当使用文档自动生成工具，来生成相关的程序文档。</p><h2 id="文件或程序库的文档注释"><a href="#文件或程序库的文档注释" class="headerlink" title="文件或程序库的文档注释"></a>文件或程序库的文档注释</h2><p>可以为整个文件编写文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @file file.h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Abrief file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Amore elaborated file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="类文档注释"><a href="#类文档注释" class="headerlink" title="类文档注释"></a>类文档注释</h2><p>在类定义前面应加上类说明文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** WindowsNT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @brief Windows Nice Try.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Bill Gates</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Several species of small furryanimals gathered together</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *          in a cave and grooving with a pict.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @version 4.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @date   1996-1998</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug It crashes a lot and requires hugeamounts of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug The class introduces the more bugs, thelonger it is used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning This class may explode in your face.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning If you inherit anything from thisclass, you&#x27;re doomed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsNT</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数文档注释"><a href="#函数文档注释" class="headerlink" title="函数文档注释"></a>函数文档注释</h2><p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 赋值操作符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param val 将要赋给本对象的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return 本对象的引用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">XX&amp;  <span class="keyword">operator</span> =(XX&amp; val);</span><br></pre></td></tr></table></figure><p>注释属性</p><p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p><p>n 前提条件 (pre)<br>定义调用这个函数的前提条件</p><p>n 警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p><p>n 备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p><p>n 将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成。</p><p>n 使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 复制一个字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@pre</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(from != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(to != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@warning</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 缓冲区必需足够大，以便容纳的下要拷贝的字串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@example teststrcpy.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param from 要拷贝的字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param to 用于容纳字串的缓冲区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return void</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">strcpy</span><span class="params">(constchar* from, <span class="keyword">char</span>* to)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Include-语句注释"><a href="#Include-语句注释" class="headerlink" title="Include 语句注释"></a>Include 语句注释</h2><p>如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p><h2 id="语句块注释"><a href="#语句块注释" class="headerlink" title="语句块注释"></a>语句块注释</h2><p>语句块的注释可以用在语句块的开头和结束位置：</p><h1 id="编码要求"><a href="#编码要求" class="headerlink" title="编码要求"></a>编码要求</h1><h2 id="不要忽略编译器的警告"><a href="#不要忽略编译器的警告" class="headerlink" title="不要忽略编译器的警告"></a>不要忽略编译器的警告</h2><p>编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p><h2 id="应使用源代码管理器"><a href="#应使用源代码管理器" class="headerlink" title="应使用源代码管理器"></a>应使用源代码管理器</h2><p>根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p><h2 id="固有的类方法成员"><a href="#固有的类方法成员" class="headerlink" title="固有的类方法成员"></a>固有的类方法成员</h2><p>默认构造函数(DefaultConstructor)</p><p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p><p>虚析构函数(Virtual Destructor)</p><p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p><p>拷贝构造函数(Copy Constructor)</p><p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p><p>赋值操作(AssignmentOperator)</p><p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p><h2 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h2><p>根名字一般是设计者的名字。比如公司名称等等。</p><p>不要在全局空间使用using语句。</p><h2 id="初始化所有的变量"><a href="#初始化所有的变量" class="headerlink" title="初始化所有的变量"></a>初始化所有的变量</h2><p>无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p><h2 id="保持函数短小精悍"><a href="#保持函数短小精悍" class="headerlink" title="保持函数短小精悍"></a>保持函数短小精悍</h2><p>一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p><h2 id="对空语句进行注释"><a href="#对空语句进行注释" class="headerlink" title="对空语句进行注释"></a>对空语句进行注释</h2><p>For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(*dest++ = *srC++)</span><br><span class="line">   ;<span class="comment">// VOID</span></span><br></pre></td></tr></table></figure><h2 id="不要用if语句的默认方法测试非零值"><a href="#不要用if语句的默认方法测试非零值" class="headerlink" title="不要用if语句的默认方法测试非零值"></a>不要用if语句的默认方法测试非零值</h2><p>If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值。</p><p>建议使用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>() != FAIL)</span><br></pre></td></tr></table></figure><p>不建议使用下面的表达式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>())</span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p><h2 id="避免在语句中内含赋值"><a href="#避免在语句中内含赋值" class="headerlink" title="避免在语句中内含赋值"></a>避免在语句中内含赋值</h2><p>只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (EOF != (c= <span class="built_in">getchar</span>()))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确的使用Const"><a href="#正确的使用Const" class="headerlink" title="正确的使用Const"></a>正确的使用Const</h2><p>C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p><h2 id="不要在头文件定义数据"><a href="#不要在头文件定义数据" class="headerlink" title="不要在头文件定义数据"></a>不要在头文件定义数据</h2><p>不要把数据定义放在头文件。</p><h2 id="不要直接使用数字"><a href="#不要直接使用数字" class="headerlink" title="不要直接使用数字"></a>不要直接使用数字</h2><p>直接使用数字，会使源代码难以理解和维护。我们可以用#define或者常量来改变这一状况。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>如果可以，使用内联函数代替宏。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    <span class="comment">// 取最大数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>使用内联函数可以达到相同的效果，而且更安全：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt; y ? x : y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x + y</span></span><br></pre></td></tr></table></figure><p>必须写成：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure><p>和全局变量一样，宏也会与其它名称产生冲突。</p><p>下面两条规则有助于解决这个问题：</p><p>一、在宏名称前加上库的名字</p><p>二、避免使用简单而常用的名字，如：MAX和MIN。</p>]]></content>
      
      
      <categories>
          
          <category> Coding Itself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Coding Style </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
