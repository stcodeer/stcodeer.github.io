<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown与Mathjax的冲突</title>
      <link href="/2022/01/09/Markdown-Mathjax/"/>
      <url>/2022/01/09/Markdown-Mathjax/</url>
      
        <content type="html"><![CDATA[<p>关于Markdown与Mathjax的冲突以及解决方案。</p><p>为了进一步解决冲突问题，详见<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">Mathjax的配置方法</a>。</p><h1 id="冲突1"><a href="#冲突1" class="headerlink" title="冲突1"></a>冲突1</h1><p>有些特殊符号在Markdown与Mathjax中存在表达冲突的问题，如星号（*）在Markdown中可以表示斜体或加粗，在Mathjax中可以表示乘法。</p><p>为了解决冲突，可以在Mathjax中使用Markdown中的转义符（\）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a \* b$</span><br></pre></td></tr></table></figure><p>将会输出为：</p><p>$a * b$</p><p>这种解决方法会导致Latex的语法发生变化，需要注意。</p><h1 id="冲突2"><a href="#冲突2" class="headerlink" title="冲突2"></a>冲突2</h1><p>为了输出大括号，不能在Mathjax中使用如下语法，此处方案会导致大括号不显示。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\&#123; A \&#125;$</span><br></pre></td></tr></table></figure><p>而应使用：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\lbrace A \rbrace$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$\lbrace A \rbrace$</p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Chinese </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Butterfly 基本用法</title>
      <link href="/2022/01/09/Hexo-basis/"/>
      <url>/2022/01/09/Hexo-basis/</url>
      
        <content type="html"><![CDATA[<p>关于Hexo如何生成，测试，上传博客，博客内的基本语法，以及Butterfly主题如何更改配置文件。</p><h1 id="Hexo语法"><a href="#Hexo语法" class="headerlink" title="Hexo语法"></a>Hexo语法</h1><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>通过配置文件，sources文件夹（包含博客以及其他页面文件）生成public文件夹。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>将public文件夹以本地为服务器，生成博客内容，网址为<a href="http://localhost:4000/">http://localhost:4000/</a>。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>将public文件夹上传至Github，利用Github做服务器，生成博客内容。</p><h2 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清空public文件夹，清空缓存，适用于修改配置文件后，生成public文件夹前。</p><h1 id="Hexo-Markdown-Mathjax-Butterfly-博客内语法"><a href="#Hexo-Markdown-Mathjax-Butterfly-博客内语法" class="headerlink" title="Hexo + Markdown + Mathjax + Butterfly 博客内语法"></a>Hexo + Markdown + Mathjax + Butterfly 博客内语法</h1><h2 id="Hexo前缀（Front-matter）"><a href="#Hexo前缀（Front-matter）" class="headerlink" title="Hexo前缀（Front-matter）"></a>Hexo前缀（Front-matter）</h2><p>在博客前，需要添加Front-matter以确定该博客的基本属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Template</span><br><span class="line">//博客标题</span><br><span class="line">date: 2099-01-01 00:00:00</span><br><span class="line">//博客创建时间，缺省为.md创建时间，如果该时间晚于当前时间，则为定时发布（可在主题config的future中调整）</span><br><span class="line">updated: 2099-01-01 00:00:00</span><br><span class="line">//博客更新时间，缺省为.md更新时间</span><br><span class="line">tags: [Chinese,Hexo]</span><br><span class="line">//博客标签（Chinese,Hexo两个标签并列）</span><br><span class="line">categories: [A,B]</span><br><span class="line">//博客分类（A,B两个分类嵌套，B是子分类）</span><br><span class="line">description: About Hexo.</span><br><span class="line">//博客简介，显示在首页或归档中，博客外</span><br><span class="line">cover: http://xx/1.jpg</span><br><span class="line">//博客封面</span><br><span class="line">comments: true/false</span><br><span class="line">//开启评论功能，默认为true</span><br></pre></td></tr></table></figure><h2 id="Markdown-Mathjax基本语法"><a href="#Markdown-Mathjax基本语法" class="headerlink" title="Markdown+Mathjax基本语法"></a>Markdown+Mathjax基本语法</h2><p>博客基本语法即Markdown+Mathjax语法。</p><h3 id="关于Markdown与Mathjax的冲突"><a href="#关于Markdown与Mathjax的冲突" class="headerlink" title="关于Markdown与Mathjax的冲突"></a>关于Markdown与Mathjax的冲突</h3><p>为了进一步解决冲突问题，详见<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">Mathjax的配置方法</a>。</p><h4 id="冲突1"><a href="#冲突1" class="headerlink" title="冲突1"></a>冲突1</h4><p>有些特殊符号在Markdown与Mathjax中存在表达冲突的问题，如星号（*）在Markdown中可以表示斜体或加粗，在Mathjax中可以表示乘法。</p><p>为了解决冲突，可以在Mathjax中使用Markdown中的转义符（\）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a \* b$</span><br></pre></td></tr></table></figure><p>将会输出为：</p><p>$a * b$</p><p>这种解决方法会导致Latex的语法发生变化，需要注意。</p><h4 id="冲突2"><a href="#冲突2" class="headerlink" title="冲突2"></a>冲突2</h4><p>为了输出大括号，不能在Mathjax中使用:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\&#123; A \&#125;$</span><br></pre></td></tr></table></figure><p>而应使用：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\lbrace A \rbrace$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$\lbrace A \rbrace$</p><h2 id="Butterfly主题自创语法"><a href="#Butterfly主题自创语法" class="headerlink" title="Butterfly主题自创语法"></a>Butterfly主题自创语法</h2><div class="note warning modern"><p>该语法仅适用于Butterfly主题，在其他主题下可能会出现错误。</p></div><h3 id="提示标签"><a href="#提示标签" class="headerlink" title="提示标签"></a>提示标签</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">none</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div class="note modern"><p>none</p></div><div class="note default modern"><p>default</p></div><div class="note primary modern"><p>primary</p></div><div class="note success modern"><p>success</p></div><div class="note info modern"><p>info</p></div><div class="note warning modern"><p>warning</p></div><div class="note danger modern"><p>danger</p></div><h3 id="选择标签"><a href="#选择标签" class="headerlink" title="选择标签"></a>选择标签</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tabname %&#125;</span><br><span class="line">&lt;!-- tab name1 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab name2 --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab name3 --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div class="tabs" id="tabname"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tabname-1">name1</button></li><li class="tab"><button type="button" data-href="#tabname-2">name2</button></li><li class="tab"><button type="button" data-href="#tabname-3">name3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tabname-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>更多更详细的用法见<a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly的标签外挂</a>。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="新建页"><a href="#新建页" class="headerlink" title="新建页"></a>新建页</h2><p>在导览菜单中修改，使得右上角出现选项（<a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%B0%8E%E8%88%AA%E8%8F%9C%E5%96%AE">详细操作</a>）。</p><p>在source/pagename中添加页文件，基本语法与博客文件相同（<a href="https://butterfly.js.org/posts/dc584b87/#Page-Front-matter">详细操作</a>）。</p><p>可以加入个人介绍页，简历页等等。</p><h2 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E7%B6%B2%E7%AB%99%E8%B3%87%E6%96%99">详细操作</a></p><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E9%A0%82%E9%83%A8%E5%9C%96">详细操作</a></p><p>可直接通过主题配置文件中的 disable_top_img: true/false 来控制顶部图的启用与关闭。</p><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><h2 id="Footer-设置"><a href="#Footer-设置" class="headerlink" title="Footer 设置"></a>Footer 设置</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%8D%9A%E5%AE%A2%E5%B9%B4%E4%BB%BD">详细操作</a></p><p>可在其中加入备案信息。</p><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><p>Butterfly支持评论，图库，在线聊天，分享，搜索系统，网站验证，站点分析统计，广告，美化特效，CDN等等更多功能。</p><p>详见：<a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安装文档(四) 主题配置-2</a></p><p>Butterfly支持音乐，豆瓣电影，说说，自定义代码配色，自定义侧边栏，图片压缩等等更多功能。</p><p>详见：<a href="https://butterfly.js.org/posts/4073eda/">Butterfly 安装文档(六) 进阶教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Chinese </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数的几何意义</title>
      <link href="/2022/01/07/linear-geometry/"/>
      <url>/2022/01/07/linear-geometry/</url>
      
        <content type="html"><![CDATA[<p>基于3Blue1Brown科普内容的总结，关于线性代数的本质。</p><h1 id="3Blue1Brown原视频链接"><a href="#3Blue1Brown原视频链接" class="headerlink" title="3Blue1Brown原视频链接"></a>3Blue1Brown原视频链接</h1><p><a href="https://www.bilibili.com/medialist/play/watchlater/BV1ys411472E">【官方双语/合集】线性代数的本质 - 系列合集</a></p><h1 id="张成与基"><a href="#张成与基" class="headerlink" title="张成与基"></a>张成与基</h1><p>向量集合的张成是所有能表示的点所构成的线性空间。</p><p>基即最小的向量集合，使得该集合的张成等于当前线性空间。</p><h1 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h1><p>线性变换是指满足可加性，数乘性的离散函数，有输入，有输出。通俗来说，线性变换的几何意义是原点不变且直线在变换后仍为直线，更直观的表示是原点不变且网格线变换前后保持平行且等距离。</p><h1 id="矩阵与矩阵乘法"><a href="#矩阵与矩阵乘法" class="headerlink" title="矩阵与矩阵乘法"></a>矩阵与矩阵乘法</h1><p>矩阵的几何意义是线性变换，矩阵乘法的几何意义是线性变换的叠加。</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>方阵的行列式的几何定义是有向的放缩倍率。</p><h1 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h1><p>非方阵也是高维到低维的线性变换。</p><h1 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h1><p>点积的式子可以用对偶性来证明，看成对于一个向量的非方阵线性变换，使得其位于另一个向量的直线上。</p><h1 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h1><p>二维叉积是有向面积，就是将其看作二维线性变换后的放缩倍率，即行列式。</p><p>三维叉积的面积即将两个向量和另一个单位向量（看作可变向量，但将其认为是单位向量）看作三维线性变换后得到的放缩倍率，即行列式。但最终得到的行列式实际上是个与两个向量垂直的向量，且长度才为叉积值。此处可以用对偶性来证明，将该行列式等同于求得向量与可变向量的点积，显然无论该可变向量如何变化都是成立的，可变向量在所求向量上的投影=可变向量在六面体的高，所求向量长度=底面积叉积，所以叉积的本质就是这个求得向量。</p><h1 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h1><p>特征向量是线性变换中张成空间不变的向量。</p><p>特征值是特征向量的变化率。（$A*v=\lambda*v$，$A$是线性变换矩阵，$\lambda$是特征值，$v$是特征向量）</p><h1 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h1><p>$A^{-1}*M*A$实际上是在非标准基下进行标准视角下的变换。（比如说旋转$90$度，标准基下乘上$M$即可，但是非标准基下要乘上$A^{-1}*M*A$，$A$是用来转化成标准基的线性变换矩阵）</p><p>如果可以选$n$个特征向量张成整个空间的话，那么可以将这$n$个向量看作新的基底，此时线性变换在该基底下一定是对角阵，即有$A^{-1}*M*A=D$。（$D$是对角阵）（基向量都是特征向量的话，线性变换一定是对角阵）</p><p>方阵快速幂：</p><p><img src="https://www.ipicbed.com/images/2022/01/08/l1.png" alt="方阵快速幂1"></p><p><img src="https://www.ipicbed.com/images/2022/01/08/l2.png" alt="方阵快速幂2"></p><p><img src="https://www.ipicbed.com/images/2022/01/08/l3.png" alt="方阵快速幂3"></p><p><img src="https://www.ipicbed.com/images/2022/01/08/l4.png" alt="方阵快速幂4"></p><h1 id="向量的抽象"><a href="#向量的抽象" class="headerlink" title="向量的抽象"></a>向量的抽象</h1><p>满足八大公理的结构都能被看作向量，存在线性变换，也有之前所推导的性质。例如函数也可以看作一种有无穷维度的向量，同样有基底（$1,x^1,x^2,x^3,…$）。线性变换即线性算子（如求导等，可以用无穷阶的方阵表示），点积即内积，特征向量即特征函数等等。</p><p><img src="https://www.ipicbed.com/images/2022/01/07/linear_atoms.png" alt="八大公理"></p>]]></content>
      
      
      <categories>
          
          <category> Maths </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Linear Algebra </tag>
            
            <tag> 3Blue1Brown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2022/01/04/hello-hexo/"/>
      <url>/2022/01/04/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAOI2007 理想的正方形</title>
      <link href="/2017/03/14/HAOI2007-square/"/>
      <url>/2017/03/14/HAOI2007-square/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/14/%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2216">Luogu 2216</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://www.ipicbed.com/images/2022/01/10/HAOI2007-square.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>二维滑动窗口，先对每一行建立双端队列，记录每一个$1*n$的长方体中的极值，将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n*1$的长方体(在原矩阵中为$n*n$的正方形)中的极值（$miny[i][t],maxy[i][t]$存储的是以$(i,t)$为右下角端点的$n*n$正方形的极值信息），枚举即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e3</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];</span><br><span class="line"><span class="keyword">int</span> y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];</span><br><span class="line"><span class="keyword">int</span> mapp[N][N],a,b,n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=inf;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get</span>(a),<span class="built_in">get</span>(b),<span class="built_in">get</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)<span class="built_in">get</span>(mapp[i][t]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--;</span><br><span class="line">        x1[++tailx1[i]]=t;</span><br><span class="line">        <span class="keyword">while</span>(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++;</span><br><span class="line">        minx[i][t]=mapp[i][x1[headx1[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=b;++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--;</span><br><span class="line">        x2[++tailx2[i]]=t;</span><br><span class="line">        <span class="keyword">while</span>(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++;</span><br><span class="line">        maxx[i][t]=mapp[i][x2[headx2[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--;</span><br><span class="line">        y1[++taily1[t]]=i;</span><br><span class="line">        <span class="keyword">while</span>(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++;</span><br><span class="line">        miny[i][t]=minx[y1[heady1[t]]][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--;</span><br><span class="line">        y2[++taily2[t]]=i;</span><br><span class="line">        <span class="keyword">while</span>(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++;</span><br><span class="line">        maxy[i][t]=maxx[y2[heady2[t]]][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=n;t&lt;=b;++t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=a;++i)</span><br><span class="line">    <span class="keyword">if</span>(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟赛 2017-03-12</title>
      <link href="/2017/03/12/NOIP-2017-3-12/"/>
      <url>/2017/03/12/NOIP-2017-3-12/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/13/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B%202017%203%2012/">原文</a>）</p></div><h1 id="Blue"><a href="#Blue" class="headerlink" title="Blue"></a>Blue</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。</p><p>他最近开始研究青蛙过河的问题，可以简化成：数轴上 $0$ 为岸边，$L$ 为河对岸。$(0,L)$中间存在 $n$ 个石子。已知青蛙一跳可以跳距离 $D$，而且不能沾水。求问能不能跳到河对岸。</p><p>当然他觉得这个问题非常 naïve，于是在思考如果青蛙有$m$个，且石头被踩过之后就会沉下去，$m$ 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。</p><p>输入第一行为一个正整数 $T$ 代表数据组数。每组数据第一行四个正整数：$n、m、D、L$。</p><p>第二行 $n$ 个升序正整数 $a_i$ 代表第 $i$ 个石子坐标为 $a_i$。保证没有重复且都小于 $L$。</p><p>输出 $T$ 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10 9 16 30</span><br><span class="line">2 4 6 9 11 15 18 19 25 27 </span><br><span class="line">10 1 23 30</span><br><span class="line">10 11 13 14 15 16 18 26 27 29 </span><br><span class="line">10 7 28 30</span><br><span class="line">2 3 7 9 12 15 20 24 27 28 </span><br><span class="line">10 3 18 30</span><br><span class="line">1 6 9 14 18 19 22 27 28 29 </span><br><span class="line">10 7 10 30</span><br><span class="line">1 2 4 6 18 19 20 22 23 26 </span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">Excited</span><br><span class="line">Excited</span><br><span class="line">Excited</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$10%$的数据保证 $m=1$</p><p>对于另外$10%$的数据保证 $D=L$</p><p>对于另外$10%$的数据保证 $n=L−1$</p><p>对于另外$30%$的数据保证 $n&lt;=100,L&lt;=10^5$</p><p>对于$100%$的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$</p><p>数据范围中的 $n、m$ 皆代表题目描述中 $n、m$ 的总和。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和$d$的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。</p><p>具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了…</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tt,n,m,d,l,a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)b[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> anss=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">1</span>;now&lt;=n;++now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[now]-b[++anss]&lt;=d)b[anss]=a[now];</span><br><span class="line">        <span class="keyword">if</span>(anss==ans)anss=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;++i)</span><br><span class="line">    <span class="keyword">if</span>(l-b[i]&gt;d)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n),<span class="built_in">read</span>(m),<span class="built_in">read</span>(d),<span class="built_in">read</span>(l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">int</span> ll=<span class="number">0</span>,rr=m,mid;</span><br><span class="line">        <span class="keyword">while</span>(ll!=rr)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=ll+rr+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid))    ll=mid;</span><br><span class="line">            <span class="keyword">else</span>            rr=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rr==m)    <span class="built_in">printf</span>(<span class="string">&quot;Excited\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Weed"><a href="#Weed" class="headerlink" title="Weed"></a>Weed</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。</p><p>为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。</p><p>电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为$v_i$的金坷垃，或者除掉最新$v_i$层（不是量）撒的金坷垃。如果上面只留有不足$v_i$层金坷垃，那么就相当于电脑上面没有金坷垃了。</p><p>duyege非常严谨，一开始先给你$m$个上述操作要你依次完成。然后又对实验步骤进行了$q$次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最终金坷垃的量有多少。</p><p>输入第一行为两个正整数$m、q$，接下来$m$行每行$2$个整数$k、v_i$。$k$为$0$时撒金坷垃，为$1$时除金坷垃。接下来$q$行每行$3$个整数$c_i、k、v_i$，$c_i$代表被更改的操作是第$c_i$个，后面$2$个数描述更改为这样的操作。</p><p>输出 $q$ 行代表每次金坷垃的量为多少。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">0 10</span><br><span class="line">1 5</span><br><span class="line">0 13</span><br><span class="line">0 18</span><br><span class="line">0 2</span><br><span class="line">1 1</span><br><span class="line">0 8</span><br><span class="line">0 9</span><br><span class="line">1 3</span><br><span class="line">0 7</span><br><span class="line">9 0 3</span><br><span class="line">10 1 7</span><br><span class="line">6 0 8</span><br><span class="line">10 0 5</span><br><span class="line">8 1 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">58</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">66</span><br><span class="line">41</span><br></pre></td></tr></table></figure><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$30%$的数据，$m&lt;=1000,q&lt;=1000$</p><p>对于另外$20%$的数据，每次 $k=1$ 时都会将金坷垃清空。</p><p>对于$100%$的数据，$m&lt;=2*10^5,q&lt;=2*10^5,v_i&lt;=10^4$</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现…</p><p>题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">build</span>&#123;</span><span class="keyword">int</span> sum,in,out;&#125;tr[<span class="number">8</span>*N];</span><br><span class="line"><span class="keyword">int</span> n,q,k,a[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pot&gt;=tr[x].in)            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!pot)                    <span class="keyword">return</span> tr[x].sum;</span><br><span class="line">    <span class="keyword">if</span>(pot&lt;=tr[x*<span class="number">2</span>+<span class="number">1</span>].in)</span><br><span class="line">    <span class="keyword">return</span> tr[x].sum-tr[x*<span class="number">2</span>+<span class="number">1</span>].sum+<span class="built_in">find</span>(x*<span class="number">2</span>+<span class="number">1</span>,pot);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x*<span class="number">2</span>,pot-tr[x*<span class="number">2</span>+<span class="number">1</span>].in+tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].in=tr[x*<span class="number">2</span>+<span class="number">1</span>].in+<span class="built_in">max</span>(<span class="number">0</span>,tr[x*<span class="number">2</span>].in-tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">    tr[x].out=tr[x*<span class="number">2</span>].out+<span class="built_in">max</span>(<span class="number">0</span>,tr[x*<span class="number">2</span>+<span class="number">1</span>].out-tr[x*<span class="number">2</span>].in);</span><br><span class="line">    tr[x].sum=tr[x*<span class="number">2</span>+<span class="number">1</span>].sum+<span class="built_in">find</span>(x*<span class="number">2</span>,tr[x*<span class="number">2</span>+<span class="number">1</span>].out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l]&lt;<span class="number">0</span>)    tr[x].out=-a[l];</span><br><span class="line">        <span class="keyword">else</span>        tr[x].in=<span class="number">1</span>,tr[x].sum=a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x*<span class="number">2</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(x*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pot,<span class="keyword">int</span> w,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;tr[x],<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tr[x]));</span><br><span class="line">        <span class="keyword">if</span>(w&lt;<span class="number">0</span>)        tr[x].out=-w;</span><br><span class="line">        <span class="keyword">else</span>        tr[x].in=<span class="number">1</span>,tr[x].sum=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pot&gt;mid)    <span class="built_in">change</span>(x*<span class="number">2</span>+<span class="number">1</span>,pot,w,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">else</span>        <span class="built_in">change</span>(x*<span class="number">2</span>,pot,w,l,mid);</span><br><span class="line">        <span class="built_in">update</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(k),<span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(k)a[i]*=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,w;</span><br><span class="line">        <span class="built_in">read</span>(x);<span class="built_in">read</span>(k);<span class="built_in">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span>(k)w*=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,x,w,<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Drink"><a href="#Drink" class="headerlink" title="Drink"></a>Drink</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个遥远的国度有一个腰缠万贯的资本家Link，每一个拜访他的人都可以得到一份丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了Link家。Link智商超群（不然也赚不到这么多资本），所以决定用特殊的方法赏赐毒液哥。</p><p>Link的藏宝库是一个$N * M$棋盘，每个格子里都有宝物。Link会对棋盘做$Q$次操作，每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转$90$度）。毒液哥不仅财富值被Link碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财的他想知道最后棋盘内所有的宝物价值以方便他挑选。</p><p>作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）和资产阶级代表（Link）之间的贫富差距么。</p><p>输入第一行三个数 $N, M, Q$ 分别表示棋盘的行数、列数和操作个数。</p><p>接下来 $N$ 行每行 $M$ 个数表示一开始棋盘上宝物的价值。</p><p>接下来 $Q$ 行每行 $3$ 个数 $x, y, c$ 表示操作区域为以第 $x$ 行第 $y$ 列为左上角的边长为 $c$ 的正方形。</p><p>输出一个 $N * M$ 的矩阵表示最后的棋盘。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">1 1 3</span><br><span class="line">3 3 2</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 5 1 4 </span><br><span class="line">2 7 6 8 </span><br><span class="line">3 7 2 3 </span><br><span class="line">5 6 8 4 </span><br></pre></td></tr></table></figure><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 30%的数据，$N, M, Q &lt;= 100$.</p><p>对于另外 30%的数据，保证所有 $Q$ 个正方形两两之间不相交或相等。</p><p>对于 100%的数据, $N, M, Q &lt;= 1000$，棋盘内所有数取值都为 $0 ~ 9$。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（$p=0$），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（$p=(p+1)%4$），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @Author: 閫搁棽</span></span><br><span class="line"><span class="comment">* @Date:   2016-09-25 13:04:44</span></span><br><span class="line"><span class="comment">* @Last Modified by:   閫搁棽</span></span><br><span class="line"><span class="comment">* @Last Modified time: 2016-10-01 10:19:00</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstdio&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstdlib&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cstring&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 2005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Eps</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Get(x, a) (x ? x -&gt; a : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Num = <span class="number">0</span>, Flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            Flag = -Flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        Num = Num * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> Num * Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">int</span> A[MAX_SIZE * MAX_SIZE][<span class="number">4</span>], Map[MAX_SIZE][MAX_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> &amp;Direction, <span class="keyword">int</span> &amp;Now, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Next = A[Now][j - Direction + <span class="number">4</span> &amp; <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(Direction = <span class="number">0</span>; A[Next][j - Direction + <span class="number">6</span> &amp; <span class="number">3</span>] != Now; ++Direction);</span><br><span class="line">    Now = Next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="comment">//    freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            Map[i][j] = <span class="built_in">Get_Int</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (N + <span class="number">2</span>) * (M + <span class="number">2</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][<span class="number">0</span>] = i - M - <span class="number">2</span>;</span><br><span class="line">        A[i][<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        A[i][<span class="number">2</span>] = i + M + <span class="number">2</span>;</span><br><span class="line">        A[i][<span class="number">3</span>] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">Get_Int</span>(), y = <span class="built_in">Get_Int</span>(), c = <span class="built_in">Get_Int</span>();</span><br><span class="line">        <span class="keyword">int</span> Direction = <span class="number">0</span>, Now = <span class="number">1</span>;</span><br><span class="line">        vector&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; Border[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line">            <span class="built_in">Move</span>(Direction, Now, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; ++i)</span><br><span class="line">            <span class="built_in">Move</span>(Direction, Now, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                Border[j][<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(Direction, Now));</span><br><span class="line">                <span class="built_in">Move</span>(Direction, Now, j);</span><br><span class="line">                Border[j][<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(Direction, Now));</span><br><span class="line">                <span class="built_in">Move</span>(Direction, Now, j + <span class="number">2</span> &amp; <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(i != c)</span><br><span class="line">                    <span class="built_in">Move</span>(Direction, Now, j + <span class="number">1</span> &amp; <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Now = Border[j][<span class="number">1</span>][i];</span><br><span class="line">                A[Now.second][j + <span class="number">6</span> - Now.first &amp; <span class="number">3</span>] = Border[j + <span class="number">3</span> &amp; <span class="number">3</span>][<span class="number">0</span>][i].second;</span><br><span class="line">                Now = Border[j][<span class="number">0</span>][i];</span><br><span class="line">                A[Now.second][j + <span class="number">4</span> - Now.first &amp; <span class="number">3</span>] = Border[j + <span class="number">1</span> &amp; <span class="number">3</span>][<span class="number">1</span>][i].second;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Direction = <span class="number">0</span>, Now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Move</span>(Direction, Now, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = Direction, Next = Now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Move</span>(temp, Next, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Map[(Next - <span class="number">1</span>) / (M + <span class="number">2</span>)][(Next - <span class="number">1</span>) % (M + <span class="number">2</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Data Structure </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Greedy </tag>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCOI2010 股票交易</title>
      <link href="/2017/03/11/SCOI2010-stock/"/>
      <url>/2017/03/11/SCOI2010-stock/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/11/%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93/#more">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P2569">Luogu 2569</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://www.ipicbed.com/images/2022/01/09/stock.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="o-t∗maxp-2-算法"><a href="#o-t∗maxp-2-算法" class="headerlink" title="$o(t∗maxp^2)$算法"></a>$o(t∗maxp^2)$算法</h2><p>$o(t∗maxp^2)$算法有70分，还是比较良心的。</p><p>这题转移方程也不难想，可以设$dp[i][j]$为第$i$天后手中还剩$t$张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买$3$张股票，那么$dp[1][4]$是便是无效的，不妨将$dp$数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2017</span>;</span><br><span class="line"><span class="keyword">int</span> n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;maxp,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,ap+i,bp+i,as+i,bs+i);</span><br><span class="line">  <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;<span class="comment">//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j]);<span class="comment">//该天没有操作</span></span><br><span class="line">          <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;=<span class="built_in">min</span>(j+bs[i],maxp);++k)</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][k]+(k-j)*bp[i]);<span class="comment">//卖出</span></span><br><span class="line">          <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="built_in">max</span>(j-as[i],<span class="number">0</span>);k&lt;j;++k)</span><br><span class="line">          dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][k]-(j-k)*ap[i]);<span class="comment">//买入</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="o-t∗maxp-算法（单调队列）"><a href="#o-t∗maxp-算法（单调队列）" class="headerlink" title="$o(t∗maxp)$算法（单调队列）"></a>$o(t∗maxp)$算法（单调队列）</h2><p>此题单调队列优化思想不难，但是还要注意各种细节。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2017</span>;</span><br><span class="line"><span class="keyword">int</span> n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;maxp,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,ap+i,bp+i,as+i,bs+i);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as[i];++j)    dp[i][j]=-ap[i]*j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)    dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(i-w<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=maxp;++j)<span class="comment">//买入 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;<span class="built_in">max</span>(<span class="number">0</span>,j-as[i]))head++;</span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][q[head]]-(j-q[head])*ap[i]);</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i-w<span class="number">-1</span>][j]+j*ap[i]&gt;=dp[i-w<span class="number">-1</span>][q[tail]]+q[tail]*ap[i])tail--;</span><br><span class="line">                q[++tail]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=maxp;j&gt;=<span class="number">0</span>;--j)<span class="comment">//卖出 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&gt;<span class="built_in">min</span>(maxp,j+bs[i]))head++;</span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-w<span class="number">-1</span>][q[head]]+(q[head]-j)*bp[i]);</span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i-w<span class="number">-1</span>][j]+j*bp[i]&gt;=dp[i-w<span class="number">-1</span>][q[tail]]+q[tail]*bp[i])tail--;</span><br><span class="line">                q[++tail]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化 题目列表</title>
      <link href="/2017/03/10/dp-list/"/>
      <url>/2017/03/10/dp-list/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8/">原文</a>）</p></div><h1 id="单调队列优化dp"><a href="#单调队列优化dp" class="headerlink" title="单调队列优化dp"></a>单调队列优化dp</h1><p>BZOJ 1855、BZOJ 2442、BZOJ 2500、BZOJ 1047</p><h1 id="单调栈优化dp"><a href="#单调栈优化dp" class="headerlink" title="单调栈优化dp"></a>单调栈优化dp</h1><p>BZOJ 1057、BZOJ 1683、BZOJ 3956、BZOJ 3611</p><h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><p>BZOJ 1879、BZOJ 1087、BZOJ 2669、BZOJ 3812</p><h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675</p><h1 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h1><p>POJ1160 HDU2829 HDU3480 HDU3506 HDU3516</p><h1 id="斜率优化DP和四边形不等式优化DP题单整理"><a href="#斜率优化DP和四边形不等式优化DP题单整理" class="headerlink" title="斜率优化DP和四边形不等式优化DP题单整理"></a>斜率优化DP和四边形不等式优化DP题单整理</h1><p><a href="http://blog.csdn.net/shiwei408/article/details/8791011">http://blog.csdn.net/shiwei408/article/details/8791011</a></p><p><a href="http://blog.csdn.net/tomorrowtodie/article/details/52279807">http://blog.csdn.net/tomorrowtodie/article/details/52279807</a></p><p><a href="http://blog.csdn.net/u014800748/article/details/45750737">http://blog.csdn.net/u014800748/article/details/45750737</a></p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNOI2008 玩具装箱Toy（详解）</title>
      <link href="/2017/03/10/HNOI2008-toy/"/>
      <url>/2017/03/10/HNOI2008-toy/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/10/%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy/">原文</a>）</p></div><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P3195">Luogu 3195</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://www.ipicbed.com/images/2022/01/09/toy.png" alt="题目描述"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>设$dp[i]$为处理前$i$个玩具的最小花费，$a[i]$为前$i$个玩具长度的前缀和。</p><p>易得转移方程为$dp[i]=min \lbrace  dp[j]+(i−j−1+a[i]−a[j]−l)^2 \rbrace (0 \leq i &lt; j \leq n)$</p><p>此方法时间复杂度为$O(n^2)$，只能水到20分。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,dp[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>+a[i]-a[j]-l)*(i-j<span class="number">-1</span>+a[i]-a[j]-l));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。</p><p>斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，一般可以通过决策表的方法进行验证，对于此题来说，数据容易生成，可以尝试一下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,dp[N],a[N],best[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>+a[i]-a[j]-l)*(i-j<span class="number">-1</span>+a[i]-a[j]-l))，best[i]=j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,best[i]);<span class="comment">//决策表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>易观察到$best[i]$单调不降，满足决策单调性。</p><p>证明见下：</p><p>对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有</p><p>$$dp[k]+(i−k−1+a[i]−a[k]−l)^2 &lt; dp[j]+(i−j−1+a[i]−a[j]−l)^2$$</p><p>$$dp[k]−dp[j] &lt; (i−j−1+a[i]−a[j]−l)^2−(i−k−1+a[i]−a[k]−l)^2$$</p><p>对于该方程，可设</p><p>$$b[i]=a[i]+i$$</p><p>$$l=l+1$$</p><p>则有</p><p>$$dp[k]−dp[j]&lt;(b[i]−b[j]−l)^2−(b[i]−b[k]−l)^2$$</p><p>化简得</p><p>$$((dp[k]+b[k]^2)−(dp[j]+b[j]^2))/(b[k]−b[j])&lt;2b[i]−2l$$</p><p>此时的形式为点斜式方程：</p><p>$$(yk−yj)/(xk−xj) &lt; ansi$$</p><p>已知$b[i]$为前缀和的形式，所以$b[i]$单调递增，可知斜率为单调递增。则适用决策单调性。</p><p>设</p><p>$$g[k,j]=(yk−yj)/(xk−xj)$$</p><p>则当且仅当$g[A1,A2] &lt; b[i]−2l$时，由$A1$转移而来优于$A2$。</p><p><strong>当$g[c,b] &lt; g[b,a]$时,易证得$b$必不为最优决策。</strong></p><p><strong>当$g[c,b] &lt; ansi$，此时$c$决策优于$b$，则$b$一定不为最优决策。</strong></p><p><strong>当$g[c,b]&gt;=ansi$，此时$b$决策优于$c$，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时$b$决策不优于$a$决策。</strong></p><p><strong>综上所述，则可将所有满足$g[c,b] &lt; g[b,a]$的决策$b$排除掉。此时函数满足上凸的性质，即有斜率递减。</strong></p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p><strong>以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：</strong></p><p><strong>1： 用单调队列维护点集信息。</strong></p><p><strong>2： 求解$dp[i]$，可以从队首开始扫描，当$g(head+1,head) &lt; ansi$时，可知$head+1$优于$head$，故继续扫描，直到不满足条件，此时$bext[i]=head$,即使$dp[i]$最优的决策为队首。</strong></p><p><strong>3： 当加入点$i$，我们要维护队列的上凸性质,即从队尾开始扫描，判断$g(i,tail)$是否小于$g(tail，tail-1)$，如果满足，则可删除$tail$，并继续扫描，直到不满足该条件，则$i$在此处入队，队列仍满足上凸性质。</strong></p><p>AC代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,a[N],b[N],dp[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">g</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k,<span class="keyword">long</span> <span class="keyword">long</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,a+i),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)b[i]=a[i]+i;</span><br><span class="line">    l++;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="built_in">g</span>(q[head+<span class="number">1</span>],q[head])&lt;<span class="number">2</span>*b[i]<span class="number">-2</span>*l)head++;</span><br><span class="line">        <span class="keyword">int</span> j=q[head];</span><br><span class="line">        dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="built_in">g</span>(i,q[tail])&lt;<span class="built_in">g</span>(q[tail],q[tail<span class="number">-1</span>]))tail--;</span><br><span class="line">        q[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Monotonicity In Decision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组十三题</title>
      <link href="/2017/03/08/13problems/"/>
      <url>/2017/03/08/13problems/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98/#more">原文</a>）</p></div><h1 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h1><p><a href="https://wenku.baidu.com/view/ed1be61e10a6f524ccbf85fd.html">后缀数组——处理字符串的有力工具–罗穗骞</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="POJ1743-Musical-Theme"><a href="#POJ1743-Musical-Theme" class="headerlink" title="POJ1743 Musical Theme"></a>POJ1743 Musical Theme</h2><p>本题题目描述与论文略有差别。</p><p>应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..））</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">1</span>,j=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>,maxsa=<span class="number">-1</span>,minsa=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(h[i]&lt;k)maxsa=<span class="number">-1</span>,minsa=inf;</span><br><span class="line">    <span class="keyword">if</span>(sa[i]&lt;minsa)minsa=sa[i];</span><br><span class="line">    <span class="keyword">if</span>(sa[i]&gt;maxsa)maxsa=sa[i];</span><br><span class="line">    <span class="keyword">if</span>(maxsa-minsa&gt;k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">    <span class="keyword">if</span>(!n)<span class="keyword">break</span>;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    s[<span class="number">0</span>]=s[<span class="number">1</span>]-x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;++i)s[i]=s[i+<span class="number">1</span>]-s[i];</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)s[i]+=<span class="number">150</span>;</span><br><span class="line">    <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">getheight</span>(n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1e6</span>,ans;</span><br><span class="line">    <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">can</span>(ans,n))  l=ans;</span><br><span class="line">        <span class="keyword">else</span>      r=ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(l)&gt;=<span class="number">5</span>?l:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3261-Milk-Patterns"><a href="#POJ3261-Milk-Patterns" class="headerlink" title="POJ3261 Milk Patterns"></a>POJ3261 Milk Patterns</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];</span><br><span class="line"><span class="keyword">int</span> s[N],k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&lt;ans)tot=<span class="number">0</span>;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot==k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,s+i);</span><br><span class="line">    <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">getheight</span>(n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n+<span class="number">1</span>,ans,mid;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n))ans=l=mid;</span><br><span class="line">        <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ694-Distinct-Substrings"><a href="#SPOJ694-Distinct-Substrings" class="headerlink" title="SPOJ694 Distinct Substrings"></a>SPOJ694 Distinct Substrings</h2><p>这题论文中的方法不太好想，可以换一种思路。</p><p>易证长度为$len$的字符串一共有$(len+1)∗len/2$个子串。</p><p>而其中重复的字串个数则为height数组的总和，减去即可。</p><p>以这一组数据为例，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sa[i-1]  abba</span><br><span class="line">sa[i]    abcd //height[i] = 2</span><br></pre></td></tr></table></figure><p>两者相同的字串有$2∗(2+1)/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。</p><p>这个例子中只应减去$a,ab$这两个重复字符，之后必有两个后缀为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bba</span><br><span class="line">bcd //height = 1</span><br></pre></td></tr></table></figure><p>重复的子串$b$ 将在此处减掉。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e4</span>+<span class="number">5</span>;       </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;       </span><br><span class="line"><span class="keyword">char</span> s[N];   </span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],tong[N],wv[N];      </span><br><span class="line"><span class="keyword">int</span> rank[N],height[N];      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> t;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);  </span><br><span class="line">    <span class="keyword">while</span>(t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);  </span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);   </span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,<span class="number">128</span>);  </span><br><span class="line">        <span class="built_in">calheight</span>(n);  </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=n*(n+<span class="number">1</span>)/<span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        ans-=height[i];  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ705-不同的子串"><a href="#SPOJ705-不同的子串" class="headerlink" title="SPOJ705 不同的子串"></a>SPOJ705 不同的子串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>*r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,i=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line"><span class="built_in">getheight</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)sa[i]++;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans+=n-sa[i]-(i==<span class="number">1</span>?<span class="number">0</span>:h[i])+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URAL1297-Palindrome"><a href="#URAL1297-Palindrome" class="headerlink" title="URAL1297 Palindrome"></a>URAL1297 Palindrome</h2><p>这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tong[N],wv[N],wa[N],wb[N];</span><br><span class="line"><span class="keyword">int</span> rank1[N],height[N],sa[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=a[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)rank1[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank1[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank1[i]<span class="number">-1</span>];a[i+k]==a[j+k];k++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preRMQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">1</span>;i++)dp[i][<span class="number">0</span>]=height[i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=<span class="number">2</span>*n+<span class="number">1</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=<span class="number">2</span>*n+<span class="number">1</span>;i++)</span><br><span class="line">    dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=rank1[l],b=rank1[r];</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">int</span> t=(<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="built_in"><span class="keyword">double</span></span>(b-a+<span class="number">1</span>))/<span class="built_in">log</span>(<span class="number">2.00</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[a][t],dp[b-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,res,flag,max;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        max=<span class="number">0</span>;</span><br><span class="line">        n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)a[i]=(<span class="keyword">int</span>)s[i];</span><br><span class="line">        a[n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)a[i+n+<span class="number">1</span>]=<span class="built_in"><span class="keyword">int</span></span>(s[n-i<span class="number">-1</span>]);</span><br><span class="line">        a[<span class="number">2</span>*n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(<span class="number">2</span>*n+<span class="number">2</span>,<span class="number">123</span>);</span><br><span class="line">        <span class="built_in">calheight</span>(<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">preRMQ</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">lcp</span>(i,<span class="number">2</span>*n-i)*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;res)max=res,flag=i;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res=<span class="built_in">lcp</span>(i,<span class="number">2</span>*n-i+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;res) max=res,flag=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max%<span class="number">2</span>==<span class="number">1</span>)<span class="keyword">for</span>(i=flag-max/<span class="number">2</span>;i&lt;=flag+max/<span class="number">2</span>;i++)   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(i=flag-max/<span class="number">2</span>;i&lt;=flag+max/<span class="number">2</span><span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ2406-Power-Strings"><a href="#POJ2406-Power-Strings" class="headerlink" title="POJ2406 Power Strings"></a>POJ2406 Power Strings</h2><p>本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个$logn$。</p><h2 id="POJ3693-Maximum-repetition-substring"><a href="#POJ3693-Maximum-repetition-substring" class="headerlink" title="POJ3693 Maximum repetition substring"></a>POJ3693 Maximum repetition substring</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];</span><br><span class="line"><span class="keyword">int</span> k,now,jj,maxr,cnt;</span><br><span class="line"><span class="keyword">int</span> d[N][<span class="number">21</span>],ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line"><span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prermq</span><span class="params">(<span class="keyword">int</span>*a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)d[i][<span class="number">0</span>]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;++j)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;n;++i)</span><br><span class="line">d[i][j]=<span class="built_in">min</span>(d[i][j<span class="number">-1</span>],d[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">askrmq</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">l=rank[l],r=rank[r];</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="built_in">swap</span>(l,r);</span><br><span class="line">l++;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>))&lt;=r-l+<span class="number">1</span>)k++;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(d[l][k],d[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ccase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(tong,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tong));</span><br><span class="line"><span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">ccase++;</span><br><span class="line">k=now=jj=maxr=cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line"><span class="built_in">getheight</span>(n);</span><br><span class="line"><span class="built_in">prermq</span>(h,n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;n;j+=i) </span><br><span class="line">&#123;</span><br><span class="line">k=<span class="built_in">askrmq</span>(j,j+i);</span><br><span class="line">now=k/i+<span class="number">1</span>;</span><br><span class="line">jj=j-(i-k%i);</span><br><span class="line"><span class="keyword">if</span> (jj&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">askrmq</span>(jj,jj+i)&gt;=(i-k%i))++now;</span><br><span class="line"><span class="keyword">if</span>(now&gt;maxr)    &#123;cnt=<span class="number">0</span>;maxr=now;ans[cnt++]=i;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(now==maxr)  ans[cnt++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">askrmq</span>(sa[i],sa[i]+ans[j])&gt;=(maxr<span class="number">-1</span>)*ans[j])</span><br><span class="line">&#123;</span><br><span class="line">    jj=sa[i],k=ans[j];</span><br><span class="line">    <span class="keyword">goto</span> dd;</span><br><span class="line">&#125;</span><br><span class="line">dd:;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,ccase);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxr*k;++i)<span class="built_in">putchar</span>(s[jj++]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ687-重复的字符串"><a href="#SPOJ687-重复的字符串" class="headerlink" title="SPOJ687 重复的字符串"></a>SPOJ687 重复的字符串</h2><p>暂略。</p><h2 id="POJ2774-Long-Long-Message"><a href="#POJ2774-Long-Long-Message" class="headerlink" title="POJ2774 Long Long Message"></a>POJ2774 Long Long Message</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],wv[N],tong[maxf+<span class="number">1</span>],rank[N],h[N];</span><br><span class="line"><span class="keyword">char</span> s[N],ss[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;m=p,j&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)wv[i]=x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),p=<span class="number">1</span>,i=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;longlongmessage.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;longlongmessage.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),m=<span class="built_in">strlen</span>(ss);</span><br><span class="line">    s[n]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+m;++i)s[i]=ss[i-n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> l=n+m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">da</span>(l+<span class="number">1</span>,maxf);</span><br><span class="line">    <span class="built_in">geth</span>(l);</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=l;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i<span class="number">-1</span>]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i<span class="number">-1</span>]&lt;n)))</span><br><span class="line">        maxx=h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3415-Common-Substrings"><a href="#POJ3415-Common-Substrings" class="headerlink" title="POJ3415 Common Substrings"></a>POJ3415 Common Substrings</h2><p>暂略。</p><h2 id="POJ3294-生命形态"><a href="#POJ3294-生命形态" class="headerlink" title="POJ3294 生命形态"></a>POJ3294 生命形态</h2><p>本题和上题都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="keyword">int</span> sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">111</span>][<span class="number">10001</span>],s[N];</span><br><span class="line"><span class="keyword">int</span> nn[<span class="number">111</span>],tt;</span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">111</span>];</span><br><span class="line"><span class="keyword">int</span> ll[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>,p=<span class="number">1</span>,<span class="built_in">swap</span>(x,y),x[sa[<span class="number">0</span>]]=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(j=sa[rank[i]<span class="number">-1</span>],k?k--:<span class="number">0</span>;s[j+k]==s[i+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> ansg;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tot1=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));  tot1=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nowq,nowt;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])nowt=t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;</span><br><span class="line">                <span class="keyword">if</span>(!inq[nowq])tot1++,inq[nowq]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!inq[nowt])tot1++,inq[nowt]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot1&gt;=k)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> lll=inf,rrr=<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">int</span> tot1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));  tot1=<span class="number">0</span>;</span><br><span class="line">              lll=inf;rrr=<span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">int</span> nowq,nowt;</span><br><span class="line">              <span class="keyword">if</span>(sa[i<span class="number">-1</span>]&lt;lll)lll=sa[i<span class="number">-1</span>];<span class="keyword">if</span>(sa[i<span class="number">-1</span>]&gt;rrr)rrr=sa[i<span class="number">-1</span>];</span><br><span class="line">              <span class="keyword">if</span>(sa[i]&lt;lll)lll=sa[i];<span class="keyword">if</span>(sa[i]&gt;rrr)rrr=sa[i];</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])nowt=t;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=tt;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;</span><br><span class="line">              <span class="keyword">if</span>(!inq[nowq])tot1++,inq[nowq]=<span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span>(!inq[nowt])tot1++,inq[nowt]=<span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">if</span>(tot1==k)ll[++ansg]=lll;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tt)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(wa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wa));</span><br><span class="line">        <span class="built_in">memset</span>(wb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wb));</span><br><span class="line">        <span class="built_in">memset</span>(wv,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wv));</span><br><span class="line">        <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">        <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">memset</span>(nn,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nn));</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">2</span>;</span><br><span class="line">        ansg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss[i]);</span><br><span class="line">            nn[i]=<span class="built_in">strlen</span>(ss[i]);</span><br><span class="line">            nn[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;nn[i];++t)s[tot++]=ss[i][t];</span><br><span class="line">            nn[i]+=nn[i<span class="number">-1</span>]+(i==tt?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i!=tt)s[tot++]=tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        nn[tt]++;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">        <span class="built_in">geth</span>(n);</span><br><span class="line">        k=(tt)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n+<span class="number">1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n,<span class="number">0</span>))  l=mid;</span><br><span class="line">            <span class="keyword">else</span>      r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);<span class="keyword">goto</span> dd;&#125;</span><br><span class="line">        <span class="built_in">can</span>(l,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ansg;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;l;++t)<span class="keyword">if</span>(s[ll[i]+t]!=s[ll[i<span class="number">-1</span>]+t])&#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=ll[i];t&lt;=ll[i]+l<span class="number">-1</span>;++t)<span class="built_in">putchar</span>(s[t]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dd:;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPOJ220-破译进攻计划"><a href="#SPOJ220-破译进攻计划" class="headerlink" title="SPOJ220 破译进攻计划"></a>SPOJ220 破译进攻计划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxf = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];</span><br><span class="line"><span class="keyword">char</span> s[N],ss[<span class="number">13</span>][<span class="number">15031</span>];</span><br><span class="line"><span class="keyword">int</span> inq[<span class="number">13</span>],maxq[<span class="number">13</span>],minq[<span class="number">13</span>];</span><br><span class="line"><span class="keyword">int</span> tt,num;</span><br><span class="line"><span class="keyword">bool</span> use[<span class="number">13</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)sa[--tong[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;++i)y[p++]=i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)<span class="keyword">if</span>(sa[i]&gt;=j)y[p++]=sa[i]-j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;++i)tong[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)tong[i]+=tong[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)sa[--tong[wv[i]]]=y[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">swap</span>(x,y),x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>,p=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        x[sa[i]]=<span class="built_in">cmp</span>(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geth</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)rank[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;h[rank[i++]]=k)</span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> ans,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&lt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            tot=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">            <span class="built_in">memset</span>(maxq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(maxq));</span><br><span class="line">            <span class="built_in">memset</span>(minq,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(minq));</span><br><span class="line">            <span class="built_in">memset</span>(use,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(use));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=num;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t])</span><br><span class="line">            &#123;</span><br><span class="line">                inq[t]++;</span><br><span class="line">                minq[t]=<span class="built_in">min</span>(minq[t],sa[i]);</span><br><span class="line">                maxq[t]=<span class="built_in">max</span>(maxq[t],sa[i]);</span><br><span class="line">                <span class="keyword">if</span>(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot==num)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=num;++t)<span class="keyword">if</span>(nn[t<span class="number">-1</span>]&lt;sa[i<span class="number">-1</span>]&amp;&amp;sa[i<span class="number">-1</span>]&lt;nn[t])</span><br><span class="line">            &#123;</span><br><span class="line">                inq[t]++;</span><br><span class="line">                minq[t]=<span class="built_in">min</span>(minq[t],sa[i<span class="number">-1</span>]);</span><br><span class="line">                maxq[t]=<span class="built_in">max</span>(maxq[t],sa[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tot==num)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    nn[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt);</span><br><span class="line">    <span class="keyword">while</span>(tt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(inq));</span><br><span class="line">        <span class="built_in">memset</span>(wa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wa));</span><br><span class="line">        <span class="built_in">memset</span>(wb,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wb));</span><br><span class="line">        <span class="built_in">memset</span>(wv,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wv));</span><br><span class="line">        <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(rank));</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>,qiguaizifu=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss[i]);</span><br><span class="line">            nn[i]=<span class="built_in">strlen</span>(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;nn[i];++t)</span><br><span class="line">            s[tot++]=ss[i][t];</span><br><span class="line">            s[tot++]=qiguaizifu++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)nn[i]+=(nn[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">da</span>(n+<span class="number">1</span>,maxf);</span><br><span class="line">        <span class="built_in">geth</span>(n);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">can</span>(mid,n))  l=mid;</span><br><span class="line">            <span class="keyword">else</span>      r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ1226-Substrings"><a href="#POJ1226-Substrings" class="headerlink" title="POJ1226 Substrings"></a>POJ1226 Substrings</h2><p>暂略。</p>]]></content>
      
      
      <categories>
          
          <category> OI / ACM (Algo. Competition) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> Data Structure </tag>
            
            <tag> String Manipulation </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ Coding Style</title>
      <link href="/2017/03/07/C-C++-Coding-Style/"/>
      <url>/2017/03/07/C-C++-Coding-Style/</url>
      
        <content type="html"><![CDATA[<div class="note info modern"><p>本文移植自个人的原博客（<a href="http://deprecated.tong-su.com/2017/03/07/c++%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">原文</a>）</p></div><p>C/C++代码规范。包括命名规则，排版规则，文档及注释，编码要求等等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://www.ipicbed.com/images/2022/01/08/C-CodingStyle.png" alt="C/C++ Google Coding Style"></p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="起个合适的名字"><a href="#起个合适的名字" class="headerlink" title="起个合适的名字"></a>起个合适的名字</h2><h3 id="类的名称"><a href="#类的名称" class="headerlink" title="类的名称"></a>类的名称</h3><p>类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p><p>类的名字不需要告诉我们，它从哪个类继承而来的。</p><p>有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p><h3 id="方法和函数的名称"><a href="#方法和函数的名称" class="headerlink" title="方法和函数的名称"></a>方法和函数的名称</h3><p>方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p><p>函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p><p>可以加一些必要的后缀：</p><p>Max – 表示取最大值。</p><p>Cnt – 表示当前的计数值。</p><p>Key – 表示键值。</p><p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p><p>前缀也同样有用：</p><p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p><p>Get – 用于获取一个值。</p><p>Set – 用于设置一个值。</p><p>例如：IsHitRetryLimit。</p><h3 id="含有度量单位的名称"><a href="#含有度量单位的名称" class="headerlink" title="含有度量单位的名称"></a>含有度量单位的名称</h3><p>如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint32 mTimeoutMsecs;</span><br><span class="line">uint32 mMyWeightLbs;</span><br></pre></td></tr></table></figure><h3 id="缩写名称不要全部大写"><a href="#缩写名称不要全部大写" class="headerlink" title="缩写名称不要全部大写"></a>缩写名称不要全部大写</h3><p>无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FluidOz</span>;</span>            <span class="comment">// 而不是 FluidOZ</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkAbcKey</span>;</span>      <span class="comment">// 而不是 NetworkABCKey</span></span><br></pre></td></tr></table></figure><h2 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h2><p>用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p><p>名字的第一个字母应大写。</p><p>不含有下划线。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>;</span></span><br></pre></td></tr></table></figure><h2 id="类库或程序库命名"><a href="#类库或程序库命名" class="headerlink" title="类库或程序库命名"></a>类库或程序库命名</h2><p>使用命名空间防止名字冲突。</p><p>如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p><p>例如：（Tong Su 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TsLinkList</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数的命名"><a href="#方法和函数的命名" class="headerlink" title="方法和函数的命名"></a>方法和函数的命名</h2><p>使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoIt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类属性的命名"><a href="#类属性的命名" class="headerlink" title="类属性的命名"></a>类属性的命名</h2><p>属性（通常是非公有数据成员）名字以字母’m’开头。</p><p>在 ‘m(m_)’ 后面，使用与类名相同的规则。</p><p>‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">VarAbc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ErrorNumber</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mVarAbc;</span><br><span class="line"><span class="keyword">int</span> mErrorNumber;</span><br><span class="line">String* mpName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数参数的命名"><a href="#方法和函数参数的命名" class="headerlink" title="方法和函数参数的命名"></a>方法和函数参数的命名</h2><p>第一个字母必须小写。</p><p>第一个字母后面的单词使用与类名相同的规则。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameOneTwo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StartYourEngines</span><span class="params">(Engine&amp;rSomeEngine,Engine&amp;rAnotherEngine)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量的命名"><a href="#局部变量的命名" class="headerlink" title="局部变量的命名"></a>局部变量的命名</h2><p>所有字母都用小写。</p><p>使用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NameOneTwo::HandleError</span><span class="params">(<span class="keyword">int</span> errorNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error= <span class="built_in">OsErr</span>();</span><br><span class="line">Time time_of_error;</span><br><span class="line">ErrorProcessor error_processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针变量的命名前缀"><a href="#指针变量的命名前缀" class="headerlink" title="指针变量的命名前缀"></a>指针变量的命名前缀</h2><p>指针变量多数情况应在前面加 ‘p’。</p><p>星号应靠近类型，而不是变量名。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String* pName=<span class="keyword">new</span> String;</span><br></pre></td></tr></table></figure><p>特别的：String* pName, name; 应分成两行来写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String* pName;</span><br><span class="line">String  name;</span><br></pre></td></tr></table></figure><h2 id="引用变量和返回引用函数的命名前缀"><a href="#引用变量和返回引用函数的命名前缀" class="headerlink" title="引用变量和返回引用函数的命名前缀"></a>引用变量和返回引用函数的命名前缀</h2><p>引用必须用‘r’作前缀修饰。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(StatusInfo&amp;rStatus)</span></span>;</span><br><span class="line"><span class="function">StatusInfo&amp; <span class="title">rStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">constStatusInfo&amp; <span class="title">Status</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 这里返回的是常量引用，所以不符合本规则</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StatusInfo&amp; mrStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局变量的命名前缀"><a href="#全局变量的命名前缀" class="headerlink" title="全局变量的命名前缀"></a>全局变量的命名前缀</h2><p>全局变量总是以 ‘g(g_)’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger g_Log;</span><br><span class="line">Logger* g_pLog;</span><br></pre></td></tr></table></figure><h2 id="全局常量的命名"><a href="#全局常量的命名" class="headerlink" title="全局常量的命名"></a>全局常量的命名</h2><p>全局常量全部大写，并以下划线分隔单词。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intA_GLOBAL_CONSTANT = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="静态变量的命名前缀"><a href="#静态变量的命名前缀" class="headerlink" title="静态变量的命名前缀"></a>静态变量的命名前缀</h2><p>静态变量以 ‘s’ 作为前缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">staticStatusInfo m_sStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类型typedef的命名"><a href="#自定义类型typedef的命名" class="headerlink" title="自定义类型typedef的命名"></a>自定义类型typedef的命名</h2><p>类型定义名称指的是用typedef定义的名称。</p><p>类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint16  ModuleType;</span><br><span class="line"><span class="keyword">typedef</span> uint32  SystemType;</span><br></pre></td></tr></table></figure><h2 id="宏定义的命名"><a href="#宏定义的命名" class="headerlink" title="宏定义的命名"></a>宏定义的命名</h2><p>所有单词的字母都用大写，并使用下划线分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) blah</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ERR(err) blah</span></span><br></pre></td></tr></table></figure><h2 id="C-函数的命名"><a href="#C-函数的命名" class="headerlink" title="C 函数的命名"></a>C 函数的命名</h2><p>C++项目中，应尽量少用C函数。</p><p>C函数使用GNU规范，所有字母都使用小写，并用下划线作为单词的分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，为了兼容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” <span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>或在C/C++中推荐使用下面的格式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#ifdef__cplusplus__</span><br><span class="line"><span class="keyword">extern</span> “C”&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_bloody_function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">#ifdef__cplusplus__</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="枚举的命名"><a href="#枚举的命名" class="headerlink" title="枚举的命名"></a>枚举的命名</h2><p>所有字母都大写，并用下划线作为单词分隔。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">enumPinStateType&#123;</span><br><span class="line">PIN_OFF,</span><br><span class="line">PIN_ON;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>STATE_ERR,STATE_OPEN,STATE_RUNNING,STATE_DYING&#125;;</span><br></pre></td></tr></table></figure><h1 id="排版规则"><a href="#排版规则" class="headerlink" title="排版规则"></a>排版规则</h1><h2 id="布局和模板"><a href="#布局和模板" class="headerlink" title="布局和模板"></a>布局和模板</h2><h3 id="类的布局模板"><a href="#类的布局模板" class="headerlink" title="类的布局模板"></a>类的布局模板</h3><p>请使用下面的模板来创建一个新的类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment"> * 用一行来描述类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *#include &quot;XX.h&quot; &lt;BR&gt;</span></span><br><span class="line"><span class="comment"> *-llib</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类的详细说明</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @seesomething</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="comment">// 在这里包含系统头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含项目头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里包含局部头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置前置引用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XX</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 类的生命周期控制函数，如构造和析构，以及状态机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***Default constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">/***Copy constructor.*/</span></span><br><span class="line"><span class="built_in">XX</span>(<span class="keyword">const</span> XX&amp; from);</span><br><span class="line"><span class="comment">/***Destructor.*/</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">XX</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 在这里放置类的运算操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Assignment operator.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@param from THe value to assign to this object.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*@return A reference to this object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">XX&amp; <span class="keyword">operator</span>=(XX&amp;from); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的操作                      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置属性存取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里放置类的状态查询</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 内联方法定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>定义的顺序是: public, protected, private。</p><p>要清楚public/protected/private都应该放置哪些东西。</p><h3 id="保护头文件不被重复包含"><a href="#保护头文件不被重复包含" class="headerlink" title="保护头文件不被重复包含"></a>保护头文件不被重复包含</h3><p>应使用宏定义来保护头文件不被重复包含：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SORUTION_PROJECT_CLASSNAME_H</span></span></span><br></pre></td></tr></table></figure><p>如果使用命名空间的时候，要把命名空间加到文件名前面：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORUTION_PROJECT_NAMESPACE_CLASSNAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="方法和函数的布局"><a href="#方法和函数的布局" class="headerlink" title="方法和函数的布局"></a>方法和函数的布局</h3><p>对于有较多参数的函数的写法。</p><p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg1, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg2,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> arg4)</span></span>; </span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AnyMethod</span><span class="params">(<span class="keyword">int</span> arg1 </span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg2</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg3</span></span></span><br><span class="line"><span class="params"><span class="function">             ,<span class="keyword">int</span> arg4)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="尽量使一行不要超过78个字母"><a href="#尽量使一行不要超过78个字母" class="headerlink" title="尽量使一行不要超过78个字母"></a>尽量使一行不要超过78个字母</h2><p>有许多编辑器屏幕只有78个字母宽。</p><h2 id="保证一行只写一条语句"><a href="#保证一行只写一条语句" class="headerlink" title="保证一行只写一条语句"></a>保证一行只写一条语句</h2><p>一行最多只写一条语句。</p><p>一行只定义一个变量。</p><h2 id="圆括号规则"><a href="#圆括号规则" class="headerlink" title="圆括号规则"></a>圆括号规则</h2><p>圆括号与关键字之间应放一个空格。</p><p>圆括号与函数名之间不要有空格。</p><p>Return 语句不要使用圆括号。</p><h2 id="使用goto-continue-break-和"><a href="#使用goto-continue-break-和" class="headerlink" title="使用goto continue break 和?:"></a>使用goto continue break 和?:</h2><h3 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h3><p>尽量避免使用Goto 语句。</p><h3 id="Continue-and-Break"><a href="#Continue-and-Break" class="headerlink" title="Continue and Break"></a>Continue and Break</h3><p>Continue和break实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p><h3 id="A-B-C"><a href="#A-B-C" class="headerlink" title="A?B:C"></a>A?B:C</h3><p>用括号把条件表达式括起来。</p><p>不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p><p>操作语句应分行写，除非它们能够简洁的放在一行当中。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(condition) ?<span class="built_in">funct1</span>() : <span class="built_in">func2</span>();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(condition)</span><br><span class="line">? longstatement</span><br><span class="line">: anotherlong statement;</span><br></pre></td></tr></table></figure><h2 id="运算符号的规则"><a href="#运算符号的规则" class="headerlink" title="运算符号的规则"></a>运算符号的规则</h2><p>一元操作符如（!、~ 等等）应贴近操作对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IsOk)</span><br><span class="line">    <span class="keyword">return</span> ++v;</span><br></pre></td></tr></table></figure><p>二元操作符如（+、%、== 等等）应在前后留空格。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 == v2)</span><br><span class="line">     <span class="keyword">return</span> v1 * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。</p><h2 id="变量声明语句块"><a href="#变量声明语句块" class="headerlink" title="变量声明语句块"></a>变量声明语句块</h2><p>变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。</p><p>声明语句块必须要对齐。类型，变量，等号和初始化值要分别对齐。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DWORD      mDword;</span><br><span class="line">DWORD*     mpDword;</span><br><span class="line"><span class="keyword">char</span>*      mpChar;</span><br><span class="line"><span class="keyword">char</span>       mChar;</span><br><span class="line"></span><br><span class="line">mDword     =    <span class="number">0</span>;</span><br><span class="line">mpDword    =    <span class="literal">NULL</span>;</span><br><span class="line">mpChar     =    <span class="literal">NULL</span>;</span><br><span class="line">mChar      =    <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="文档及注释"><a href="#文档及注释" class="headerlink" title="文档及注释"></a>文档及注释</h1><p>应当使用文档自动生成工具，来生成相关的程序文档。</p><h2 id="文件或程序库的文档注释"><a href="#文件或程序库的文档注释" class="headerlink" title="文件或程序库的文档注释"></a>文件或程序库的文档注释</h2><p>可以为整个文件编写文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @file file.h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Abrief file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Amore elaborated file description.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="类文档注释"><a href="#类文档注释" class="headerlink" title="类文档注释"></a>类文档注释</h2><p>在类定义前面应加上类说明文档。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** WindowsNT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @brief Windows Nice Try.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Bill Gates</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @author Several species of small furryanimals gathered together</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *          in a cave and grooving with a pict.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @version 4.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @date   1996-1998</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug It crashes a lot and requires hugeamounts of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @bug The class introduces the more bugs, thelonger it is used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning This class may explode in your face.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  @warning If you inherit anything from thisclass, you&#x27;re doomed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsNT</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数文档注释"><a href="#函数文档注释" class="headerlink" title="函数文档注释"></a>函数文档注释</h2><p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 赋值操作符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param val 将要赋给本对象的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return 本对象的引用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">XX&amp;  <span class="keyword">operator</span> =(XX&amp; val);</span><br></pre></td></tr></table></figure><p>注释属性</p><p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p><p>n 前提条件 (pre)<br>定义调用这个函数的前提条件</p><p>n 警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p><p>n 备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p><p>n 将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成。</p><p>n 使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 复制一个字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@pre</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(from != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*     - 需要保证(to != 0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@warning</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 缓冲区必需足够大，以便容纳的下要拷贝的字串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@example teststrcpy.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param from 要拷贝的字串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@param to 用于容纳字串的缓冲区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*@return void</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">strcpy</span><span class="params">(constchar* from, <span class="keyword">char</span>* to)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Include-语句注释"><a href="#Include-语句注释" class="headerlink" title="Include 语句注释"></a>Include 语句注释</h2><p>如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p><h2 id="语句块注释"><a href="#语句块注释" class="headerlink" title="语句块注释"></a>语句块注释</h2><p>语句块的注释可以用在语句块的开头和结束位置：</p><h1 id="编码要求"><a href="#编码要求" class="headerlink" title="编码要求"></a>编码要求</h1><h2 id="不要忽略编译器的警告"><a href="#不要忽略编译器的警告" class="headerlink" title="不要忽略编译器的警告"></a>不要忽略编译器的警告</h2><p>编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p><h2 id="应使用源代码管理器"><a href="#应使用源代码管理器" class="headerlink" title="应使用源代码管理器"></a>应使用源代码管理器</h2><p>根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p><h2 id="固有的类方法成员"><a href="#固有的类方法成员" class="headerlink" title="固有的类方法成员"></a>固有的类方法成员</h2><p>默认构造函数(DefaultConstructor)</p><p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p><p>虚析构函数(Virtual Destructor)</p><p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p><p>拷贝构造函数(Copy Constructor)</p><p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p><p>赋值操作(AssignmentOperator)</p><p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p><h2 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h2><p>根名字一般是设计者的名字。比如公司名称等等。</p><p>不要在全局空间使用using语句。</p><h2 id="初始化所有的变量"><a href="#初始化所有的变量" class="headerlink" title="初始化所有的变量"></a>初始化所有的变量</h2><p>无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p><h2 id="保持函数短小精悍"><a href="#保持函数短小精悍" class="headerlink" title="保持函数短小精悍"></a>保持函数短小精悍</h2><p>一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p><h2 id="对空语句进行注释"><a href="#对空语句进行注释" class="headerlink" title="对空语句进行注释"></a>对空语句进行注释</h2><p>For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(*dest++ = *srC++)</span><br><span class="line">   ;<span class="comment">// VOID</span></span><br></pre></td></tr></table></figure><h2 id="不要用if语句的默认方法测试非零值"><a href="#不要用if语句的默认方法测试非零值" class="headerlink" title="不要用if语句的默认方法测试非零值"></a>不要用if语句的默认方法测试非零值</h2><p>If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值。</p><p>建议使用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>() != FAIL)</span><br></pre></td></tr></table></figure><p>不建议使用下面的表达式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>())</span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p><h2 id="避免在语句中内含赋值"><a href="#避免在语句中内含赋值" class="headerlink" title="避免在语句中内含赋值"></a>避免在语句中内含赋值</h2><p>只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (EOF != (c= <span class="built_in">getchar</span>()))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确的使用Const"><a href="#正确的使用Const" class="headerlink" title="正确的使用Const"></a>正确的使用Const</h2><p>C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p><h2 id="不要在头文件定义数据"><a href="#不要在头文件定义数据" class="headerlink" title="不要在头文件定义数据"></a>不要在头文件定义数据</h2><p>不要把数据定义放在头文件。</p><h2 id="不要直接使用数字"><a href="#不要直接使用数字" class="headerlink" title="不要直接使用数字"></a>不要直接使用数字</h2><p>直接使用数字，会使源代码难以理解和维护。我们可以用#define或者常量来改变这一状况。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>如果可以，使用内联函数代替宏。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    <span class="comment">// 取最大数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>使用内联函数可以达到相同的效果，而且更安全：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt; y ? x : y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x + y</span></span><br></pre></td></tr></table></figure><p>必须写成：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure><p>和全局变量一样，宏也会与其它名称产生冲突。</p><p>下面两条规则有助于解决这个问题：</p><p>一、在宏名称前加上库的名字</p><p>二、避免使用简单而常用的名字，如：MAX和MIN。</p>]]></content>
      
      
      <categories>
          
          <category> Coding Itself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chinese </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Coding Style </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
